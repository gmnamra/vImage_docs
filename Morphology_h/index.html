<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head>
<title>Morphology.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="HeaderDoc">
<meta name="xcode-display" content="render">
<style type="text/css"><!--.char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;}body {border: 0px; margin: 0px;}div {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}td {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}span.hd_tocAccessSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroupSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroup { display: block; font-weight: bold; font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; margin-left: 0px; padding-left: 40px; }span.hd_tocGroup + span.hd_tocAccess { padding-top: 5px; }td.toc_contents_text {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; }li.tocSubEntry {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}p {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}a:link {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:active {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}h2.h2tight { margin-top: 0px; padding-top: 0px; }h1 { margin-top: 13px; padding-top: 0px; }h4 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: tiny; font-weight: bold;}h5 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: 10.1pt; font-weight: bold;}pre {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666; font-size: 10pt;}pre a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}pre a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}body  {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt; padding-left: 0px; padding-top: 0px; margin-left: 0px; margin-top: 0px; border: none; }#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }.afterName { display: none; }.list_indent { margin-left: 40px; }.declaration_indent { margin-left: 40px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; min-height: 12px; vertical-align: middle; }.declaration_indent pre { margin-top: 20px; padding-top: 0px; margin-bottom: 20px; padding-bottom: 0px; }.gapBeforeFooter { display: none; }hr { height: 0px; min-height: 0px; border-top: none; border-left: none; border-right: none; border-bottom: 1px solid #909090;}hr.afterHeader { display: none }.param_group_indent { margin-left: 25px; }.param_indent { margin-left: 40px; margin-top: 0px; padding-top: 0px; }.param_indent dl { margin-top: 4px; padding-top: 0px; }dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.param_indent dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.group_indent { margin-left: 40px; }.group_desc_indent { margin-left: 20px; }.warning_indent { margin-left: 40px; }.important_indent { margin-left: 40px; }.note_indent { margin-left: 40px; }h3 {       color: #3C4C6C;}.tight {       margin-top: 2px; margin-bottom: 0px;       padding-top: 0px; padding-bottom: 0px;}h3 a {       color: #3C4C6C;	font-size: 16px;	font-style: normal;	font-variant: normal;	font-weight: bold;	height: 0px;	line-height: normal;}.hd_tocAccess { display: block; margin-left: 40px; font-style: italic; font-size: 10px; font-weight: normal; color: #303030; }.tocSubheading { margin-bottom: 4px; }--></style>
<style><!--
body {
    padding: 0px;
    margin: 0px;
    border: 0px;
}
.toc_contents_text {
    padding-left: 1em;
    text-indent: -1em;
}

ul.tocSubEntryList li.tocSubEntry {
    list-style: none;
}

#colorbox {
		display: none;
}
.spec_sheet_line {
		margin-bottom: 1px;
}
.collapsible {
		display: none;
}
.toc_leadspace {
		width: 10; min-width: 10;
}
.disclosure_triangle_td {
		width: 14; min-width: 14;
		font-size: 10px;
		vertical-align: middle;
}
.specbox td {
		font-size: 13px;
}
.specbox td a {
		font-size: 13px;
}
.specbox td code {
		font-size: 13px;
}
.specbox td tt {
		font-size: 13px;
}
.specbox td pre {
		font-size: 13px;
}
.specbox a {
		font-size: 12px;
}
.disclosure_triangle_td a {
		text-decoration: none;
}
.disclosure_triangle_td a:link {
		text-decoration: none;
}
.disclosure_triangle_td a:active {
		text-decoration: none;
}
.disclosure_triangle_td a:visited:hover {
		text-decoration: none;
}
.disclosure_triangle_td a:hover {
		text-decoration: none;
}
.hd_toc_box {
		padding-top: 10px;
		padding-right: 15px;
}.tocSeparator {
		margin-top: 15px;
		padding-bottom: 0px;
		margin-bottom: 0px;
}
.tocSubEntryList {
		margin-left: 0px;
		padding-left: 40px;
		padding-top: 0px;
		margin-top: 2px;
		padding-bottom: 0px;
		margin-bottom: 8px;
}
.hd_toc_heading_table {
		margin-top: 2px;
		margin-bottom: 2px;
}
.hd_toc_entry_table {
		margin-top: 2px;
		margin-bottom: 2px;
}
.tocSubEntry {
		margin-left: 0px;
		padding-left: 0px;
		margin-top: 0px;
		margin-bottom: 1px;
}
.tocSubEntry a {
		font-size: 10pt;
}
.tocSubheading {
		padding-left: 14px;
		margin-left: 0px;
		margin-top: 5px;
		padding-top: 0px;
		font-size: 16px;
		color: #808080;
}

#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }
#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }

#tocMenu {
		border-right: 1px solid #c0c0c0;
		background-color: #f4f4ff;
		top:0px;
		left:0px;
		width:230px;
		height:100%;
}
#bodyContents {
		width: auto;
		padding-left: 15px;
}
--></style>
<style id="disable_before_iOS_5"><!--
#tocMenu {
		position: fixed;
		height: 100%;
		overflow: auto;
}
#bodyContents {
		width: auto;
		left: 235px;
		right: 0;
		padding-left: 15px;
		position: fixed;
		height: 100%;
		overflow-y: scroll;
}
--></style>
<script language="JavaScript" type="text/javascript"><!--
    if (navigator.platform && (navigator.platform.match(/iPad/) || navigator.platform.match(/iPhone/) || navigator.platform.match(/iPod/))) {
        if (navigator.userAgent.match(/OS 1(_\d)+/) ||
            navigator.userAgent.match(/OS 2(_\d)+/) ||
            navigator.userAgent.match(/OS 3(_\d)+/) ||
            navigator.userAgent.match(/OS 4(_\d)+/)) {
                /* Earlier iOS versions require different scrolling gestures with position: fixed. */
                var del_style_elt = document.getElementById("disable_before_iOS_5");
                if (del_style_elt) del_style_elt.parentNode.removeChild(del_style_elt);
        }
    }
// --></script><script language="JavaScript" type="text/javascript"><!--
function getNewHTTPObject()
{
        var xmlhttp;

        /** Special IE only code ... */
        /*@cc_on
          @if (@_jscript_version >= 5)
              try
              {
                  xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');
              }
              catch (e)
              {
                  try
                  {
                      xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');
                  }
                  catch (E)
                  {
                      xmlhttp = false;
                  }
             }
          @else
             xmlhttp = false;
        @end @*/

        /** Every other browser on the planet */
        if (!xmlhttp && typeof XMLHttpRequest != 'undefined')
        {
            try
            {
                xmlhttp = new XMLHttpRequest();
            }
            catch (e)
            {
                xmlhttp = false;
            }
        }

        return xmlhttp;
}

function hidetoc() {
	var toc = document.getElementById('tocMenu');
	var src = toc.getAttribute('src');
	var xhr = getNewHTTPObject();
	xhr.open('GET', src, true);
	xhr.onreadystatechange = function() {
		if(xhr.readyState == 4) {
			var toc = document.getElementById('tocMenu');
			toc.innerHTML = xhr.responseText;
		}
	}
	xhr.send(null);
	var origURL = parent.document.URL;
	var contentURL = origURL.substring(origURL.indexOf('?')+1, origURL.length);
	if (contentURL.length == origURL.length) {
		jumpPos = origURL.substring(origURL.indexOf('#')+1, origURL.length);
	}
	if (contentURL == "hidetoc") {
		var body = document.getElementById('bodyContents');
		if (toc && body) {
			toc.style.display = 'none';
			body.style.marginLeft = '0px';
		}
	}
}

function disclosure_triangle(elt) {
   var linkelt = elt;
   while (elt && elt.tagName != 'TABLE') { elt = elt.parentNode;}
   if (!elt) { return; }
   while (elt && elt.tagName != 'DIV') { elt = elt.nextSibling;}
   if (!elt) { return; }
   if (parseInt(linkelt.getAttribute('state'))) {
      // It's open.  Close it
      linkelt.innerHTML = '&#x25B7;';
      linkelt.setAttribute('state', 0);
      linkelt.setAttribute('class', 'closed_disclosure_triangle');
      elt.style.display = 'none';
   } else {
      // It's closed.  Open it
      linkelt.innerHTML = '&#x25BC;';
      linkelt.setAttribute('state', 1);
      linkelt.setAttribute('class', 'open_disclosure_triangle');
      elt.style.display = 'block';
   }
}
--></script><style type="text/css"><!--.char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;}body {border: 0px; margin: 0px;}div {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}td {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}span.hd_tocAccessSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroupSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroup { display: block; font-weight: bold; font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; margin-left: 0px; padding-left: 40px; }span.hd_tocGroup + span.hd_tocAccess { padding-top: 5px; }td.toc_contents_text {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; }li.tocSubEntry {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}p {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}a:link {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:active {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}h2.h2tight { margin-top: 0px; padding-top: 0px; }h1 { margin-top: 13px; padding-top: 0px; }h4 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: tiny; font-weight: bold;}h5 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: 10.1pt; font-weight: bold;}pre {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666; font-size: 10pt;}pre a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}pre a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}body  {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt; padding-left: 0px; padding-top: 0px; margin-left: 0px; margin-top: 0px; border: none; }#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }.afterName { display: none; }.list_indent { margin-left: 40px; }.declaration_indent { margin-left: 40px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; min-height: 12px; vertical-align: middle; }.declaration_indent pre { margin-top: 20px; padding-top: 0px; margin-bottom: 20px; padding-bottom: 0px; }.gapBeforeFooter { display: none; }hr { height: 0px; min-height: 0px; border-top: none; border-left: none; border-right: none; border-bottom: 1px solid #909090;}hr.afterHeader { display: none }.param_group_indent { margin-left: 25px; }.param_indent { margin-left: 40px; margin-top: 0px; padding-top: 0px; }.param_indent dl { margin-top: 4px; padding-top: 0px; }dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.param_indent dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.group_indent { margin-left: 40px; }.group_desc_indent { margin-left: 20px; }.warning_indent { margin-left: 40px; }.important_indent { margin-left: 40px; }.note_indent { margin-left: 40px; }h3 {       color: #3C4C6C;}.tight {       margin-top: 2px; margin-bottom: 0px;       padding-top: 0px; padding-bottom: 0px;}h3 a {       color: #3C4C6C;	font-size: 16px;	font-style: normal;	font-variant: normal;	font-weight: bold;	height: 0px;	line-height: normal;}.hd_tocAccess { display: block; margin-left: 40px; font-style: italic; font-size: 10px; font-weight: normal; color: #303030; }.tocSubheading { margin-bottom: 4px; }--></style>
</head>
<body bgcolor="#ffffff" onload="hidetoc();">
<!-- headerDoc=Header;  uid=//apple_ref/doc/header/Morphology.h;   name=Morphology.h -->
<a name="//apple_ref/doc/header/Morphology.h"></a>
<table id="hd_outermost_table" height="100%" width="100%"><tr>
<td valign="top" id="tocMenu" src="toc.html"></td>
<td id="bodyContents" valign="top">
<a name="top"></a>
<h1><a name="Morphology.h">Morphology.h</a></h1>
<div class="spec_sheet_info_box"><table cellspacing="0" class="specbox"><tr>
<td scope="row"><b>Includes:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text">
<a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/header/vImage_Types.h" logicalPath="//apple_ref/doc/header/vImage_Types.h" target="_top">&lt;vImage/vImage_Types.h&gt;</a></div></div></td>
</tr></table></div>
<h2>Introduction</h2>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/doc/header/Morphology.h;name=start --><p>Morphology functions modify the shape of dark and light elements in an image.  They can enlarge
light structural elements (Dilate) or make them smaller by making the darker regions larger (Erode).
The filters can be used in combination fill in holes (Dilate then Erode) or remove fine structure
(Erode then Dilate).  The Erode and Dilate filters can themselves have structure. For example, you
can Dilate in the shape of a star, in which case single pixel bright signal (such as stars in a night 
sky) assume a star shape.  Larger structure elements assume something of a star-like shape, but generally will
not become fully recognizable as such until the size of the filter exceeds the size of the image
structure element. A small circular filter can turn a rectangle into a larger rectangle with round corners.
Many other examples abound.
</p>
<p>Min is a special case for an Erode function with a rectangular kernel that contains all the same value.
Max is a special case for a Dilate function with a rectangular kernel that contains all the same value.
Min and Max make use of a faster algorithm that can operate at much reduced cost.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/doc/header/Morphology.h;name=end --><!-- end discussion -->
<hr class="afterClassOrHeaderInfo">
<br><a name="HeaderDoc_groups"><h2 class="h2tight">Groups</h2></a>

<h3>Max</h3>
<div class="group_desc_indent">
<p></p>
<p>A max filter is a special case of a dilate filter, in which the filter elements are all 0. 
This allows a much, much faster algorithm to be used.
</p>
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMax_ARGB8888" logicalPath="//apple_ref/c/func/vImageMax_ARGB8888" target="_top">vImageMax_ARGB8888</a></tt></dt>
<dd><p>Apply a max filter to a ARGB8888 image
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMax_ARGBFFFF" logicalPath="//apple_ref/c/func/vImageMax_ARGBFFFF" target="_top">vImageMax_ARGBFFFF</a></tt></dt>
<dd><p>Apply a max filter to a ARGBFFFF image
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMax_Planar8" logicalPath="//apple_ref/c/func/vImageMax_Planar8" target="_top">vImageMax_Planar8</a></tt></dt>
<dd><p>Apply a max filter to a Planar8 image.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMax_PlanarF" logicalPath="//apple_ref/c/func/vImageMax_PlanarF" target="_top">vImageMax_PlanarF</a></tt></dt>
<dd><p>Apply a max filter to a PlanarF image.
</p></dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>Dilate</h3>
<div class="group_desc_indent">
<p></p>
<p>A dilate filter uses a shaped probe to trace a 3D surface. Imagine the kernel to define a 2D surface with
the third dimension the values in the kernel.  This is then lowered down over the image, itself treated
as a 3D surface. The result image is the height at which the surface makes contact with the image for 
each pixel in the image. In this respect it operates like a scanning electron microscope with an adjustable
probe shape. In code:
               </p>
<pre> 
                  for each pixel result[i][j] in the image{
                      int r = 0;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
                          }
                      }

                      // normalize for kernel center not 0
                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];

                      // saturate overflow to representable range
                      result[i][j] = CLIP( r );
                  }
                </pre>
<p>The ARGB variants apply the filter to the four channels in parallel. It should be noted that the application
of the filter to the image causes the structure elements in the filter to be reflected into the image, reversed 
top to bottom and left to right. Also, if the center of the kernel is not 0, a general lightening of the image
will occur. Some functions will run much faster if the center of the kernel is 0.
</p>
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageDilate_ARGB8888" logicalPath="//apple_ref/c/func/vImageDilate_ARGB8888" target="_top">vImageDilate_ARGB8888</a></tt></dt>
<dd><p>Apply a dilate filter to a ARGB8888 image
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageDilate_ARGBFFFF" logicalPath="//apple_ref/c/func/vImageDilate_ARGBFFFF" target="_top">vImageDilate_ARGBFFFF</a></tt></dt>
<dd><p>Apply a dilate filter to a ARGBFFFF image
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageDilate_Planar8" logicalPath="//apple_ref/c/func/vImageDilate_Planar8" target="_top">vImageDilate_Planar8</a></tt></dt>
<dd><p>Apply a dilate filter to a Planar8 image
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageDilate_PlanarF" logicalPath="//apple_ref/c/func/vImageDilate_PlanarF" target="_top">vImageDilate_PlanarF</a></tt></dt>
<dd><p>Apply a dilate filter to a PlanarF image
</p></dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>Min</h3>
<div class="group_desc_indent">
<p></p>
<p>A min filter is a special case of an erode filter, in which the filter elements are all 0.
This allows a much, much faster algorithm to be used.
</p>
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMin_ARGB8888" logicalPath="//apple_ref/c/func/vImageMin_ARGB8888" target="_top">vImageMin_ARGB8888</a></tt></dt>
<dd><p>Apply a min filter to a ARGB8888 image
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMin_ARGBFFFF" logicalPath="//apple_ref/c/func/vImageMin_ARGBFFFF" target="_top">vImageMin_ARGBFFFF</a></tt></dt>
<dd><p>Apply a min filter to a ARGBFFFF image
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMin_Planar8" logicalPath="//apple_ref/c/func/vImageMin_Planar8" target="_top">vImageMin_Planar8</a></tt></dt>
<dd><p>Apply a min filter to a Planar8 image.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMin_PlanarF" logicalPath="//apple_ref/c/func/vImageMin_PlanarF" target="_top">vImageMin_PlanarF</a></tt></dt>
<dd><p>Apply a min filter to a PlanarF image.
</p></dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>Erode</h3>
<div class="group_desc_indent">
<p></p>
<p>An erode filter uses a shaped probe to trace a 3D surface. Imagine the kernel to define a 2D surface with
the third dimension the values in the kernel.  This is then elevated from underneath the image, itself treated
as a 3D surface. The result image is the height at which the surface makes contact with the image for
each pixel in the image. 
</p>
<p>In code:
               </p>
<pre> 
                  for each pixel result[i][j] in the image{
                      int r = MAX_CHANNEL_VALUE;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
                          }
                      }

                      // normalize for kernel center not 0
                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];

                      // saturate overflow to representable range
                      result[i][j] = CLIP( r );
                  }
                </pre>
<p>The ARGB variants apply the filter to the four channels in parallel. It should be noted that the application
of the filter to the image causes the structure elements in the filter to be reflected into the image, reversed
top to bottom and left to right. Also, if the center of the kernel is not 0, a general lightening of the image
will occur. Some functions will run much faster if the center of the kernel is 0.
</p>
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageErode_ARGB8888" logicalPath="//apple_ref/c/func/vImageErode_ARGB8888" target="_top">vImageErode_ARGB8888</a></tt></dt>
<dd><p>Apply a erode filter to a ARGB8888 image
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageErode_ARGBFFFF" logicalPath="//apple_ref/c/func/vImageErode_ARGBFFFF" target="_top">vImageErode_ARGBFFFF</a></tt></dt>
<dd><p>Apply a erode filter to a ARGBFFFF image
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageErode_Planar8" logicalPath="//apple_ref/c/func/vImageErode_Planar8" target="_top">vImageErode_Planar8</a></tt></dt>
<dd><p>Apply a erode filter to a Planar8 image
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageErode_PlanarF" logicalPath="//apple_ref/c/func/vImageErode_PlanarF" target="_top">vImageErode_PlanarF</a></tt></dt>
<dd><p>Apply a erode filter to a PlanarF image
</p></dd>
</dl>
</div>
<hr class="afterGroupHeading">
<a name="HeaderDoc_functions"></a>
<h2 class="h2tight">Functions</h2>
<dl>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageDilate_ARGB8888" target="_top">vImageDilate_ARGB8888</a></tt></dt>
<dd><p>Apply a dilate filter to a ARGB8888 image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageDilate_ARGBFFFF" target="_top">vImageDilate_ARGBFFFF</a></tt></dt>
<dd><p>Apply a dilate filter to a ARGBFFFF image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageDilate_Planar8" target="_top">vImageDilate_Planar8</a></tt></dt>
<dd><p>Apply a dilate filter to a Planar8 image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageDilate_PlanarF" target="_top">vImageDilate_PlanarF</a></tt></dt>
<dd><p>Apply a dilate filter to a PlanarF image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageErode_ARGB8888" target="_top">vImageErode_ARGB8888</a></tt></dt>
<dd><p>Apply a erode filter to a ARGB8888 image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageErode_ARGBFFFF" target="_top">vImageErode_ARGBFFFF</a></tt></dt>
<dd><p>Apply a erode filter to a ARGBFFFF image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageErode_Planar8" target="_top">vImageErode_Planar8</a></tt></dt>
<dd><p>Apply a erode filter to a Planar8 image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageErode_PlanarF" target="_top">vImageErode_PlanarF</a></tt></dt>
<dd><p>Apply a erode filter to a PlanarF image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageMax_ARGB8888" target="_top">vImageMax_ARGB8888</a></tt></dt>
<dd><p>Apply a max filter to a ARGB8888 image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageMax_ARGBFFFF" target="_top">vImageMax_ARGBFFFF</a></tt></dt>
<dd><p>Apply a max filter to a ARGBFFFF image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageMax_Planar8" target="_top">vImageMax_Planar8</a></tt></dt>
<dd><p>Apply a max filter to a Planar8 image.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageMax_PlanarF" target="_top">vImageMax_PlanarF</a></tt></dt>
<dd><p>Apply a max filter to a PlanarF image.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageMin_ARGB8888" target="_top">vImageMin_ARGB8888</a></tt></dt>
<dd><p>Apply a min filter to a ARGB8888 image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageMin_ARGBFFFF" target="_top">vImageMin_ARGBFFFF</a></tt></dt>
<dd><p>Apply a min filter to a ARGBFFFF image
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageMin_Planar8" target="_top">vImageMin_Planar8</a></tt></dt>
<dd><p>Apply a min filter to a Planar8 image.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageMin_PlanarF" target="_top">vImageMin_PlanarF</a></tt></dt>
<dd><p>Apply a min filter to a PlanarF image.
</p></dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageDilate_ARGB8888;   name=vImageDilate_ARGB8888 --><a name="//apple_ref/c/func/vImageDilate_ARGB8888"></a>
<h3><a name="vImageDilate_ARGB8888">vImageDilate_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageDilate_ARGB8888;name=start --><!-- begin abstract --></p>
<p>Apply a dilate filter to a ARGB8888 image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageDilate_ARGB8888;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageDilate_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageDilate_ARGB8888" logicalPath="//apple_ref/c/instm/vImageDilate_ARGB8888 //apple_ref/c/clm/vImageDilate_ARGB8888 //apple_ref/c/intfcm/vImageDilate_ARGB8888 //apple_ref/c/intfm/vImageDilate_ARGB8888 //apple_ref/c/func/vImageDilate_ARGB8888" target="_top"><span class="function">vImageDilate_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <span class="keyword">unsigned</span> <!-- a logicalPath="//apple_ref/c/cl/char //apple_ref/c/tdef/char //apple_ref/c/tag/char //apple_ref/c/struct/char //apple_ref/c/intf/char //apple_ref/doc/anysymbol/char" machineGenerated="true" --><span class="type">char</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageDilate_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGB8888/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGB8888/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the dilate filter.
It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGB8888/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGB8888/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the dilate filter.
It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGB8888/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGB8888/kernel"></a>
<code>kernel</code>
</dt>
<dd><p>A pointer to a array of filter values of dimension kernel_height x kernel_width.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGB8888/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGB8888/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGB8888/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGB8888/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.

             kvImageGetTempBufferSize     Return 0.  Do no work.

             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
                                          without modification, instead of having a dilate filter applied to it.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageDilate_ARGB8888;name=start --><p>This is a general purpose dilate filter for ARGB8888 data. If your filter is all 0's, you should use vImageMax_ARGB8888
instead.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      int a = 0;
                      int r = 0;
                      int g = 0;
                      int b = 0;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
                          }
                      }

                      // normalize for kernel center not 0
                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];

                      // saturate overflow to representable range
                      result[i][j][0] = (flags &amp; kvImageLeaveAlphaUnchanged) ? src[i][j] : CLIP( a );
                      result[i][j][1] = CLIP( r );
                      result[i][j][2] = CLIP( g );
                      result[i][j][3] = CLIP( b );
                  }
                </pre>

<p>If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place. If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. 
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageDilate_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageDilate_ARGBFFFF;   name=vImageDilate_ARGBFFFF --><a name="//apple_ref/c/func/vImageDilate_ARGBFFFF"></a>
<h3><a name="vImageDilate_ARGBFFFF">vImageDilate_ARGBFFFF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageDilate_ARGBFFFF;name=start --><!-- begin abstract --></p>
<p>Apply a dilate filter to a ARGBFFFF image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageDilate_ARGBFFFF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageDilate_ARGBFFFF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageDilate_ARGBFFFF" logicalPath="//apple_ref/c/instm/vImageDilate_ARGBFFFF //apple_ref/c/clm/vImageDilate_ARGBFFFF //apple_ref/c/intfcm/vImageDilate_ARGBFFFF //apple_ref/c/intfm/vImageDilate_ARGBFFFF //apple_ref/c/func/vImageDilate_ARGBFFFF" target="_top"><span class="function">vImageDilate_ARGBFFFF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageDilate_ARGBFFFF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the dilate filter.
It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the dilate filter.
It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/kernel"></a>
<code>kernel</code>
</dt>
<dd><p>A pointer to a array of filter values of dimension kernel_height x kernel_width.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageDilate_ARGBFFFF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.

             kvImageGetTempBufferSize     Return 0.  Do no work.

             kvImageLeaveAlphaUnchanged   The alpha channel (first float in pixel in memory) is copied to the destination
                                          without modification, instead of having a dilate filter applied to it.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageDilate_ARGBFFFF;name=start --><p>This is a general purpose dilate filter for ARGBFFFF data. If your filter is all 0's, you should use vImageMax_ARGBFFFF
instead.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      float a = -INFINITY;
                      float r = -INFINITY;
                      float g = -INFINITY;
                      float b = -INFINITY;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
                          }
                      }

                      // normalize for kernel center not 0
                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];

                      // saturate overflow to representable range
                      result[i][j][0] = (flags &amp; kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
                      result[i][j][1] = r;
                      result[i][j][2] = g;
                      result[i][j][3] = b;
                  }
                </pre>

<p>If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place.  If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. Floating-point values have host
endianness.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageDilate_ARGBFFFF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageDilate_Planar8;   name=vImageDilate_Planar8 --><a name="//apple_ref/c/func/vImageDilate_Planar8"></a>
<h3><a name="vImageDilate_Planar8">vImageDilate_Planar8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageDilate_Planar8;name=start --><!-- begin abstract --></p>
<p>Apply a dilate filter to a Planar8 image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageDilate_Planar8;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageDilate_Planar8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageDilate_Planar8" logicalPath="//apple_ref/c/instm/vImageDilate_Planar8 //apple_ref/c/clm/vImageDilate_Planar8 //apple_ref/c/intfcm/vImageDilate_Planar8 //apple_ref/c/intfm/vImageDilate_Planar8 //apple_ref/c/func/vImageDilate_Planar8" target="_top"><span class="function">vImageDilate_Planar8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <span class="keyword">unsigned</span> <!-- a logicalPath="//apple_ref/c/cl/char //apple_ref/c/tdef/char //apple_ref/c/tag/char //apple_ref/c/struct/char //apple_ref/c/intf/char //apple_ref/doc/anysymbol/char" machineGenerated="true" --><span class="type">char</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageDilate_Planar8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_Planar8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageDilate_Planar8/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_Planar8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageDilate_Planar8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_Planar8/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageDilate_Planar8/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the dilate filter.
It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the 
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_Planar8/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageDilate_Planar8/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the dilate filter.
It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_Planar8/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageDilate_Planar8/kernel"></a>
<code>kernel</code>
</dt>
<dd><p>A pointer to a array of filter values of dimension kernel_height x kernel_width.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_Planar8/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageDilate_Planar8/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_Planar8/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageDilate_Planar8/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_Planar8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageDilate_Planar8/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.

             kvImageGetTempBufferSize     Return 0.  Do no work.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageDilate_Planar8;name=start --><p>This is a general purpose dilate filter for Planar8 data. It is optimized to handle the special cases that occur
in image masks -- large contiguous regions of all 0xff or 0x0. If your filter is all 0's, you should use vImageMax_Planar8
instead. 
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      int r = 0;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
                          }
                      }

                      // normalize for kernel center not 0
                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];

                      // saturate overflow to representable range
                      result[i][j] = CLIP( r );
                  }
                </pre>

<p>If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image. 
</p>
<p>Does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageDilate_Planar8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageDilate_PlanarF;   name=vImageDilate_PlanarF --><a name="//apple_ref/c/func/vImageDilate_PlanarF"></a>
<h3><a name="vImageDilate_PlanarF">vImageDilate_PlanarF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageDilate_PlanarF;name=start --><!-- begin abstract --></p>
<p>Apply a dilate filter to a PlanarF image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageDilate_PlanarF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageDilate_PlanarF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageDilate_PlanarF" logicalPath="//apple_ref/c/instm/vImageDilate_PlanarF //apple_ref/c/clm/vImageDilate_PlanarF //apple_ref/c/intfcm/vImageDilate_PlanarF //apple_ref/c/intfm/vImageDilate_PlanarF //apple_ref/c/func/vImageDilate_PlanarF" target="_top"><span class="function">vImageDilate_PlanarF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageDilate_PlanarF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_PlanarF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageDilate_PlanarF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_PlanarF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageDilate_PlanarF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_PlanarF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageDilate_PlanarF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the dilate filter.
It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_PlanarF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageDilate_PlanarF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the dilate filter.
It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_PlanarF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageDilate_PlanarF/kernel"></a>
<code>kernel</code>
</dt>
<dd><p>A pointer to a array of filter values of dimension kernel_height x kernel_width.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_PlanarF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageDilate_PlanarF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_PlanarF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageDilate_PlanarF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageDilate_PlanarF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageDilate_PlanarF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.

             kvImageGetTempBufferSize     Return 0.  Do no work.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageDilate_PlanarF;name=start --><p>This is a general purpose dilate filter for Planar8 data. If your filter is all 0's, you should use vImageMax_PlanarF
instead.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      float r = -INFINITY;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
                          }
                      }

                      // normalize for kernel center not 0
                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];

                      // saturate overflow to representable range
                      result[i][j] = r;
                  }
                </pre>

<p>If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place. Floating-point values have host endianness.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageDilate_PlanarF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageErode_ARGB8888;   name=vImageErode_ARGB8888 --><a name="//apple_ref/c/func/vImageErode_ARGB8888"></a>
<h3><a name="vImageErode_ARGB8888">vImageErode_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageErode_ARGB8888;name=start --><!-- begin abstract --></p>
<p>Apply a erode filter to a ARGB8888 image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageErode_ARGB8888;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageErode_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageErode_ARGB8888" logicalPath="//apple_ref/c/instm/vImageErode_ARGB8888 //apple_ref/c/clm/vImageErode_ARGB8888 //apple_ref/c/intfcm/vImageErode_ARGB8888 //apple_ref/c/intfm/vImageErode_ARGB8888 //apple_ref/c/func/vImageErode_ARGB8888" target="_top"><span class="function">vImageErode_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <span class="keyword">unsigned</span> <!-- a logicalPath="//apple_ref/c/cl/char //apple_ref/c/tdef/char //apple_ref/c/tag/char //apple_ref/c/struct/char //apple_ref/c/intf/char //apple_ref/doc/anysymbol/char" machineGenerated="true" --><span class="type">char</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageErode_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGB8888/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGB8888/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the erode filter.
It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGB8888/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGB8888/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the erode filter.
It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGB8888/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGB8888/kernel"></a>
<code>kernel</code>
</dt>
<dd><p>A pointer to a array of filter values of dimension kernel_height x kernel_width.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGB8888/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGB8888/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGB8888/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGB8888/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.

             kvImageGetTempBufferSize     Return 0.  Do no work.

             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
                                          without modification, instead of having a erode filter applied to it.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageErode_ARGB8888;name=start --><p>This is a general purpose erode filter for ARGB8888 data. If your filter is all 0's, you should use vImageMin_ARGB8888
instead.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      int a = 255;
                      int r = 255;
                      int g = 255;
                      int b = 255;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
                          }
                      }

                      // normalize for kernel center not 0
                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];

                      // saturate overflow to representable range
                      result[i][j][0] = (flags &amp; kvImageLeaveAlphaUnchanged) ? src[i][j] : CLIP( a );
                      result[i][j][1] = CLIP( r );
                      result[i][j][2] = CLIP( g );
                      result[i][j][3] = CLIP( b );
                  }
                </pre>

<p>If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place. If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageErode_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageErode_ARGBFFFF;   name=vImageErode_ARGBFFFF --><a name="//apple_ref/c/func/vImageErode_ARGBFFFF"></a>
<h3><a name="vImageErode_ARGBFFFF">vImageErode_ARGBFFFF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageErode_ARGBFFFF;name=start --><!-- begin abstract --></p>
<p>Apply a erode filter to a ARGBFFFF image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageErode_ARGBFFFF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageErode_ARGBFFFF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageErode_ARGBFFFF" logicalPath="//apple_ref/c/instm/vImageErode_ARGBFFFF //apple_ref/c/clm/vImageErode_ARGBFFFF //apple_ref/c/intfcm/vImageErode_ARGBFFFF //apple_ref/c/intfm/vImageErode_ARGBFFFF //apple_ref/c/func/vImageErode_ARGBFFFF" target="_top"><span class="function">vImageErode_ARGBFFFF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageErode_ARGBFFFF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the erode filter.
It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the erode filter.
It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/kernel"></a>
<code>kernel</code>
</dt>
<dd><p>A pointer to a array of filter values of dimension kernel_height x kernel_width.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageErode_ARGBFFFF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.

             kvImageGetTempBufferSize     Return 0.  Do no work.

             kvImageLeaveAlphaUnchanged   The alpha channel (first float in pixel in memory) is copied to the destination
                                          without modification, instead of having a erode filter applied to it.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageErode_ARGBFFFF;name=start --><p>This is a general purpose erode filter for ARGBFFFF data. If your filter is all 0's, you should use vImageMin_ARGBFFFF
instead.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      float a = INFINITY;
                      float r = INFINITY;
                      float g = INFINITY;
                      float b = INFINITY;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
                          }
                      }

                      // normalize for kernel center not 0
                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];

                      // saturate overflow to representable range
                      result[i][j][0] = (flags &amp; kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
                      result[i][j][1] = r;
                      result[i][j][2] = g;
                      result[i][j][3] = b;
                  }
                </pre>

<p>If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place.  If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. Floating-point values have host
endianness.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageErode_ARGBFFFF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageErode_Planar8;   name=vImageErode_Planar8 --><a name="//apple_ref/c/func/vImageErode_Planar8"></a>
<h3><a name="vImageErode_Planar8">vImageErode_Planar8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageErode_Planar8;name=start --><!-- begin abstract --></p>
<p>Apply a erode filter to a Planar8 image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageErode_Planar8;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageErode_Planar8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageErode_Planar8" logicalPath="//apple_ref/c/instm/vImageErode_Planar8 //apple_ref/c/clm/vImageErode_Planar8 //apple_ref/c/intfcm/vImageErode_Planar8 //apple_ref/c/intfm/vImageErode_Planar8 //apple_ref/c/func/vImageErode_Planar8" target="_top"><span class="function">vImageErode_Planar8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <span class="keyword">unsigned</span> <!-- a logicalPath="//apple_ref/c/cl/char //apple_ref/c/tdef/char //apple_ref/c/tag/char //apple_ref/c/struct/char //apple_ref/c/intf/char //apple_ref/doc/anysymbol/char" machineGenerated="true" --><span class="type">char</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageErode_Planar8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_Planar8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageErode_Planar8/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_Planar8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageErode_Planar8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_Planar8/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageErode_Planar8/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the erode filter.
It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_Planar8/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageErode_Planar8/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the erode filter.
It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_Planar8/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageErode_Planar8/kernel"></a>
<code>kernel</code>
</dt>
<dd><p>A pointer to a array of filter values of dimension kernel_height x kernel_width.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_Planar8/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageErode_Planar8/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_Planar8/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageErode_Planar8/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_Planar8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageErode_Planar8/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.

             kvImageGetTempBufferSize     Return 0.  Do no work.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageErode_Planar8;name=start --><p>This is a general purpose erode filter for Planar8 data. If your filter is all 0's, you should use vImageMin_Planar8
instead.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      int r = MAX_CHANNEL_VALUE;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
                          }
                      }

                      // normalize for kernel center not 0
                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];

                      // saturate overflow to representable range
                      result[i][j] = CLIP( r );
                  }
                </pre>

<p>If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageErode_Planar8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageErode_PlanarF;   name=vImageErode_PlanarF --><a name="//apple_ref/c/func/vImageErode_PlanarF"></a>
<h3><a name="vImageErode_PlanarF">vImageErode_PlanarF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageErode_PlanarF;name=start --><!-- begin abstract --></p>
<p>Apply a erode filter to a PlanarF image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageErode_PlanarF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageErode_PlanarF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageErode_PlanarF" logicalPath="//apple_ref/c/instm/vImageErode_PlanarF //apple_ref/c/clm/vImageErode_PlanarF //apple_ref/c/intfcm/vImageErode_PlanarF //apple_ref/c/intfm/vImageErode_PlanarF //apple_ref/c/func/vImageErode_PlanarF" target="_top"><span class="function">vImageErode_PlanarF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageErode_PlanarF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_PlanarF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageErode_PlanarF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_PlanarF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageErode_PlanarF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_PlanarF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageErode_PlanarF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the erode filter.
It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_PlanarF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageErode_PlanarF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the erode filter.
It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_PlanarF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageErode_PlanarF/kernel"></a>
<code>kernel</code>
</dt>
<dd><p>A pointer to a array of filter values of dimension kernel_height x kernel_width.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_PlanarF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageErode_PlanarF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_PlanarF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageErode_PlanarF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageErode_PlanarF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageErode_PlanarF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.

             kvImageGetTempBufferSize     Return 0.  Do no work.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageErode_PlanarF;name=start --><p>This is a general purpose erode filter for Planar8 data. If your filter is all 0's, you should use vImageMin_PlanarF
instead.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      float r = INFINITY;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
                          }
                      }

                      // normalize for kernel center not 0
                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];

                      // saturate overflow to representable range
                      result[i][j] = r;
                  }
                </pre>

<p>If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place. Floating-point values have host endianness.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageErode_PlanarF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageMax_ARGB8888;   name=vImageMax_ARGB8888 --><a name="//apple_ref/c/func/vImageMax_ARGB8888"></a>
<h3><a name="vImageMax_ARGB8888">vImageMax_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMax_ARGB8888;name=start --><!-- begin abstract --></p>
<p>Apply a max filter to a ARGB8888 image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMax_ARGB8888;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMax_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMax_ARGB8888" logicalPath="//apple_ref/c/instm/vImageMax_ARGB8888 //apple_ref/c/clm/vImageMax_ARGB8888 //apple_ref/c/intfcm/vImageMax_ARGB8888 //apple_ref/c/intfm/vImageMax_ARGB8888 //apple_ref/c/func/vImageMax_ARGB8888" target="_top"><span class="function">vImageMax_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMax_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGB8888/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGB8888/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>May be NULL. An optional temp buffer in which to store temporary computation. To find the size
of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
flag. The size of the temp buffer will be returned from the left hand side of the function in
place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
the newly allocated temp buffer.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGB8888/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGB8888/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the max filter.
It allows the max filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGB8888/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGB8888/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the max filter.
It allows the max filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGB8888/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGB8888/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGB8888/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGB8888/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread. 
                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.

             kvImageGetTempBufferSize     Return 0.  Do no work.

             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
                                          without modification, instead of having a max filter applied to it.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                 &gt;=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
                                              Instead, the size of the temp buffer needed is returned.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMax_ARGB8888;name=start --><p>This is a special purpose dilate filter for ARGB8888 data, for rectangular kernels with value 0. It is much faster than the normal dilate.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      int a = 0;
                      int r = 0;
                      int g = 0;
                      int b = 0;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
                          }
                      }

                      // saturate overflow to representable range
                      result[i][j][0] = (flags &amp; kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
                      result[i][j][1] = r;
                      result[i][j][2] = g;
                      result[i][j][3] = b;
                  }
                </pre>

<p>If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably 
run more slowly.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMax_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageMax_ARGBFFFF;   name=vImageMax_ARGBFFFF --><a name="//apple_ref/c/func/vImageMax_ARGBFFFF"></a>
<h3><a name="vImageMax_ARGBFFFF">vImageMax_ARGBFFFF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMax_ARGBFFFF;name=start --><!-- begin abstract --></p>
<p>Apply a max filter to a ARGBFFFF image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMax_ARGBFFFF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMax_ARGBFFFF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMax_ARGBFFFF" logicalPath="//apple_ref/c/instm/vImageMax_ARGBFFFF //apple_ref/c/clm/vImageMax_ARGBFFFF //apple_ref/c/intfcm/vImageMax_ARGBFFFF //apple_ref/c/intfm/vImageMax_ARGBFFFF //apple_ref/c/func/vImageMax_ARGBFFFF" target="_top"><span class="function">vImageMax_ARGBFFFF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMax_ARGBFFFF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>May be NULL. An optional temp buffer in which to store temporary computation. To find the size
of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
flag. The size of the temp buffer will be returned from the left hand side of the function in
place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
the newly allocated temp buffer.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the max filter.
It allows the max filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the max filter.
It allows the max filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageMax_ARGBFFFF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.
                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.

             kvImageGetTempBufferSize     Return 0.  Do no work.

             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
                                          without modification, instead of having a max filter applied to it.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                 &gt;=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
                                              Instead, the size of the temp buffer needed is returned.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMax_ARGBFFFF;name=start --><p>This is a special purpose dilate filter for ARGBFFFF data, for rectangular kernels with value 0. It is much faster than the normal dilate.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      float a = -INFINITY;
                      float r = -INFINITY;
                      float g = -INFINITY;
                      float b = -INFINITY;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
                          }
                      }

                      // saturate overflow to representable range
                      result[i][j][0] = (flags &amp; kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
                      result[i][j][1] = r;
                      result[i][j][2] = g;
                      result[i][j][3] = b;
                  }
                </pre>

<p>If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
run more slowly.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMax_ARGBFFFF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageMax_Planar8;   name=vImageMax_Planar8 --><a name="//apple_ref/c/func/vImageMax_Planar8"></a>
<h3><a name="vImageMax_Planar8">vImageMax_Planar8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMax_Planar8;name=start --><!-- begin abstract --></p>
<p>Apply a max filter to a Planar8 image.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMax_Planar8;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMax_Planar8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMax_Planar8" logicalPath="//apple_ref/c/instm/vImageMax_Planar8 //apple_ref/c/clm/vImageMax_Planar8 //apple_ref/c/intfcm/vImageMax_Planar8 //apple_ref/c/intfm/vImageMax_Planar8 //apple_ref/c/func/vImageMax_Planar8" target="_top"><span class="function">vImageMax_Planar8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMax_Planar8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_Planar8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageMax_Planar8/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_Planar8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageMax_Planar8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_Planar8/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageMax_Planar8/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>May be NULL. An optional temp buffer in which to store temporary computation. To find the size
of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
flag. The size of the temp buffer will be returned from the left hand side of the function in
place of an error code, and no work will be done on the image data. A temp buffer can provide a speed 
improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of 
the newly allocated temp buffer.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_Planar8/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageMax_Planar8/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the max filter.
It allows the max filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_Planar8/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageMax_Planar8/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the max filter.
It allows the max filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_Planar8/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageMax_Planar8/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_Planar8/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageMax_Planar8/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_Planar8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageMax_Planar8/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread. It also
                                          allows the function to work in place, though more slowly.

             kvImageGetTempBufferSize     Return 0.  Do no work.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                 &gt;=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
                                              Instead, the size of the temp buffer needed is returned.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMax_Planar8;name=start --><p>A max filter is a special case dilate filter, in which the filter elements are all 0. It is much faster than the normal dilate.
               </p>
<pre> 
                  for each pixel result[i][j] in the image{
                      int r = 0;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
                          }
                      }

                      // saturate overflow to representable range
                      result[i][j] = r;
                  }
                </pre>
<p>If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place, unless the kvImageDoNotTile flag is used.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMax_Planar8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageMax_PlanarF;   name=vImageMax_PlanarF --><a name="//apple_ref/c/func/vImageMax_PlanarF"></a>
<h3><a name="vImageMax_PlanarF">vImageMax_PlanarF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMax_PlanarF;name=start --><!-- begin abstract --></p>
<p>Apply a max filter to a PlanarF image.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMax_PlanarF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMax_PlanarF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMax_PlanarF" logicalPath="//apple_ref/c/instm/vImageMax_PlanarF //apple_ref/c/clm/vImageMax_PlanarF //apple_ref/c/intfcm/vImageMax_PlanarF //apple_ref/c/intfm/vImageMax_PlanarF //apple_ref/c/func/vImageMax_PlanarF" target="_top"><span class="function">vImageMax_PlanarF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMax_PlanarF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_PlanarF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageMax_PlanarF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_PlanarF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageMax_PlanarF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_PlanarF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageMax_PlanarF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>May be NULL. An optional temp buffer in which to store temporary computation. To find the size 
of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
flag. The size of the temp buffer will be returned from the left hand side of the function in
place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
the newly allocated temp buffer.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_PlanarF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageMax_PlanarF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the max filter.
It allows the max filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_PlanarF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageMax_PlanarF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the max filter.
It allows the max filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_PlanarF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageMax_PlanarF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_PlanarF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageMax_PlanarF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMax_PlanarF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageMax_PlanarF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread. It also
                                          allows the function to work in place, though more slowly.

             kvImageGetTempBufferSize     Return the size of the temp buffer needed.  Do no work.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                 &gt;=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
                                              Instead, the size of the temp buffer needed is returned.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMax_PlanarF;name=start --><p>A max filter is a special case dilate filter, in which the filter elements are all 0. It is much faster than the normal dilate.
               </p>
<pre> 
                  for each pixel result[i][j] in the image{
                      float r = -INFINITY;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
                          }
                      }

                      // saturate overflow to representable range
                      result[i][j] = r;
                  }
                </pre>
<p>If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place, unless the kvImageDoNotTile flag is used.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMax_PlanarF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageMin_ARGB8888;   name=vImageMin_ARGB8888 --><a name="//apple_ref/c/func/vImageMin_ARGB8888"></a>
<h3><a name="vImageMin_ARGB8888">vImageMin_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMin_ARGB8888;name=start --><!-- begin abstract --></p>
<p>Apply a min filter to a ARGB8888 image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMin_ARGB8888;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMin_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMin_ARGB8888" logicalPath="//apple_ref/c/instm/vImageMin_ARGB8888 //apple_ref/c/clm/vImageMin_ARGB8888 //apple_ref/c/intfcm/vImageMin_ARGB8888 //apple_ref/c/intfm/vImageMin_ARGB8888 //apple_ref/c/func/vImageMin_ARGB8888" target="_top"><span class="function">vImageMin_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMin_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGB8888/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGB8888/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>May be NULL. An optional temp buffer in which to store temporary computation. To find the size
of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
flag. The size of the temp buffer will be returned from the left hand side of the function in
place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
the newly allocated temp buffer.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGB8888/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGB8888/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the min filter.
It allows the min filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGB8888/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGB8888/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the min filter.
It allows the min filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGB8888/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGB8888/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGB8888/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGB8888/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.
                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.

             kvImageGetTempBufferSize     Return 0.  Do no work.

             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
                                          without modification, instead of having a min filter applied to it.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                 &gt;=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
                                              Instead, the size of the temp buffer needed is returned.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMin_ARGB8888;name=start --><p>This is a special purpose erode filter for ARGB8888 data, for rectangular kernels with value 0. It is much faster than the normal erode.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      int a = MAX_CHANNEL_VALUE;
                      int r = MAX_CHANNEL_VALUE;
                      int g = MAX_CHANNEL_VALUE;
                      int b = MAX_CHANNEL_VALUE;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
                          }
                      }

                      // saturate overflow to representable range
                      result[i][j][0] = (flags &amp; kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
                      result[i][j][1] = r;
                      result[i][j][2] = g;
                      result[i][j][3] = b;
                  }
                </pre>

<p>If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
run more slowly.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMin_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageMin_ARGBFFFF;   name=vImageMin_ARGBFFFF --><a name="//apple_ref/c/func/vImageMin_ARGBFFFF"></a>
<h3><a name="vImageMin_ARGBFFFF">vImageMin_ARGBFFFF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMin_ARGBFFFF;name=start --><!-- begin abstract --></p>
<p>Apply a min filter to a ARGBFFFF image
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMin_ARGBFFFF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMin_ARGBFFFF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMin_ARGBFFFF" logicalPath="//apple_ref/c/instm/vImageMin_ARGBFFFF //apple_ref/c/clm/vImageMin_ARGBFFFF //apple_ref/c/intfcm/vImageMin_ARGBFFFF //apple_ref/c/intfm/vImageMin_ARGBFFFF //apple_ref/c/func/vImageMin_ARGBFFFF" target="_top"><span class="function">vImageMin_ARGBFFFF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMin_ARGBFFFF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>May be NULL. An optional temp buffer in which to store temporary computation. To find the size
of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
flag. The size of the temp buffer will be returned from the left hand side of the function in
place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
the newly allocated temp buffer.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the min filter.
It allows the min filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the min filter.
It allows the min filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageMin_ARGBFFFF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread.
                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.

             kvImageGetTempBufferSize     Return 0.  Do no work.

             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
                                          without modification, instead of having a min filter applied to it.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                 &gt;=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
                                              Instead, the size of the temp buffer needed is returned.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMin_ARGBFFFF;name=start --><p>This is a special purpose erode filter for ARGBFFFF data, for rectangular kernels with value 0. It is much faster than the normal erode.
</p>
               <pre> 
                  for each pixel result[i][j] in the image{
                      float a = INFINITY;
                      float r = INFINITY;
                      float g = INFINITY;
                      float b = INFINITY;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
                          }
                      }

                      // saturate overflow to representable range
                      result[i][j][0] = (flags &amp; kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
                      result[i][j][1] = r;
                      result[i][j][2] = g;
                      result[i][j][3] = b;
                  }
                </pre>

<p>If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
run more slowly.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMin_ARGBFFFF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageMin_Planar8;   name=vImageMin_Planar8 --><a name="//apple_ref/c/func/vImageMin_Planar8"></a>
<h3><a name="vImageMin_Planar8">vImageMin_Planar8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMin_Planar8;name=start --><!-- begin abstract --></p>
<p>Apply a min filter to a Planar8 image.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMin_Planar8;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMin_Planar8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMin_Planar8" logicalPath="//apple_ref/c/instm/vImageMin_Planar8 //apple_ref/c/clm/vImageMin_Planar8 //apple_ref/c/intfcm/vImageMin_Planar8 //apple_ref/c/intfm/vImageMin_Planar8 //apple_ref/c/func/vImageMin_Planar8" target="_top"><span class="function">vImageMin_Planar8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMin_Planar8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_Planar8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageMin_Planar8/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_Planar8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageMin_Planar8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_Planar8/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageMin_Planar8/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>May be NULL. An optional temp buffer in which to store temporary computation. To find the size
of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
flag. The size of the temp buffer will be returned from the left hand side of the function in
place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
the newly allocated temp buffer.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_Planar8/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageMin_Planar8/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the min filter.
It allows the min filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_Planar8/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageMin_Planar8/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the min filter.
It allows the min filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_Planar8/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageMin_Planar8/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_Planar8/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageMin_Planar8/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_Planar8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageMin_Planar8/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread. It also
                                          allows the function to work in place, though more slowly.

             kvImageGetTempBufferSize     Return 0.  Do no work.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                 &gt;=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
                                              Instead, the size of the temp buffer needed is returned.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMin_Planar8;name=start --><p>A min filter is a special case erode filter, in which the filter elements are all 0.  It is much faster than the normal erode.
               </p>
<pre> 
                  for each pixel result[i][j] in the image{
                      int r = MAX_CHANNEL_VALUE;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
                          }
                      }

                      // saturate overflow to representable range
                      result[i][j] = r;
                  }
                </pre>
<p>If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place, unless the kvImageDoNotTile flag is used.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMin_Planar8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageMin_PlanarF;   name=vImageMin_PlanarF --><a name="//apple_ref/c/func/vImageMin_PlanarF"></a>
<h3><a name="vImageMin_PlanarF">vImageMin_PlanarF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMin_PlanarF;name=start --><!-- begin abstract --></p>
<p>Apply a min filter to a PlanarF image.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageMin_PlanarF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMin_PlanarF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageMin_PlanarF" logicalPath="//apple_ref/c/instm/vImageMin_PlanarF //apple_ref/c/clm/vImageMin_PlanarF //apple_ref/c/intfcm/vImageMin_PlanarF //apple_ref/c/intfm/vImageMin_PlanarF //apple_ref/c/func/vImageMin_PlanarF" target="_top"><span class="function">vImageMin_PlanarF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_height</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageMin_PlanarF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_PlanarF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageMin_PlanarF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_PlanarF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageMin_PlanarF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to contain the result image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_PlanarF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageMin_PlanarF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>May be NULL. An optional temp buffer in which to store temporary computation. To find the size
of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
flag. The size of the temp buffer will be returned from the left hand side of the function in
place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
the newly allocated temp buffer.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_PlanarF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageMin_PlanarF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset added to the horizontal position in the src image when calculating the min filter.
It allows the min filter to operate in a tiled fashion for tiles that do not start on the
left edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_PlanarF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageMin_PlanarF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset added to the vertical position in the src image when calculating the min filter.
It allows the min filter to operate in a tiled fashion for tiles that do not start on the
top edge of the source image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_PlanarF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageMin_PlanarF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_PlanarF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageMin_PlanarF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the rectangular kernel. Must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageMin_PlanarF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageMin_PlanarF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags values are allowed:
      </p>
<pre> 
             kvImageNoFlags               Default operation

             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
                                          multithreading and just want the filter to run local to the current thread. It also
                                          allows the function to work in place, though more slowly.

             kvImageGetTempBufferSize     Return 0.  Do no work.
       </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may result:
      </p>
<pre> 
             kvImageNoError                   Success.
                 &gt;=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
                                              Instead, the size of the temp buffer needed is returned.

             kvImageRoiLargerThanInputBuffer  dest-&gt;width and dest-&gt;height must be less than or equal to the corresponding
                                              dimensions in the src image

             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMin_PlanarF;name=start --><p>A min filter is a special case erode filter, in which the filter elements are all 0. It is much faster than the normal erode.
               </p>
<pre> 
                  for each pixel result[i][j] in the image{
                      float r = INFINITY;
                      for( y = 0; y &lt; kernel_height; y++ ){
                          for( x = 0; x &lt; kernel_width; x++ ){
                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
                          }
                      }

                      // saturate overflow to representable range
                      result[i][j] = r;
                  }
                </pre>
<p>If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
of the result tile relative to the src image.
</p>
<p>Does not work in place, unless the kvImageDoNotTile flag is used.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageMin_PlanarF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<p class="gapBeforeFooter">&nbsp;</p>
<hr class="afterFooter">
<div class="hd_copyright_and_timestamp">
<p class="hd_copyright">&copy; Copyright (c) 2002-2015 by Apple Inc. All rights reserved.

 </p>
<p class="hd_timestamp">Last Updated: Thursday, December 24, 2015
</p>
</div>
</td>
</tr></table>
</body>
</html>
