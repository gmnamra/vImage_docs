<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head>
<title>vImage.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="generator" content="HeaderDoc">
<meta name="xcode-display" content="render">
<style type="text/css"><!--.char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;}body {border: 0px; margin: 0px;}div {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}td {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}span.hd_tocAccessSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroupSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroup { display: block; font-weight: bold; font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; margin-left: 0px; padding-left: 40px; }span.hd_tocGroup + span.hd_tocAccess { padding-top: 5px; }td.toc_contents_text {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; }li.tocSubEntry {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}p {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}a:link {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:active {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}h2.h2tight { margin-top: 0px; padding-top: 0px; }h1 { margin-top: 13px; padding-top: 0px; }h4 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: tiny; font-weight: bold;}h5 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: 10.1pt; font-weight: bold;}pre {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666; font-size: 10pt;}pre a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}pre a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}body  {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt; padding-left: 0px; padding-top: 0px; margin-left: 0px; margin-top: 0px; border: none; }#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }.afterName { display: none; }.list_indent { margin-left: 40px; }.declaration_indent { margin-left: 40px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; min-height: 12px; vertical-align: middle; }.declaration_indent pre { margin-top: 20px; padding-top: 0px; margin-bottom: 20px; padding-bottom: 0px; }.gapBeforeFooter { display: none; }hr { height: 0px; min-height: 0px; border-top: none; border-left: none; border-right: none; border-bottom: 1px solid #909090;}hr.afterHeader { display: none }.param_group_indent { margin-left: 25px; }.param_indent { margin-left: 40px; margin-top: 0px; padding-top: 0px; }.param_indent dl { margin-top: 4px; padding-top: 0px; }dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.param_indent dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.group_indent { margin-left: 40px; }.group_desc_indent { margin-left: 20px; }.warning_indent { margin-left: 40px; }.important_indent { margin-left: 40px; }.note_indent { margin-left: 40px; }h3 {       color: #3C4C6C;}.tight {       margin-top: 2px; margin-bottom: 0px;       padding-top: 0px; padding-bottom: 0px;}h3 a {       color: #3C4C6C;	font-size: 16px;	font-style: normal;	font-variant: normal;	font-weight: bold;	height: 0px;	line-height: normal;}.hd_tocAccess { display: block; margin-left: 40px; font-style: italic; font-size: 10px; font-weight: normal; color: #303030; }.tocSubheading { margin-bottom: 4px; }--></style>
<style><!--
body {
    padding: 0px;
    margin: 0px;
    border: 0px;
}
.toc_contents_text {
    padding-left: 1em;
    text-indent: -1em;
}

ul.tocSubEntryList li.tocSubEntry {
    list-style: none;
}

#colorbox {
		display: none;
}
.spec_sheet_line {
		margin-bottom: 1px;
}
.collapsible {
		display: none;
}
.toc_leadspace {
		width: 10; min-width: 10;
}
.disclosure_triangle_td {
		width: 14; min-width: 14;
		font-size: 10px;
		vertical-align: middle;
}
.specbox td {
		font-size: 13px;
}
.specbox td a {
		font-size: 13px;
}
.specbox td code {
		font-size: 13px;
}
.specbox td tt {
		font-size: 13px;
}
.specbox td pre {
		font-size: 13px;
}
.specbox a {
		font-size: 12px;
}
.disclosure_triangle_td a {
		text-decoration: none;
}
.disclosure_triangle_td a:link {
		text-decoration: none;
}
.disclosure_triangle_td a:active {
		text-decoration: none;
}
.disclosure_triangle_td a:visited:hover {
		text-decoration: none;
}
.disclosure_triangle_td a:hover {
		text-decoration: none;
}
.hd_toc_box {
		padding-top: 10px;
		padding-right: 15px;
}.tocSeparator {
		margin-top: 15px;
		padding-bottom: 0px;
		margin-bottom: 0px;
}
.tocSubEntryList {
		margin-left: 0px;
		padding-left: 40px;
		padding-top: 0px;
		margin-top: 2px;
		padding-bottom: 0px;
		margin-bottom: 8px;
}
.hd_toc_heading_table {
		margin-top: 2px;
		margin-bottom: 2px;
}
.hd_toc_entry_table {
		margin-top: 2px;
		margin-bottom: 2px;
}
.tocSubEntry {
		margin-left: 0px;
		padding-left: 0px;
		margin-top: 0px;
		margin-bottom: 1px;
}
.tocSubEntry a {
		font-size: 10pt;
}
.tocSubheading {
		padding-left: 14px;
		margin-left: 0px;
		margin-top: 5px;
		padding-top: 0px;
		font-size: 16px;
		color: #808080;
}

#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }
#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }

#tocMenu {
		border-right: 1px solid #c0c0c0;
		background-color: #f4f4ff;
		top:0px;
		left:0px;
		width:230px;
		height:100%;
}
#bodyContents {
		width: auto;
		padding-left: 15px;
}
--></style>
<style id="disable_before_iOS_5"><!--
#tocMenu {
		position: fixed;
		height: 100%;
		overflow: auto;
}
#bodyContents {
		width: auto;
		left: 235px;
		right: 0;
		padding-left: 15px;
		position: fixed;
		height: 100%;
		overflow-y: scroll;
}
--></style>
<script language="JavaScript" type="text/javascript"><!--
    if (navigator.platform && (navigator.platform.match(/iPad/) || navigator.platform.match(/iPhone/) || navigator.platform.match(/iPod/))) {
        if (navigator.userAgent.match(/OS 1(_\d)+/) ||
            navigator.userAgent.match(/OS 2(_\d)+/) ||
            navigator.userAgent.match(/OS 3(_\d)+/) ||
            navigator.userAgent.match(/OS 4(_\d)+/)) {
                /* Earlier iOS versions require different scrolling gestures with position: fixed. */
                var del_style_elt = document.getElementById("disable_before_iOS_5");
                if (del_style_elt) del_style_elt.parentNode.removeChild(del_style_elt);
        }
    }
// --></script><script language="JavaScript" type="text/javascript"><!--
function getNewHTTPObject()
{
        var xmlhttp;

        /** Special IE only code ... */
        /*@cc_on
          @if (@_jscript_version >= 5)
              try
              {
                  xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');
              }
              catch (e)
              {
                  try
                  {
                      xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');
                  }
                  catch (E)
                  {
                      xmlhttp = false;
                  }
             }
          @else
             xmlhttp = false;
        @end @*/

        /** Every other browser on the planet */
        if (!xmlhttp && typeof XMLHttpRequest != 'undefined')
        {
            try
            {
                xmlhttp = new XMLHttpRequest();
            }
            catch (e)
            {
                xmlhttp = false;
            }
        }

        return xmlhttp;
}

function hidetoc() {
	var toc = document.getElementById('tocMenu');
	var src = toc.getAttribute('src');
	var xhr = getNewHTTPObject();
	xhr.open('GET', src, true);
	xhr.onreadystatechange = function() {
		if(xhr.readyState == 4) {
			var toc = document.getElementById('tocMenu');
			toc.innerHTML = xhr.responseText;
		}
	}
	xhr.send(null);
	var origURL = parent.document.URL;
	var contentURL = origURL.substring(origURL.indexOf('?')+1, origURL.length);
	if (contentURL.length == origURL.length) {
		jumpPos = origURL.substring(origURL.indexOf('#')+1, origURL.length);
	}
	if (contentURL == "hidetoc") {
		var body = document.getElementById('bodyContents');
		if (toc && body) {
			toc.style.display = 'none';
			body.style.marginLeft = '0px';
		}
	}
}

function disclosure_triangle(elt) {
   var linkelt = elt;
   while (elt && elt.tagName != 'TABLE') { elt = elt.parentNode;}
   if (!elt) { return; }
   while (elt && elt.tagName != 'DIV') { elt = elt.nextSibling;}
   if (!elt) { return; }
   if (parseInt(linkelt.getAttribute('state'))) {
      // It's open.  Close it
      linkelt.innerHTML = '&#x25B7;';
      linkelt.setAttribute('state', 0);
      linkelt.setAttribute('class', 'closed_disclosure_triangle');
      elt.style.display = 'none';
   } else {
      // It's closed.  Open it
      linkelt.innerHTML = '&#x25BC;';
      linkelt.setAttribute('state', 1);
      linkelt.setAttribute('class', 'open_disclosure_triangle');
      elt.style.display = 'block';
   }
}
--></script><style type="text/css"><!--.char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;}body {border: 0px; margin: 0px;}div {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}td {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}span.hd_tocAccessSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroupSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroup { display: block; font-weight: bold; font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; margin-left: 0px; padding-left: 40px; }span.hd_tocGroup + span.hd_tocAccess { padding-top: 5px; }td.toc_contents_text {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; }li.tocSubEntry {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}p {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}a:link {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:active {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}h2.h2tight { margin-top: 0px; padding-top: 0px; }h1 { margin-top: 13px; padding-top: 0px; }h4 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: tiny; font-weight: bold;}h5 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: 10.1pt; font-weight: bold;}pre {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666; font-size: 10pt;}pre a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}pre a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}body  {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt; padding-left: 0px; padding-top: 0px; margin-left: 0px; margin-top: 0px; border: none; }#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }.afterName { display: none; }.list_indent { margin-left: 40px; }.declaration_indent { margin-left: 40px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; min-height: 12px; vertical-align: middle; }.declaration_indent pre { margin-top: 20px; padding-top: 0px; margin-bottom: 20px; padding-bottom: 0px; }.gapBeforeFooter { display: none; }hr { height: 0px; min-height: 0px; border-top: none; border-left: none; border-right: none; border-bottom: 1px solid #909090;}hr.afterHeader { display: none }.param_group_indent { margin-left: 25px; }.param_indent { margin-left: 40px; margin-top: 0px; padding-top: 0px; }.param_indent dl { margin-top: 4px; padding-top: 0px; }dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.param_indent dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.group_indent { margin-left: 40px; }.group_desc_indent { margin-left: 20px; }.warning_indent { margin-left: 40px; }.important_indent { margin-left: 40px; }.note_indent { margin-left: 40px; }h3 {       color: #3C4C6C;}.tight {       margin-top: 2px; margin-bottom: 0px;       padding-top: 0px; padding-bottom: 0px;}h3 a {       color: #3C4C6C;	font-size: 16px;	font-style: normal;	font-variant: normal;	font-weight: bold;	height: 0px;	line-height: normal;}.hd_tocAccess { display: block; margin-left: 40px; font-style: italic; font-size: 10px; font-weight: normal; color: #303030; }.tocSubheading { margin-bottom: 4px; }--></style>
</head>
<body bgcolor="#ffffff" onload="hidetoc();">
<!-- headerDoc=Header;  uid=//apple_ref/doc/header/vImage.h;   name=vImage.h -->
<a name="//apple_ref/doc/header/vImage.h"></a>
<table id="hd_outermost_table" height="100%" width="100%"><tr>
<td valign="top" id="tocMenu" src="toc.html"></td>
<td id="bodyContents" valign="top">
<a name="top"></a>
<h1><a name="vImage.h">vImage.h</a></h1>
<div class="spec_sheet_info_box"><table cellspacing="0" class="specbox">
<tr>
<td scope="row"><b>Compiler Flags:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text"><dl>
<dt><p>-framework</p></dt>
<dd>Accelerate</dd>
</dl></div></div></td>
</tr>
<tr>
<td scope="row"><b>Includes:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text">
<a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/header/vImage_Types.h" logicalPath="//apple_ref/doc/header/vImage_Types.h" target="_top">&lt;vImage/vImage_Types.h&gt;</a><br><a machinegenerated="true" href="../Alpha_h/index.html#//apple_ref/doc/header/Alpha.h" logicalPath="//apple_ref/doc/header/Alpha.h" target="_top">&lt;vImage/Alpha.h&gt;</a><br><a machinegenerated="true" href="../Convolution_h/index.html#//apple_ref/doc/header/Convolution.h" logicalPath="//apple_ref/doc/header/Convolution.h" target="_top">&lt;vImage/Convolution.h&gt;</a><br><a machinegenerated="true" href="../Conversion_h/index.html#//apple_ref/doc/header/Conversion.h" logicalPath="//apple_ref/doc/header/Conversion.h" target="_top">&lt;vImage/Conversion.h&gt;</a><br><!-- a logicalPath="//apple_ref/doc/header/Geometry.h" machineGenerated="true" -->&lt;vImage/Geometry.h&gt;<!-- /a --><br><a machinegenerated="true" href="../Histogram_h/index.html#//apple_ref/doc/header/Histogram.h" logicalPath="//apple_ref/doc/header/Histogram.h" target="_top">&lt;vImage/Histogram.h&gt;</a><br><a machinegenerated="true" href="../Morphology_h/index.html#//apple_ref/doc/header/Morphology.h" logicalPath="//apple_ref/doc/header/Morphology.h" target="_top">&lt;vImage/Morphology.h&gt;</a><br><!-- a logicalPath="//apple_ref/doc/header/BasicImageTypes.h" machineGenerated="true" -->&lt;vImage/BasicImageTypes.h&gt;<!-- /a --><br><a machinegenerated="true" href="../Transform_h/index.html#//apple_ref/doc/header/Transform.h" logicalPath="//apple_ref/doc/header/Transform.h" target="_top">&lt;vImage/Transform.h&gt;</a><br><a machinegenerated="true" href="../vImage_Utilities_h/index.html#//apple_ref/doc/header/vImage_Utilities.h" logicalPath="//apple_ref/doc/header/vImage_Utilities.h" target="_top">&lt;vImage/vImage_Utilities.h&gt;</a><br><a machinegenerated="true" href="../vImage_CVUtilities_h/index.html#//apple_ref/doc/header/vImage_CVUtilities.h" logicalPath="//apple_ref/doc/header/vImage_CVUtilities.h" target="_top">&lt;vImage/vImage_CVUtilities.h&gt;</a></div></div></td>
</tr>
</table></div>
<h2>Introduction</h2>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/doc/header/vImage.h;name=start --><pre> 
    Data Formats
    ------------
    Most functions are available in four flavors, one for each of the four standard data formats supported
    by vImage. These are:

    8 bit planar integer data  -- "Planar8":
        The buffer contains a single color channel (e.g. red) as an array of packed unsigned chars.

    32 bit planar floating point data -- "PlanarF":
        The buffer contains a single color channel (e.g. red) as an array of packed floats.

    8 bit ARGB interleaved integer data -- "ARGB8888":
        The buffer contains four interleaved color channels in the order alpha, red, green, blue, in a
        packed array of unsigned chars. (This is a standard 32 bit ARGB color pixel, with 8 bits per channel).

    32 bit ARGB interleaved floating point data -- "ARGBFFFF":
        The buffer contains four interleaved color channels in the order alpha, red, green, blue, in a
        packed array of floats.

    Many functions are also available in Planar and ARGB versions of unsigned and signed 16-bit integer, 16S and
    16U respectively.

    PERFORMANCE ADVISORY: Performance of the planar versions of these functions will in some cases
    be *MUCH* better than their interleaved counterparts. Most operations are done in register with planar
    data, even if the starting data format was an interleaved format. By using planar data formats,
    you avoid the de-interleave, re-interleave cost in each function call. In addition, where calculation
    on the alpha channel is not desired, the computational cost and cache usage for planar formats is
    in principle 3/4 the cost of interleaved formats for four channel data. Finally planar data is a natural
    form of tiling that works well when used with multiple serial filters. When applying multiple filters to
    a image, apply them all to one channel, then repeat the sequence for the next channel and so forth until
    all the color channels are calculated. This will help keep key data in the caches and in some cases may
    produce profound performance improvements.

    The presumed value range for 8 bit color channels is 0 to 255, with 0 being black and 255 being full intensity color.
    For floating point data, 0.0f is black and 1.0f is full intensity color. Values outside this range are allowed for
    floating point data. Except where noted, FP calculations do not clip values outside the range 0.0f ... 1.0f. In certain
    cases (most notably geometry operations that involve resampling and colvolutions), it is possible that input data
    that is entirely withing the range 0.0f ... 1.0f will produce results that are slightly outside that range. A separate
    floating point clipping function is provided if clipping is required.

    Other floating point ranges (e.g. 0.0f ... 255.0f) are likely to also work since most functions in vImage are linear.
    However, they are not extensively tested.

    vImage_Buffers
    --------------
    Most vImage functions attempt to fill a destination buffer with pixels drawn from an input buffer using some
    transformation. In some cases, the operation would require that pixels outside the area covered by the input
    buffer be used to fill the output buffer. The input vImage_Buffer defines the absolute limit of the area of
    data that may be read by the function. The function will not stray outside of this area in its attempt to
    fill the destination with pixels. How a function copes with edge cases when data is unavailable is dependent
    on the function.

        typedef struct vImage_Buffer
        {
            void                *data;		// Pointer to the top left pixel of the buffer.
            vImagePixelCount	  height;		// The height (in pixels) of the buffer
            vImagePixelCount    width;		// The width (in pixels) of the buffer
            size_t              rowBytes;	    // The number of bytes in a pixel row
        }vImage_Buffer;

    Some functions may operate only on a rectangular subset of pixels in the input buffer. This is useful for tiling
    or for when image operations are only desired to be applied to part of an image. The top left corner of the subset
    is provided by a X and Y offset into the vImage_Buffer passed as the input buffer. The height and width of the input
    region of interest is in many cases given by the height and width of the destination buffer. The geometry operators
    use non-rectangular input regions of interest making it difficult to predict which pixels will be used. In this case,
    the offsets (if any) are the offsets into the input region of interest for the case where the scale factor is 1.0 and
    shear and translate are 0.0f.

    Please be aware that many functions, especially those that require kernels or which do resampling, will read
    outside the input region of interest. Some extra care with multithreaded code may be required in those cases to make
    sure nobody is changing data outside the region of interest that is read by the function while the function is operating.
    At no time will a function read outside the vImage_Buffer within which the region of interest resides.

    So as to make multithreaded tiled (stripmined) algorithms easy to write, vImage makes two guarantees:

        (1) vImage will never write data outside of the destination vImage_Buffer. vImage will not try to cheat this
            guarantee by reading data outside the destination buffer and writing it back unmodified.

        (2) vImage will never read data outside of the area passed to it as the input vImage_Buffer.

    The state of the output vImage_Buffer while a vImage function is working on it is undefined. There may be times when
    a pixel in the ROI is neither the starting data or the finished result, but instead the result of some
    intermediate calculation. The calculation is complete when the function returns.

    Note that although a vImage_Buffer struct may be marked const, this does not mean that the pixel data that
    it points to is also const. It is merely an indication that it is safe to reuse the struct between function
    calls. Except where noted, the pixel data in the input buffers will not be changed by the function. vImage
    does not go to extreme lengths to guarantee this however, so for example you may pass the same buffer as input
    and output to a function, in which case the input buffer will be changed.
    Caution: except where otherwise documented, most vImage functions do not work correctly in place.

    Performance advisory: If the rowBytes of a vImage_Buffer is a integer power of 2, performance may be adversely
    affected on some functions. (This is a side effect of how some machines handle address arithmetic
    internally. It is not something we can solve in software, except by setting rowBytes differently. ) 
    In some cases, it may also be advantageous to pad rowbytes out to 16 bytes. Using vImageBuffer_Init() 
    in vImage/vImage_Utilities.h will help sidestep this issue. It will attempt tune rowBytes to benefit the 
    current architecture.

    It is not required that you do set up your buffers exactly this way, however. To protect your investment in
    preexisting data structures, vImage is designed to work with any (natural) data alignment and any rowBytes.
    Floats must be 4 byte aligned. RowBytes must of course be greater than or equal to width * bytesPerPixel.
    BytesPerPixel values are as follows:

        Buffer Data Format	Size
        ------------------	----
        planar uint8		    sizeof( Pixel_8)		// 1 byte
        planar float		    sizeof( Pixel_F )		// 4 bytes
        ARGB uint8			sizeof( Pixel_8888)		// 4 bytes
        ARGB float			sizeof( Pixel_FFFF )	// 16 bytes



    Tiling / Strip Mining and Multithreading
    ----------------------------------------
    In general, the size of the data segment that you operate on is critical to the performance of vImage. In
    many cases, the number of pixels that may be processed per second can be up to an order of magnitude lower
    for large buffers than for small ones.  A common method to fix this is to operate on small chunks of the image
    at a time. Typically, you would apply all the filters one after another to one chunk, before going on to the next
    chunk. In this way, the data is much more likely to be in the caches when you need it. This motif is easily
    multithreaded in principle, since different processors can work on different chunks concurrently in many
    cases.

    All vImage functions are thread safe and may be called reentrantly.

    A quick test to do to see if tiling is good for you is to measure the number of pixels that you can process
    per second for very large (&gt;4 MB uncompressed) and reasonably small (&lt; 256 kB uncompressed) images. If the
    number of pixels you can process per unit time is much improved for smaller images over large ones then tiling
    is likely to be helpful.

    It is important to whenever possible make sure the tile fits in the caches. In general, the data processed in
    a single tile (including input and output buffers) should be less than 256 kB, though in some cases there may
    be a performance advantage to even smaller buffers. We have found that for many, 16-32 kB is a better number.
    In many cases, you will only see performance improvement if the tile is significantly wider than it is tall,
    for example 16 rows tall and 1024 horizontal bytes of pixels wide has been observed to be twice as fast as
    64x128. Clearly having a tile wider than the image isn't very helpful.

    A convenience method for making a vImage_Buffer that refers to a rectangular sub-region of another vImage_Buffer:

      // Calculate a vImage_Buffer descriptor for a sub-rectangle within an image
      // This function does not attempt to ensure that the tile fits in the image.
      vImage_Buffer   MyMakeTileFromImage( const vImage_Buffer *image,
                                           unsigned long startColumn, // x coordinate of top left corner of tile
                                           unsigned long startRow,    // y coordinate of top left corner of tile
                                           unsigned long tileHeight,  // number of rows in tile
                                           unsigned long tileWidth,   // number of columns in tile
                                           size_t pixelBytes ){       // number of bytes in pixel
          return (vImage_Buffer){
              .data = (void*) ((char*) image-&gt;data + startColumn * pixelBytes + startRow * image-&gt;rowBytes),
              .height = tileHeight,
              .width = tileWidth,
              .rowBytes = image-&gt;rowBytes
          };
      }

    CAUTION:  This will cause vImage to believe the edges of the image are at the edges of the tile. Usually that 
              doesn't affect the result, but will for convolultions, morphology operations and geometry operations
              --  things that take a edge mode flag.  For such routines, the start of the tile is declared using
              a srcOffsetToROI_X/Y  and the size of the tile is inferred from the destination image size.

    Sometimes you may want to flip an image vertically. In vImage, this can be done cheaply by adjusting the pointer
    to point to the last scanline of the image and setting rowBytes negative, for either the source or destination
    image:

      static inline vImage_Buffer MyFlipVertical( const vImage_Buffer *b ) __attribute__ ((always_inline,nodebug));
      static inline vImage_Buffer MyFlipVertical( const vImage_Buffer *b ){
          return (vImage_Buffer){ .data = (void*) ( (char*)b-&gt;data + b-&gt;rowBytes * (b-&gt;height-1)),
                                  .height = b-&gt;height,
                                  .width = b-&gt;width,
                                  .rowBytes = -b-&gt;rowBytes };
      }

    CAUTION:  While vImage will put up with this sort of abuse, other frameworks may not. Make sure the data is
              right side up before passing it to anyone else.

    Real Time Applications
    ----------------------
    vImage attempts to avoid doing things that will damage its suitability for use in real time applications.
    vImage will in general never take a lock, or do things that might involve taking a lock, such as allocating
    memory. Functions that may take a lock will be documented as such.  Some functions take temporary buffers
    as arguments. If you do not provide a temporary buffer, they may call malloc.

    Unused Flag Bits
    ----------------
    Many of the bits in the vImage_Flags datatype are currently unused. Apple reserves all bits in the flags field
    for their exclusive use. You must set all unused bits to 0 in the flags field. If you do not do this, in the
    future some of these bits may become active and your application may start doing unexpected things when image
    processing.

    Getting Data in and out of vImage
    ---------------------------------
    Since vImage will simply use your data in place in your objects, interfacing with your existing image pipeline
    should be a simple matter of intializing the vImage_Buffer struct fields to correspond to the location and
    and shape of your data.  
 
    When the objects are not yours and are opaque, then getting data in and out of those objects can be a little
    more work.  Most image frameworks have a method to import and export raw data. These are often simple to use
    but the data is frequently not in the format you wanted. In such cases, please see vImage/vImage_Utilities.h for
    vImageConvert_AnyToAny() which can convert nearly any image format to nearly any other one with full colorspace
    conversion, if desired, even on iOS. This should help you convert the output of one imaging library into 
    something useful for another one.  (It is used by ImageIO.framework for example, to convert the many different 
    image buffer formats produced by PNG, JPEG, GIF, TIFF, etc. to formats more favored by CoreGraphics, CoreAnimation 
    and CoreImage, for example.)  The conversions are vectorized and multithreaded to minimize time and energy 
    consumption.

    If the opaque image object comes from CoreGraphics (CGImageRef) or CoreVideo (CVPixelBufferRef), then high level
    convenience routines are provided to import and export data from those sources as vImage_Buffers. See
    vImage/vImage_Utilities.h and vImage/vImage_CVUtilities.h respectively for these.  Since the conversions go through
    the same vImageConvert_AnyToAny core, it is possible to convert all the way from a YUV 420 format out to CMYK for
    a printer in a single function call, or anywhere inbetween, if you want. A few formats like 565 and half float not 
    usually part of CG are supported as a bonus.

    </pre>
<!-- headerDoc=discussion;uid=//apple_ref/doc/header/vImage.h;name=end --><!-- end discussion -->
<p class="gapBeforeFooter">&nbsp;</p>
<hr class="afterFooter">
<div class="hd_copyright_and_timestamp">
<p class="hd_copyright">&copy; Copyright (c) 2002-2015 by Apple Inc. All rights reserved.
 </p>
<p class="hd_timestamp">Last Updated: Thursday, December 24, 2015
</p>
</div>
</td>
</tr></table>
</body>
</html>
