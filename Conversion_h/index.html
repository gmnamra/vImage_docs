<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head>
<title>Conversion.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf8">
<meta name="generator" content="HeaderDoc">
<meta name="xcode-display" content="render">
<style type="text/css"><!--.char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;}body {border: 0px; margin: 0px;}div {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}td {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}span.hd_tocAccessSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroupSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroup { display: block; font-weight: bold; font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; margin-left: 0px; padding-left: 40px; }span.hd_tocGroup + span.hd_tocAccess { padding-top: 5px; }td.toc_contents_text {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; }li.tocSubEntry {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}p {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}a:link {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:active {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}h2.h2tight { margin-top: 0px; padding-top: 0px; }h1 { margin-top: 13px; padding-top: 0px; }h4 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: tiny; font-weight: bold;}h5 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: 10.1pt; font-weight: bold;}pre {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666; font-size: 10pt;}pre a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}pre a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}body  {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt; padding-left: 0px; padding-top: 0px; margin-left: 0px; margin-top: 0px; border: none; }#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }.afterName { display: none; }.list_indent { margin-left: 40px; }.declaration_indent { margin-left: 40px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; min-height: 12px; vertical-align: middle; }.declaration_indent pre { margin-top: 20px; padding-top: 0px; margin-bottom: 20px; padding-bottom: 0px; }.gapBeforeFooter { display: none; }hr { height: 0px; min-height: 0px; border-top: none; border-left: none; border-right: none; border-bottom: 1px solid #909090;}hr.afterHeader { display: none }.param_group_indent { margin-left: 25px; }.param_indent { margin-left: 40px; margin-top: 0px; padding-top: 0px; }.param_indent dl { margin-top: 4px; padding-top: 0px; }dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.param_indent dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.group_indent { margin-left: 40px; }.group_desc_indent { margin-left: 20px; }.warning_indent { margin-left: 40px; }.important_indent { margin-left: 40px; }.note_indent { margin-left: 40px; }h3 {       color: #3C4C6C;}.tight {       margin-top: 2px; margin-bottom: 0px;       padding-top: 0px; padding-bottom: 0px;}h3 a {       color: #3C4C6C;	font-size: 16px;	font-style: normal;	font-variant: normal;	font-weight: bold;	height: 0px;	line-height: normal;}.hd_tocAccess { display: block; margin-left: 40px; font-style: italic; font-size: 10px; font-weight: normal; color: #303030; }.tocSubheading { margin-bottom: 4px; }--></style>
<style><!--
body {
    padding: 0px;
    margin: 0px;
    border: 0px;
}
.toc_contents_text {
    padding-left: 1em;
    text-indent: -1em;
}

ul.tocSubEntryList li.tocSubEntry {
    list-style: none;
}

#colorbox {
		display: none;
}
.spec_sheet_line {
		margin-bottom: 1px;
}
.collapsible {
		display: none;
}
.toc_leadspace {
		width: 10; min-width: 10;
}
.disclosure_triangle_td {
		width: 14; min-width: 14;
		font-size: 10px;
		vertical-align: middle;
}
.specbox td {
		font-size: 13px;
}
.specbox td a {
		font-size: 13px;
}
.specbox td code {
		font-size: 13px;
}
.specbox td tt {
		font-size: 13px;
}
.specbox td pre {
		font-size: 13px;
}
.specbox a {
		font-size: 12px;
}
.disclosure_triangle_td a {
		text-decoration: none;
}
.disclosure_triangle_td a:link {
		text-decoration: none;
}
.disclosure_triangle_td a:active {
		text-decoration: none;
}
.disclosure_triangle_td a:visited:hover {
		text-decoration: none;
}
.disclosure_triangle_td a:hover {
		text-decoration: none;
}
.hd_toc_box {
		padding-top: 10px;
		padding-right: 15px;
}.tocSeparator {
		margin-top: 15px;
		padding-bottom: 0px;
		margin-bottom: 0px;
}
.tocSubEntryList {
		margin-left: 0px;
		padding-left: 40px;
		padding-top: 0px;
		margin-top: 2px;
		padding-bottom: 0px;
		margin-bottom: 8px;
}
.hd_toc_heading_table {
		margin-top: 2px;
		margin-bottom: 2px;
}
.hd_toc_entry_table {
		margin-top: 2px;
		margin-bottom: 2px;
}
.tocSubEntry {
		margin-left: 0px;
		padding-left: 0px;
		margin-top: 0px;
		margin-bottom: 1px;
}
.tocSubEntry a {
		font-size: 10pt;
}
.tocSubheading {
		padding-left: 14px;
		margin-left: 0px;
		margin-top: 5px;
		padding-top: 0px;
		font-size: 16px;
		color: #808080;
}

#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }
#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }

#tocMenu {
		border-right: 1px solid #c0c0c0;
		background-color: #f4f4ff;
		top:0px;
		left:0px;
		width:230px;
		height:100%;
}
#bodyContents {
		width: auto;
		padding-left: 15px;
}
--></style>
<style id="disable_before_iOS_5"><!--
#tocMenu {
		position: fixed;
		height: 100%;
		overflow: auto;
}
#bodyContents {
		width: auto;
		left: 235px;
		right: 0;
		padding-left: 15px;
		position: fixed;
		height: 100%;
		overflow-y: scroll;
}
--></style>
<script language="JavaScript" type="text/javascript"><!--
    if (navigator.platform && (navigator.platform.match(/iPad/) || navigator.platform.match(/iPhone/) || navigator.platform.match(/iPod/))) {
        if (navigator.userAgent.match(/OS 1(_\d)+/) ||
            navigator.userAgent.match(/OS 2(_\d)+/) ||
            navigator.userAgent.match(/OS 3(_\d)+/) ||
            navigator.userAgent.match(/OS 4(_\d)+/)) {
                /* Earlier iOS versions require different scrolling gestures with position: fixed. */
                var del_style_elt = document.getElementById("disable_before_iOS_5");
                if (del_style_elt) del_style_elt.parentNode.removeChild(del_style_elt);
        }
    }
// --></script><script language="JavaScript" type="text/javascript"><!--
function getNewHTTPObject()
{
        var xmlhttp;

        /** Special IE only code ... */
        /*@cc_on
          @if (@_jscript_version >= 5)
              try
              {
                  xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');
              }
              catch (e)
              {
                  try
                  {
                      xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');
                  }
                  catch (E)
                  {
                      xmlhttp = false;
                  }
             }
          @else
             xmlhttp = false;
        @end @*/

        /** Every other browser on the planet */
        if (!xmlhttp && typeof XMLHttpRequest != 'undefined')
        {
            try
            {
                xmlhttp = new XMLHttpRequest();
            }
            catch (e)
            {
                xmlhttp = false;
            }
        }

        return xmlhttp;
}

function hidetoc() {
	var toc = document.getElementById('tocMenu');
	var src = toc.getAttribute('src');
	var xhr = getNewHTTPObject();
	xhr.open('GET', src, true);
	xhr.onreadystatechange = function() {
		if(xhr.readyState == 4) {
			var toc = document.getElementById('tocMenu');
			toc.innerHTML = xhr.responseText;
		}
	}
	xhr.send(null);
	var origURL = parent.document.URL;
	var contentURL = origURL.substring(origURL.indexOf('?')+1, origURL.length);
	if (contentURL.length == origURL.length) {
		jumpPos = origURL.substring(origURL.indexOf('#')+1, origURL.length);
	}
	if (contentURL == "hidetoc") {
		var body = document.getElementById('bodyContents');
		if (toc && body) {
			toc.style.display = 'none';
			body.style.marginLeft = '0px';
		}
	}
}

function disclosure_triangle(elt) {
   var linkelt = elt;
   while (elt && elt.tagName != 'TABLE') { elt = elt.parentNode;}
   if (!elt) { return; }
   while (elt && elt.tagName != 'DIV') { elt = elt.nextSibling;}
   if (!elt) { return; }
   if (parseInt(linkelt.getAttribute('state'))) {
      // It's open.  Close it
      linkelt.innerHTML = '&#x25B7;';
      linkelt.setAttribute('state', 0);
      linkelt.setAttribute('class', 'closed_disclosure_triangle');
      elt.style.display = 'none';
   } else {
      // It's closed.  Open it
      linkelt.innerHTML = '&#x25BC;';
      linkelt.setAttribute('state', 1);
      linkelt.setAttribute('class', 'open_disclosure_triangle');
      elt.style.display = 'block';
   }
}
--></script><style type="text/css"><!--.char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;}body {border: 0px; margin: 0px;}div {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}td {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}span.hd_tocAccessSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroupSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroup { display: block; font-weight: bold; font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; margin-left: 0px; padding-left: 40px; }span.hd_tocGroup + span.hd_tocAccess { padding-top: 5px; }td.toc_contents_text {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; }li.tocSubEntry {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}p {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}a:link {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:active {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}h2.h2tight { margin-top: 0px; padding-top: 0px; }h1 { margin-top: 13px; padding-top: 0px; }h4 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: tiny; font-weight: bold;}h5 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: 10.1pt; font-weight: bold;}pre {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666; font-size: 10pt;}pre a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}pre a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}body  {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt; padding-left: 0px; padding-top: 0px; margin-left: 0px; margin-top: 0px; border: none; }#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }.afterName { display: none; }.list_indent { margin-left: 40px; }.declaration_indent { margin-left: 40px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; min-height: 12px; vertical-align: middle; }.declaration_indent pre { margin-top: 20px; padding-top: 0px; margin-bottom: 20px; padding-bottom: 0px; }.gapBeforeFooter { display: none; }hr { height: 0px; min-height: 0px; border-top: none; border-left: none; border-right: none; border-bottom: 1px solid #909090;}hr.afterHeader { display: none }.param_group_indent { margin-left: 25px; }.param_indent { margin-left: 40px; margin-top: 0px; padding-top: 0px; }.param_indent dl { margin-top: 4px; padding-top: 0px; }dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.param_indent dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.group_indent { margin-left: 40px; }.group_desc_indent { margin-left: 20px; }.warning_indent { margin-left: 40px; }.important_indent { margin-left: 40px; }.note_indent { margin-left: 40px; }h3 {       color: #3C4C6C;}.tight {       margin-top: 2px; margin-bottom: 0px;       padding-top: 0px; padding-bottom: 0px;}h3 a {       color: #3C4C6C;	font-size: 16px;	font-style: normal;	font-variant: normal;	font-weight: bold;	height: 0px;	line-height: normal;}.hd_tocAccess { display: block; margin-left: 40px; font-style: italic; font-size: 10px; font-weight: normal; color: #303030; }.tocSubheading { margin-bottom: 4px; }--></style>
</head>
<body bgcolor="#ffffff" onload="hidetoc();">
<!-- headerDoc=Header;  uid=//apple_ref/doc/header/Conversion.h;   name=Conversion.h -->
<a name="//apple_ref/doc/header/Conversion.h"></a>
<table id="hd_outermost_table" height="100%" width="100%"><tr>
<td valign="top" id="tocMenu" src="toc.html"></td>
<td id="bodyContents" valign="top">
<a name="top"></a>
<h1><a name="Conversion.h">Conversion.h</a></h1>
<div class="spec_sheet_info_box"><table cellspacing="0" class="specbox"><tr>
<td scope="row"><b>Includes:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text">
<a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/header/vImage_Types.h" logicalPath="//apple_ref/doc/header/vImage_Types.h" target="_top">&lt;vImage/vImage_Types.h&gt;</a></div></div></td>
</tr></table></div>
<h2>Introduction</h2>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/doc/header/Conversion.h;name=start --><p>This header lists conversions between the many different image formats supported by vImage.  The core formats:
      </p>
<pre> 
          Planar 8        Planar 16U      Planar 16S      Float
          ARGB8888        ARGB16U         ARGB16S         ARGBFFFF        (also available in other channel orderings)
       </pre>
<p>are supported generally throughout vImage. Other formats may need to be converted to a core format before much can be
done with them. Many conversions between core formats as well as those between core formats and non-core formats are available here.
Please also see vImage_Utilities.h and vImage_CVUtilities.h for interfaces that allow for conversion between various CoreGraphics
and CoreVideo formats.  In many cases, those interfaces can serve as a simpler entrypoint into these APIs. They should be strongly 
considered in cases where your code has to handle a variety of different image formats. These interfaces provide direct access to 
the low-level workhorse functions for the case when you know exactly what image formats you are working with and want to just call
the right conversion directly.
</p>
<p>Generally speaking, conversions are much faster than other image filters. When tiled correctly, they do not add a lot of extra cost
in cases where you find that your image format is not directly supported by other image filters. They are usually fast enough that 
their performance is bottlenecked by throughput to L2, L3, etc. caches.  They benefit greatly from tiling, usually performing best 
with wide tile sizes that are less than half the size of the L1 cache. Because of the L1 cache residency requirement for best performance,
they are often not internally multithreaded (it wouldn't help for out-of-cache performance and would cause slowdowns for in-cache) 
and may need  to be used within the context of your tiling engine (or vImageConvert_AnyToAny) to reach peak performance. If you are calling
vImage functions within your own multithreaded tiling engine, it is recommended that you use the kvImageDoNotTile flag to make sure that
vImage does its work on the calling thread. This will help ensure that the data just produced on that thread by a previous pass 
is resident in the correct L1 cache for the next pass.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/doc/header/Conversion.h;name=end --><!-- end discussion -->
<hr class="afterClassOrHeaderInfo">
<br><a name="HeaderDoc_groups"><h2 class="h2tight">Groups</h2></a>

<h3>444CrYpCb8 ('v308')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888" target="_top">vImageConvert_444CrYpCb8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 444CrYpCb8 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8" target="_top">vImageConvert_ARGB8888To444CrYpCb8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444CrYpCb8 format
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>422YpCbYpCr8 ('yuvs' and 'yuvf')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888" target="_top">vImageConvert_422YpCbYpCr8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 422YpCbYpCr8 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8" target="_top">vImageConvert_ARGB8888To422YpCbYpCr8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 422YpCbYpCr8 format.
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>420Yp8_Cb8_Cr8 ('y420' and 'f420')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888" target="_top">vImageConvert_420Yp8_Cb8_Cr8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 420Yp8_Cb8_Cr8 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8" target="_top">vImageConvert_ARGB8888To420Yp8_Cb8_Cr8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 420Yp8_Cb8_Cr8 format.
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>422CbYpCrYp8_AA8 ('a2vy')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888" target="_top">vImageConvert_422CbYpCrYp8_AA8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 422CbYpCrYp8_AA8 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8" target="_top">vImageConvert_ARGB8888To422CbYpCrYp8_AA8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 422CbYpCrYp8_AA8 format
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>444CrYpCb10 ('v410')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12" logicalPath="//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12" target="_top">vImageConvert_444CrYpCb10ToARGB16Q12</a></tt></dt>
<dd>
<p>Convert YUV 444CrYpCb10 format to ARGB16Q12
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888" target="_top">vImageConvert_444CrYpCb10ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 444CrYpCb10 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10" logicalPath="//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10" target="_top">vImageConvert_ARGB16Q12To444CrYpCb10</a></tt></dt>
<dd>
<p>Convert ARGB16Q12 to YUV 444CrYpCb10 format
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10" target="_top">vImageConvert_ARGB8888To444CrYpCb10</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444CrYpCb10 format
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>RGBA1010102</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102" logicalPath="//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102" target="_top">vImageConvert_ARGB16Q12ToRGBA1010102</a></tt></dt>
<dd>
<p>Convert ARGB16Q12 to RGBA1010102 format.
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102" logicalPath="//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102" target="_top">vImageConvert_ARGB16UToRGBA1010102</a></tt></dt>
<dd>
<p>Convert ARGB16U to RGBA1010102 format.
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102" target="_top">vImageConvert_ARGB8888ToRGBA1010102</a></tt></dt>
<dd>
<p>Convert ARGB8888 to RGBA1010102 format.
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12" logicalPath="//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12" target="_top">vImageConvert_RGBA1010102ToARGB16Q12</a></tt></dt>
<dd>
<p>Convert RGBA1010102 to ARGB16Q12 format.
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U" logicalPath="//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U" target="_top">vImageConvert_RGBA1010102ToARGB16U</a></tt></dt>
<dd>
<p>Convert RGBA1010102 to ARGB16U format.
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888" target="_top">vImageConvert_RGBA1010102ToARGB8888</a></tt></dt>
<dd>
<p>Convert RGBA1010102 to ARGB8888 format.
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>420Yp8_CbCr8 ('420v' and '420f')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888" target="_top">vImageConvert_420Yp8_CbCr8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 420Yp8_CbCr8 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8" target="_top">vImageConvert_ARGB8888To420Yp8_CbCr8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 420Yp8_CbCr8 format.
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>444AYpCbCr8 ('r408' and 'y408')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888" target="_top">vImageConvert_444AYpCbCr8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 444AYpCbCr8 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8" target="_top">vImageConvert_ARGB8888To444AYpCbCr8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444AYpCbCr8 format
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>422CrYpCbYpCbYpCbYpCrYpCrYp10 ('v210')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12" logicalPath="//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12" target="_top">vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12</a></tt></dt>
<dd>
<p>Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB16Q12
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888" target="_top">vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10" logicalPath="//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10" target="_top">vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10</a></tt></dt>
<dd>
<p>Convert ARGB16Q12 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format.
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10" target="_top">vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format.
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>RGB888</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImagePermuteChannels_RGB888" logicalPath="//apple_ref/c/func/vImagePermuteChannels_RGB888" target="_top">vImagePermuteChannels_RGB888</a></tt></dt>
<dd>
<p>Reorder 3 color channels within the buffer according to the permute map.
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>422CbYpCrYp16(bitdepth) ('v216')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U" logicalPath="//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U" target="_top">vImageConvert_422CbYpCrYp16ToARGB16U</a></tt></dt>
<dd>
<p>Convert YUV 422CbYpCrYp16 format to ARGB16U
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888" target="_top">vImageConvert_422CbYpCrYp16ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 422CbYpCrYp16 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16" logicalPath="//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16" target="_top">vImageConvert_ARGB16UTo422CbYpCrYp16</a></tt></dt>
<dd>
<p>Convert ARGB16U to YUV 422CbYpCrYp16 format.
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16" target="_top">vImageConvert_ARGB8888To422CbYpCrYp16</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 422CbYpCrYp16 format.
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>422CbYpCrYp8 ('2vuy' and '2vuf')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888" target="_top">vImageConvert_422CbYpCrYp8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 422CbYpCrYp8 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8" target="_top">vImageConvert_ARGB8888To422CbYpCrYp8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 422CbYpCrYp8 format
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>Format agnostic</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageCopyBuffer" logicalPath="//apple_ref/c/func/vImageCopyBuffer" target="_top">vImageCopyBuffer</a></tt></dt>
<dd>
<p>Copy vImage buffer from src to dest.
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>444AYpCbCr16 ('y416')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U" logicalPath="//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U" target="_top">vImageConvert_444AYpCbCr16ToARGB16U</a></tt></dt>
<dd>
<p>Convert YUV 444AYpCbCr16 format to ARGB16U
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888" target="_top">vImageConvert_444AYpCbCr16ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 444AYpCbCr16 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16" logicalPath="//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16" target="_top">vImageConvert_ARGB16UTo444AYpCbCr16</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444AYpCbCr16 format
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16" target="_top">vImageConvert_ARGB8888To444AYpCbCr16</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444AYpCbCr16 format
</p>
</dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>444CbYpCrA8 ('v408')</h3>
<div class="group_desc_indent">
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888" logicalPath="//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888" target="_top">vImageConvert_444CbYpCrA8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 444CbYpCrA8 format to ARGB8888
</p>
</dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8" logicalPath="//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8" target="_top">vImageConvert_ARGB8888To444CbYpCrA8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444CbYpCrA8 format
</p>
</dd>
</dl>
</div>
<hr class="afterGroupHeading">
<a name="HeaderDoc_functions"></a>
<h2 class="h2tight">Functions</h2>
<dl>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888" target="_top">vImageConvert_420Yp8_Cb8_Cr8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 420Yp8_Cb8_Cr8 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888" target="_top">vImageConvert_420Yp8_CbCr8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 420Yp8_CbCr8 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U" target="_top">vImageConvert_422CbYpCrYp16ToARGB16U</a></tt></dt>
<dd>
<p>Convert YUV 422CbYpCrYp16 format to ARGB16U
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888" target="_top">vImageConvert_422CbYpCrYp16ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 422CbYpCrYp16 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888" target="_top">vImageConvert_422CbYpCrYp8_AA8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 422CbYpCrYp8_AA8 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888" target="_top">vImageConvert_422CbYpCrYp8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 422CbYpCrYp8 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12" target="_top">vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12</a></tt></dt>
<dd>
<p>Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB16Q12
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888" target="_top">vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888" target="_top">vImageConvert_422YpCbYpCr8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 422YpCbYpCr8 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U" target="_top">vImageConvert_444AYpCbCr16ToARGB16U</a></tt></dt>
<dd>
<p>Convert YUV 444AYpCbCr16 format to ARGB16U
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888" target="_top">vImageConvert_444AYpCbCr16ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 444AYpCbCr16 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888" target="_top">vImageConvert_444AYpCbCr8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 444AYpCbCr8 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888" target="_top">vImageConvert_444CbYpCrA8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 444CbYpCrA8 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12" target="_top">vImageConvert_444CrYpCb10ToARGB16Q12</a></tt></dt>
<dd>
<p>Convert YUV 444CrYpCb10 format to ARGB16Q12
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888" target="_top">vImageConvert_444CrYpCb10ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 444CrYpCb10 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888" target="_top">vImageConvert_444CrYpCb8ToARGB8888</a></tt></dt>
<dd>
<p>Convert YUV 444CrYpCb8 format to ARGB8888
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB1555toRGB565" target="_top">vImageConvert_ARGB1555toRGB565</a></tt></dt>
<dd><p>Convert from ARGB1555 to RGB565 image format
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10" target="_top">vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10</a></tt></dt>
<dd>
<p>Convert ARGB16Q12 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10" target="_top">vImageConvert_ARGB16Q12To444CrYpCb10</a></tt></dt>
<dd>
<p>Convert ARGB16Q12 to YUV 444CrYpCb10 format
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102" target="_top">vImageConvert_ARGB16Q12ToRGBA1010102</a></tt></dt>
<dd>
<p>Convert ARGB16Q12 to RGBA1010102 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16" target="_top">vImageConvert_ARGB16UTo422CbYpCrYp16</a></tt></dt>
<dd>
<p>Convert ARGB16U to YUV 422CbYpCrYp16 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16" target="_top">vImageConvert_ARGB16UTo444AYpCbCr16</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444AYpCbCr16 format
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102" target="_top">vImageConvert_ARGB16UToRGBA1010102</a></tt></dt>
<dd>
<p>Convert ARGB16U to RGBA1010102 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8" target="_top">vImageConvert_ARGB8888To420Yp8_Cb8_Cr8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 420Yp8_Cb8_Cr8 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8" target="_top">vImageConvert_ARGB8888To420Yp8_CbCr8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 420Yp8_CbCr8 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16" target="_top">vImageConvert_ARGB8888To422CbYpCrYp16</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 422CbYpCrYp16 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8" target="_top">vImageConvert_ARGB8888To422CbYpCrYp8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 422CbYpCrYp8 format
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8" target="_top">vImageConvert_ARGB8888To422CbYpCrYp8_AA8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 422CbYpCrYp8_AA8 format
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10" target="_top">vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8" target="_top">vImageConvert_ARGB8888To422YpCbYpCr8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 422YpCbYpCr8 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16" target="_top">vImageConvert_ARGB8888To444AYpCbCr16</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444AYpCbCr16 format
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8" target="_top">vImageConvert_ARGB8888To444AYpCbCr8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444AYpCbCr8 format
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8" target="_top">vImageConvert_ARGB8888To444CbYpCrA8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444CbYpCrA8 format
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10" target="_top">vImageConvert_ARGB8888To444CrYpCb10</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444CrYpCb10 format
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8" target="_top">vImageConvert_ARGB8888To444CrYpCb8</a></tt></dt>
<dd>
<p>Convert ARGB8888 to YUV 444CrYpCb8 format
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102" target="_top">vImageConvert_ARGB8888ToRGBA1010102</a></tt></dt>
<dd>
<p>Convert ARGB8888 to RGBA1010102 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered" target="_top">vImageConvert_ARGBFFFFtoARGB8888_dithered</a></tt></dt>
<dd>
<p>Convert an array of floating point data to 8 bit integer data with dithering.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion" target="_top">vImageConvert_ARGBToYpCbCr_GenerateConversion</a></tt></dt>
<dd>
<p>Generates the conversion from a ARGB to a YpCbCr pixel format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered" target="_top">vImageConvert_PlanarFtoPlanar8_dithered</a></tt></dt>
<dd>
<p>Convert an array of floating point data to 8 bit integer data with dithering. 
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_RGB565toARGB1555" target="_top">vImageConvert_RGB565toARGB1555</a></tt></dt>
<dd><p>Convert from RGB565 to ARGB1555 image format
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_RGB565toRGBA5551" target="_top">vImageConvert_RGB565toRGBA5551</a></tt></dt>
<dd><p>Convert from RGB565 to RGBA5551 image format
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12" target="_top">vImageConvert_RGBA1010102ToARGB16Q12</a></tt></dt>
<dd>
<p>Convert RGBA1010102 to ARGB16Q12 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U" target="_top">vImageConvert_RGBA1010102ToARGB16U</a></tt></dt>
<dd>
<p>Convert RGBA1010102 to ARGB16U format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888" target="_top">vImageConvert_RGBA1010102ToARGB8888</a></tt></dt>
<dd>
<p>Convert RGBA1010102 to ARGB8888 format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_RGBA5551toRGB565" target="_top">vImageConvert_RGBA5551toRGB565</a></tt></dt>
<dd><p>Convert from RGBA5551 to RGB565 image format
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered" target="_top">vImageConvert_RGBFFFtoRGB888_dithered</a></tt></dt>
<dd>
<p>Convert an array of floating point data to 8 bit integer data with dithering.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion" target="_top">vImageConvert_YpCbCrToARGB_GenerateConversion</a></tt></dt>
<dd>
<p>Generates the conversion from a YpCbCr to a ARGB pixel format.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageCopyBuffer" target="_top">vImageCopyBuffer</a></tt></dt>
<dd>
<p>Copy vImage buffer from src to dest.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageExtractChannel_ARGB16U" target="_top">vImageExtractChannel_ARGB16U</a></tt></dt>
<dd>
<p>Extract one channel from a 4-channel interleaved 16-bit per component buffer. 
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageExtractChannel_ARGB8888" target="_top">vImageExtractChannel_ARGB8888</a></tt></dt>
<dd>
<p>Extract one channel from a 4-channel interleaved 8-bit per component buffer
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageExtractChannel_ARGBFFFF" target="_top">vImageExtractChannel_ARGBFFFF</a></tt></dt>
<dd>
<p>Extract one channel from a 4-channel interleaved 32-bit per component buffer
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImagePermuteChannels_RGB888" target="_top">vImagePermuteChannels_RGB888</a></tt></dt>
<dd>
<p>Reorder 3 color channels within the buffer according to the permute map.
</p>
</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888;   name=vImageConvert_420Yp8_Cb8_Cr8ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888"></a>
<h3><a name="vImageConvert_420Yp8_Cb8_Cr8ToARGB8888">vImageConvert_420Yp8_Cb8_Cr8ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 420Yp8_Cb8_Cr8 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888 //apple_ref/c/clm/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888 //apple_ref/c/intfcm/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888 //apple_ref/c/intfm/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888 //apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888" target="_top"><span class="function">vImageConvert_420Yp8_Cb8_Cr8ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">srcYp</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">srcCb</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">srcCr</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 420Yp8_Cb8_Cr8 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>kvImageNoError                  Is returned when there was no error.
kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
</p>
<p>Note: Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888;name=start --><p>Convert YUV 420Yp8_Cb8_Cr8 format to ARGB8888
</p>

<p>Ypt0 Ypt1  =&gt;  At0 Rt0 Gt0 Bt0  At1 Rt1 Gt1 Bt1
</p>
<p>Ypb0 Ypb1      Ab0 Rb0 Gb0 Bb0  Ab1 Rb1 Gb1 Bb1
</p>
<p>Cb0
</p>
<p>Cr0
</p>

<p>YUV 420Yp8_Cb8_Cr8 can be used for 'y420' and 'f420' that are defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert 'y420' with ITU 601 video range to ARGB8888, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
  </p>
<pre>
  
     
     uint8_t *srcYtPixel = srcY.data;
     uint8_t *srcYbPixel = srcY.data + srcY.rowBytes;
     Ypt0 = srcYtPixel[0];
     Ypt1 = srcYtPixel[1];
     srcYtPixel += 2;
     Ypb0 = srcYbPixel[0];
     Ypb1 = srcYbPixel[1];
     srcYbPixel += 2;
 
     uint8_t *srcCbPixel = srcCb.data;
     uint8_t *srcCrPixel = srcCr.data;
     Cb0 = srcCbPixel[0];
     srcCbPixel += 1;
     Cr0 = srcCrPixel[0];
     srcCrPixel += 1;
     
     At0 = alpha
     Rt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 + Yp_bias) * Yp                               + (Cr0 + CbCr_bias) * Cr_R), 255 )
     Gt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_G + (Cr0 + CbCr_bias) * Cr_G), 255 )
     Bt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_B                              ), 255 )
     At1 = alpha
     Rt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 + Yp_bias) * Yp                               + (Cr0 + CbCr_bias) * Cr_R), 255 )
     Gt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_G + (Cr0 + CbCr_bias) * Cr_G), 255 )
     Bt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_B                              ), 255 )
     Ab0 = alpha
     Rb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 + Yp_bias) * Yp                               + (Cr0 + CbCr_bias) * Cr_R), 255 )
     Gb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_G + (Cr0 + CbCr_bias) * Cr_G), 255 )
     Bb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_B                              ), 255 )
     Ab1 = alpha
     Rb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 + Yp_bias) * Yp                               + (Cr0 + CbCr_bias) * Cr_R), 255 )
     Gb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_G + (Cr0 + CbCr_bias) * Cr_G), 255 )
     Bb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_B                              ), 255 )
 
     uint8_t ARGB[16];
     ARGB[0]  = At0;
     ARGB[1]  = Rt0;
     ARGB[2]  = Gt0;
     ARGB[3]  = Bt0;
     ARGB[4]  = At1;
     ARGB[5]  = Rt1;
     ARGB[6]  = Gt1;
     ARGB[7]  = Bt1;
     ARGB[8]  = Ab0;
     ARGB[9]  = Rb0;
     ARGB[10] = Gb0;
     ARGB[11] = Bb0;
     ARGB[12] = Ab1;
     ARGB[13] = Rb1;
     ARGB[14] = Gb1;
     ARGB[15] = Bb1;
 
     uint8_t *destTPixel = dest.data;
     destTPixel[0]  = ARGB[permuteMap[0]];
     destTPixel[1]  = ARGB[permuteMap[1]];
     destTPixel[2]  = ARGB[permuteMap[2]];
     destTPixel[3]  = ARGB[permuteMap[3]];
     destTPixel[4]  = ARGB[permuteMap[0]+4];
     destTPixel[5]  = ARGB[permuteMap[1]+4];
     destTPixel[6]  = ARGB[permuteMap[2]+4];
     destTPixel[7]  = ARGB[permuteMap[3]+4];
     destTPixel += 8;
     uint8_t *destBPixel = dest.data + dest.rowBytes;
     destBPixel[0]  = ARGB[permuteMap[0]+8];
     destBPixel[1]  = ARGB[permuteMap[1]+8];
     destBPixel[2]  = ARGB[permuteMap[2]+8];
     destBPixel[3]  = ARGB[permuteMap[3]+8];
     destBPixel[4]  = ARGB[permuteMap[0]+12];
     destBPixel[5]  = ARGB[permuteMap[1]+12];
     destBPixel[6]  = ARGB[permuteMap[2]+12];
     destBPixel[7]  = ARGB[permuteMap[3]+12];
     destBPixel += 8;
 
   
   </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_420Yp8_Cb8_Cr8ToARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888;   name=vImageConvert_420Yp8_CbCr8ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888"></a>
<h3><a name="vImageConvert_420Yp8_CbCr8ToARGB8888">vImageConvert_420Yp8_CbCr8ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 420Yp8_CbCr8 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_420Yp8_CbCr8ToARGB8888 //apple_ref/c/clm/vImageConvert_420Yp8_CbCr8ToARGB8888 //apple_ref/c/intfcm/vImageConvert_420Yp8_CbCr8ToARGB8888 //apple_ref/c/intfm/vImageConvert_420Yp8_CbCr8ToARGB8888 //apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888" target="_top"><span class="function">vImageConvert_420Yp8_CbCr8ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">srcYp</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">srcCbCr</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 420Yp8_CbCr8 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_420Yp8_CbCr8ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     </pre> 

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888;name=start --><p>Convert YUV 420Yp8_CbCr8 format to ARGB8888
</p>

<p>Ypt0 Ypt1  =&gt;  At0 Rt0 Gt0 Bt0  At1 Rt1 Gt1 Bt1
</p>
<p>Ypb0 Ypb1      Ab0 Rb0 Gb0 Bb0  Ab1 Rb1 Gb1 Bb1
</p>
<p>Cb0 Cr0
</p>

<p>YUV 420Yp8_CbCr8 can be used for '420v' and '420f' that are defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert '420v' with ITU 601 video range to ARGB8888, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
  </p>
<pre>
  
 
     uint8_t *srcYtPixel = srcY.data;
     uint8_t *srcYbPixel = srcY.data + srcY.rowBytes;
     Ypt0 = srcYtPixel[0];
     Ypt1 = srcYtPixel[1];
     srcYtPixel += 2;
     Ypb0 = srcYbPixel[0];
     Ypb1 = srcYbPixel[1];
     srcYbPixel += 2;
     
     uint8_t *srcCbCrPixel = srcCbCr.data;
     Cb0 = srcCbCrPixel[0];
     Cr0 = srcCbCrPixel[1];
     srcCrPixel += 2;
     
     At0 = alpha
     Rt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     Gt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     Bt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     At1 = alpha
     Rt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     Gt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     Bt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     Ab0 = alpha
     Rb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     Gb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     Bb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     Ab1 = alpha
     Rb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     Gb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     Bb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     
     uint8_t ARGB[16];
     ARGB[0]  = At0;
     ARGB[1]  = Rt0;
     ARGB[2]  = Gt0;
     ARGB[3]  = Bt0;
     ARGB[4]  = At1;
     ARGB[5]  = Rt1;
     ARGB[6]  = Gt1;
     ARGB[7]  = Bt1;
     ARGB[8]  = Ab0;
     ARGB[9]  = Rb0;
     ARGB[10] = Gb0;
     ARGB[11] = Bb0;
     ARGB[12] = Ab1;
     ARGB[13] = Rb1;
     ARGB[14] = Gb1;
     ARGB[15] = Bb1;
     
     uint8_t *destTPixel = dest.data;
     destTPixel[0]  = ARGB[permuteMap[0]];
     destTPixel[1]  = ARGB[permuteMap[1]];
     destTPixel[2]  = ARGB[permuteMap[2]];
     destTPixel[3]  = ARGB[permuteMap[3]];
     destTPixel[4]  = ARGB[permuteMap[0]+4];
     destTPixel[5]  = ARGB[permuteMap[1]+4];
     destTPixel[6]  = ARGB[permuteMap[2]+4];
     destTPixel[7]  = ARGB[permuteMap[3]+4];
     destTPixel += 8;
     uint8_t *destBPixel = dest.data + dest.rowBytes;
     destBPixel[0]  = ARGB[permuteMap[0]+8];
     destBPixel[1]  = ARGB[permuteMap[1]+8];
     destBPixel[2]  = ARGB[permuteMap[2]+8];
     destBPixel[3]  = ARGB[permuteMap[3]+8];
     destBPixel[4]  = ARGB[permuteMap[0]+12];
     destBPixel[5]  = ARGB[permuteMap[1]+12];
     destBPixel[6]  = ARGB[permuteMap[2]+12];
     destBPixel[7]  = ARGB[permuteMap[3]+12];
     destBPixel += 8;
     
   
   </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_420Yp8_CbCr8ToARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U;   name=vImageConvert_422CbYpCrYp16ToARGB16U --><a name="//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U"></a>
<h3><a name="vImageConvert_422CbYpCrYp16ToARGB16U">vImageConvert_422CbYpCrYp16ToARGB16U</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U;name=start --><!-- begin abstract --></p>
<p>Convert YUV 422CbYpCrYp16 format to ARGB16U
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U" logicalPath="//apple_ref/c/instm/vImageConvert_422CbYpCrYp16ToARGB16U //apple_ref/c/clm/vImageConvert_422CbYpCrYp16ToARGB16U //apple_ref/c/intfcm/vImageConvert_422CbYpCrYp16ToARGB16U //apple_ref/c/intfm/vImageConvert_422CbYpCrYp16ToARGB16U //apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U" target="_top"><span class="function">vImageConvert_422CbYpCrYp16ToARGB16U</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint16_t //apple_ref/c/tdef/uint16_t //apple_ref/c/tag/uint16_t //apple_ref/c/struct/uint16_t //apple_ref/c/intf/uint16_t //apple_ref/doc/anysymbol/uint16_t" machineGenerated="true" --><span class="type">uint16_t</span><!-- /a --> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CbYpCrYp16 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
permuteMap[4] = {3, 2, 1, 0} is BGRA16U.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A 16-bit value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB16U/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
  </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U;name=start --><p>Convert YUV 422CbYpCrYp16 format to ARGB16U
     </p>
<pre> 
     
                            pixel0-1
     byte0 byte1   byte2 byte3   byte4 byte5   byte6 byte7
     LE-16-bit-Cb  LE-16-bit-Y0  LE-16-bit-Cr  LE-16-bit-Y1  =&gt;  A0 R0 G0 B0  A1 R1 G1 B1
     
     (LE and left-justified 16-bit-per-component)
      </pre>

<p>YUV 422CbYpCrYp16 can be used for 16-bit 'v216' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB16U to 16-bit 'v216' with ITU 601 video range, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
 </p>
<pre> 
 
     uint64_t *srcPixel = src.data;
     uint64_t pixel = *srcPixel;
     Yp0 = getYp0From16bitv216(pixel);
     Cb0 = getCb0From16bitv216(pixel);
     Yp1 = getYp1From16bitv216(pixel);
     Cr0 = getCr0From16bitv216(pixel);
     srcPixel += 1;
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 65535 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 65535 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 65535 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 65535 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 65535 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 65535 )
     
     uint16_t ARGB[8];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel += 8;

  </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB16U;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888;   name=vImageConvert_422CbYpCrYp16ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888"></a>
<h3><a name="vImageConvert_422CbYpCrYp16ToARGB8888">vImageConvert_422CbYpCrYp16ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 422CbYpCrYp16 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_422CbYpCrYp16ToARGB8888 //apple_ref/c/clm/vImageConvert_422CbYpCrYp16ToARGB8888 //apple_ref/c/intfcm/vImageConvert_422CbYpCrYp16ToARGB8888 //apple_ref/c/intfm/vImageConvert_422CbYpCrYp16ToARGB8888 //apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888" target="_top"><span class="function">vImageConvert_422CbYpCrYp16ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CbYpCrYp16 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp16ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     <pre>
 
     Results are guaranteed to be faithfully rounded.
     This function can work in place.
 
 

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888;name=start --><p>Convert YUV 422CbYpCrYp16 format to ARGB8888
     </p>
<pre> 
     
                            pixel0-1
     byte0 byte1   byte2 byte3   byte4 byte5   byte6 byte7
     LE-16-bit-Cb  LE-16-bit-Y0  LE-16-bit-Cr  LE-16-bit-Y1  =&gt;  A0 R0 G0 B0  A1 R1 G1 B1
     
     (LE and left-justified 16-bit-per-component)
      </pre>

<p>YUV 422CbYpCrYp16 can be used for 16-bit 'v216' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 16-bit 'v216' with ITU 601 video range, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
     </p>
<pre> 
 
     uint64_t *srcPixel = src.data;
     uint64_t pixel = *srcPixel;
     Yp0 = getYp0From16bitv216(pixel);
     Cb0 = getCb0From16bitv216(pixel);
     Yp1 = getYp1From16bitv216(pixel);
     Cr0 = getCr0From16bitv216(pixel);
     srcPixel += 1;
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[8];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel += 8;
     </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp16ToARGB8888;name=end --><!-- end discussion -->
</pre></pre>
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888;   name=vImageConvert_422CbYpCrYp8_AA8ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888"></a>
<h3><a name="vImageConvert_422CbYpCrYp8_AA8ToARGB8888">vImageConvert_422CbYpCrYp8_AA8ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 422CbYpCrYp8_AA8 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_422CbYpCrYp8_AA8ToARGB8888 //apple_ref/c/clm/vImageConvert_422CbYpCrYp8_AA8ToARGB8888 //apple_ref/c/intfcm/vImageConvert_422CbYpCrYp8_AA8ToARGB8888 //apple_ref/c/intfm/vImageConvert_422CbYpCrYp8_AA8ToARGB8888 //apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888" target="_top"><span class="function">vImageConvert_422CbYpCrYp8_AA8ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">srcA</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CbYpCrYp8_AA8 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/srcA;   name=srcA -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/srcA"></a>
<code>srcA</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit alpha source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8_AA8ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
    
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
    
    </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888;name=start --><p>Convert YUV 422CbYpCrYp8_AA8 format to ARGB8888
</p>

<p>Cb0 Yp0 Cr0 Yp1  =&gt;  A0 R0 G0 B0  A1 R1 G1 B1
</p>
<p>A0 A1
</p>

<p>YUV 422CbYpCrYp8_AA8 can be used for 'a2vy' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert 'a2vy' with ITU 601 video range to ARGB8888, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
</p>
 <pre>
 
     uint8_t *srcPixel = src.data;
     Cb0 = srcPixel[0];
     Yp0 = srcPixel[1];
     Cr0 = srcPixel[2];
     Yp1 = srcPixel[3];
     srcPixel += 4;
 
     uint8_t *alpha = srcA.data;
     A0 = alpha[0];
     A1 = alpha[1];
     alpha += 2;
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[8];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel += 8;
 
 </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8_AA8ToARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888;   name=vImageConvert_422CbYpCrYp8ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888"></a>
<h3><a name="vImageConvert_422CbYpCrYp8ToARGB8888">vImageConvert_422CbYpCrYp8ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 422CbYpCrYp8 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_422CbYpCrYp8ToARGB8888 //apple_ref/c/clm/vImageConvert_422CbYpCrYp8ToARGB8888 //apple_ref/c/intfcm/vImageConvert_422CbYpCrYp8ToARGB8888 //apple_ref/c/intfm/vImageConvert_422CbYpCrYp8ToARGB8888 //apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888" target="_top"><span class="function">vImageConvert_422CbYpCrYp8ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CbYpCrYp8 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CbYpCrYp8ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
   
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
   
   </pre>

<p>Note: Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888;name=start --><p>Convert YUV 422CbYpCrYp8 format to ARGB8888
</p>

<p>Cb0 Yp0 Cr0 Yp1  =&gt;  A0 R0 G0 B0  A1 R1 G1 B1
</p>

<p>YUV 422CbYpCrYp8 can be used for '2vuy' and '2vuf' that are defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert '2vuy' with ITU 601 video range to ARGB8888, then we need 
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
</p>
     <pre>
     
     uint8_t *srcPixel = src.data;
     Cb0 = srcPixel[0];
     Yp0 = srcPixel[1];
     Cr0 = srcPixel[2];
     Yp1 = srcPixel[3];
     srcPixel += 4;
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                            ), 255 )
     
     uint8_t ARGB[8];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel += 8;
 
 </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CbYpCrYp8ToARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12;   name=vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12 --><a name="//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12"></a>
<h3><a name="vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12">vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12;name=start --><!-- begin abstract --></p>
<p>Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB16Q12
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12" logicalPath="//apple_ref/c/instm/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12 //apple_ref/c/clm/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12 //apple_ref/c/intfcm/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12 //apple_ref/c/intfm/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12 //apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12" target="_top"><span class="function">vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_16Q12" logicalPath="//apple_ref/c/cl/Pixel_16Q12 //apple_ref/c/tdef/Pixel_16Q12" target="_top"><span class="type">Pixel_16Q12</span></a> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16Q12 ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
    </pre>

<p>Note: Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12;name=start --><p>Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB16Q12
</p>

<p>6 packed YUV pixels are getting mapped into 6 ARGB16Q12 pixels.
</p>
<p>12 10-bit unsigned components are packed into 4 32-bit little-endian words.
     </p>
<pre> 
     Word0
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cr0           10-bit Y0            10-bit Cb0
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word1
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y2            10-bit Cb1           10-bit Y1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word2
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cb2           10-bit Y3            10-bit Cr1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word3
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y5            10-bit Cr2           10-bit Y4
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     
     =&gt;  A0 R0 G0 B0  A1 R1 G1 B1  A2 R2 G2 B2  A3 R3 G3 B3  A4 R4 G4 B4  A5 R5 G5 B5
      </pre>
<p>YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 can be used for 'v210' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB16Q12 to 'v210' with ITU 601 video range, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
    </p>
<pre> 
 
     uint32_t *srcPixel = src.data;
     pixel0 = srcPixel[0];
     pixel1 = srcPixel[1];
     pixel2 = srcPixel[2];
     pixel3 = srcPixel[3];
     srcPixel += 4;
     
     Yp0 = getYp0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp1 = getYp1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp2 = getYp2Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp3 = getYp3Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp4 = getYp4Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp5 = getYp5Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb0 = getCb0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb1 = getCb1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb2 = getCb2Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr0 = getCr0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr1 = getCr1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr2 = getCr2Fromv210(pixel0, pixel1, pixel2, pixel3);
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 4096 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 4096 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 4096 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 4096 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 4096 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 4096 )
     A2 = alpha
     R2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp                            + (Cr1 - CbCr_bias) * Cr_R), 4096 )
     G2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_G + (Cr1 - CbCr_bias) * Cr_G), 4096 )
     B2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_B                           ), 4096 )
     A3 = alpha
     R3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp                            + (Cr1 - CbCr_bias) * Cr_R), 4096 )
     G3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_G + (Cr1 - CbCr_bias) * Cr_G), 4096 )
     B3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_B                           ), 4096 )
     A4 = alpha
     R4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp                            + (Cr2 - CbCr_bias) * Cr_R), 4096 )
     G4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_G + (Cr2 - CbCr_bias) * Cr_G), 4096 )
     B4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_B                           ), 4096 )
     A5 = alpha
     R5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp                            + (Cr2 - CbCr_bias) * Cr_R), 4096 )
     G5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_G + (Cr2 - CbCr_bias) * Cr_G), 4096 )
     B5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_B                           ), 4096 )
     
     uint16_t ARGB[24];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     ARGB[8] = A2;
     ARGB[9] = R2;
     ARGB[10] = G2;
     ARGB[11] = B2;
     ARGB[12] = A3;
     ARGB[13] = R3;
     ARGB[14] = G3;
     ARGB[15] = B3;
     ARGB[16] = A4;
     ARGB[17] = R4;
     ARGB[18] = G4;
     ARGB[19] = B4;
     ARGB[20] = A5;
     ARGB[21] = R5;
     ARGB[22] = G5;
     ARGB[23] = B5;
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel[8] = ARGB[permuteMap[0]+8];
     destPixel[9] = ARGB[permuteMap[1]+8];
     destPixel[10] = ARGB[permuteMap[2]+8];
     destPixel[11] = ARGB[permuteMap[3]+8];
     destPixel[12] = ARGB[permuteMap[0]+12];
     destPixel[13] = ARGB[permuteMap[1]+12];
     destPixel[14] = ARGB[permuteMap[2]+12];
     destPixel[15] = ARGB[permuteMap[3]+12];
     destPixel[16] = ARGB[permuteMap[0]+16];
     destPixel[17] = ARGB[permuteMap[1]+16];
     destPixel[18] = ARGB[permuteMap[2]+16];
     destPixel[19] = ARGB[permuteMap[3]+16];
     destPixel[20] = ARGB[permuteMap[0]+20];
     destPixel[21] = ARGB[permuteMap[1]+20];
     destPixel[22] = ARGB[permuteMap[2]+20];
     destPixel[23] = ARGB[permuteMap[3]+20];
     destPixel += 24;
      </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888;   name=vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888"></a>
<h3><a name="vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888">vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888 //apple_ref/c/clm/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888 //apple_ref/c/intfcm/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888 //apple_ref/c/intfm/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888 //apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888" target="_top"><span class="function">vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888;name=start --><p>Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB8888
</p>

<p>6 packed YUV pixels are getting mapped into 6 ARGB8888 pixels.
</p>
<p>12 10-bit unsigned components are packed into 4 32-bit little-endian words.
 </p>
<pre> 

                         Word0
         Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
         10-bit Cr0           10-bit Y0            10-bit Cb0
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0

                         Word1
         Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
         10-bit Y2            10-bit Cb1           10-bit Y1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0

                         Word2
         Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
         10-bit Cb2           10-bit Y3            10-bit Cr1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0

                         Word3
         Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
         10-bit Y5            10-bit Cr2           10-bit Y4
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
 
     
     =&gt;  A0 R0 G0 B0  A1 R1 G1 B1  A2 R2 G2 B2  A3 R3 G3 B3  A4 R4 G4 B4  A5 R5 G5 B5
    </pre>
<p>YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 can be used for 'v210' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 'v210' with ITU 601 video range, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
     </p>
<pre> 
     uint32_t *srcPixel = src.data;
     pixel0 = srcPixel[0];
     pixel1 = srcPixel[1];
     pixel2 = srcPixel[2];
     pixel3 = srcPixel[3];
     srcPixel += 4;
 
     Yp0 = getYp0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp1 = getYp1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp2 = getYp2Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp3 = getYp3Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp4 = getYp4Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp5 = getYp5Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb0 = getCb0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb1 = getCb1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb2 = getCb2Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr0 = getCr0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr1 = getCr1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr2 = getCr2Fromv210(pixel0, pixel1, pixel2, pixel3);
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     A2 = alpha
     R2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp                            + (Cr1 - CbCr_bias) * Cr_R), 255 )
     G2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_G + (Cr1 - CbCr_bias) * Cr_G), 255 )
     B2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_B                           ), 255 )
     A3 = alpha
     R3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp                            + (Cr1 - CbCr_bias) * Cr_R), 255 )
     G3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_G + (Cr1 - CbCr_bias) * Cr_G), 255 )
     B3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_B                           ), 255 )
     A4 = alpha
     R4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp                            + (Cr2 - CbCr_bias) * Cr_R), 255 )
     G4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_G + (Cr2 - CbCr_bias) * Cr_G), 255 )
     B4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_B                           ), 255 )
     A5 = alpha
     R5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp                            + (Cr2 - CbCr_bias) * Cr_R), 255 )
     G5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_G + (Cr2 - CbCr_bias) * Cr_G), 255 )
     B5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_B                           ), 255 )
 
     uint8_t ARGB[24];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     ARGB[8] = A2;
     ARGB[9] = R2;
     ARGB[10] = G2;
     ARGB[11] = B2;
     ARGB[12] = A3;
     ARGB[13] = R3;
     ARGB[14] = G3;
     ARGB[15] = B3;
     ARGB[16] = A4;
     ARGB[17] = R4;
     ARGB[18] = G4;
     ARGB[19] = B4;
     ARGB[20] = A5;
     ARGB[21] = R5;
     ARGB[22] = G5;
     ARGB[23] = B5;
 
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel[8] = ARGB[permuteMap[0]+8];
     destPixel[9] = ARGB[permuteMap[1]+8];
     destPixel[10] = ARGB[permuteMap[2]+8];
     destPixel[11] = ARGB[permuteMap[3]+8];
     destPixel[12] = ARGB[permuteMap[0]+12];
     destPixel[13] = ARGB[permuteMap[1]+12];
     destPixel[14] = ARGB[permuteMap[2]+12];
     destPixel[15] = ARGB[permuteMap[3]+12];
     destPixel[16] = ARGB[permuteMap[0]+16];
     destPixel[17] = ARGB[permuteMap[1]+16];
     destPixel[18] = ARGB[permuteMap[2]+16];
     destPixel[19] = ARGB[permuteMap[3]+16];
     destPixel[20] = ARGB[permuteMap[0]+20];
     destPixel[21] = ARGB[permuteMap[1]+20];
     destPixel[22] = ARGB[permuteMap[2]+20];
     destPixel[23] = ARGB[permuteMap[3]+20];
     destPixel += 24;
     </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888;   name=vImageConvert_422YpCbYpCr8ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888"></a>
<h3><a name="vImageConvert_422YpCbYpCr8ToARGB8888">vImageConvert_422YpCbYpCr8ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 422YpCbYpCr8 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_422YpCbYpCr8ToARGB8888 //apple_ref/c/clm/vImageConvert_422YpCbYpCr8ToARGB8888 //apple_ref/c/intfcm/vImageConvert_422YpCbYpCr8ToARGB8888 //apple_ref/c/intfm/vImageConvert_422YpCbYpCr8ToARGB8888 //apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888" target="_top"><span class="function">vImageConvert_422YpCbYpCr8ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422YpCbYpCr8 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_422YpCbYpCr8ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888;name=start --><p>Convert YUV 422YpCbYpCr8 format to ARGB8888
</p>

<p>Yp0 Cb0 Yp1 Cr0  =&gt;  A0 R0 G0 B0  A1 R1 G1 B1
</p>

<p>YUV 422YpCbYpCr8 can be used for 'yuvs' and 'yuvf' that are defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 'yuvs' with ITU 601 video range, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion().
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
</p>
     <pre>
     
     uint8_t *srcPixel = src.data;
     Yp0 = srcPixel[0];
     Cb0 = srcPixel[1];
     Yp1 = srcPixel[2];
     Cr0 = srcPixel[3];
     srcPixel += 4;
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     
     uint8_t ARGB[8];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel += 8;
     
     </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_422YpCbYpCr8ToARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U;   name=vImageConvert_444AYpCbCr16ToARGB16U --><a name="//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U"></a>
<h3><a name="vImageConvert_444AYpCbCr16ToARGB16U">vImageConvert_444AYpCbCr16ToARGB16U</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U;name=start --><!-- begin abstract --></p>
<p>Convert YUV 444AYpCbCr16 format to ARGB16U
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U" logicalPath="//apple_ref/c/instm/vImageConvert_444AYpCbCr16ToARGB16U //apple_ref/c/clm/vImageConvert_444AYpCbCr16ToARGB16U //apple_ref/c/intfcm/vImageConvert_444AYpCbCr16ToARGB16U //apple_ref/c/intfm/vImageConvert_444AYpCbCr16ToARGB16U //apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U" target="_top"><span class="function">vImageConvert_444AYpCbCr16ToARGB16U</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB16U/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB16U/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444AYpCbCr16 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB16U/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB16U/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB16U/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB16U/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB16U/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB16U/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
permuteMap[4] = {3, 2, 1, 0} is BGRA16U.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB16U/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB16U/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     </pre>

<p>Results are guaranteed to be faithfully rounded.
This function can work in place.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U;name=start --><p>Convert YUV 444AYpCbCr16 format to ARGB16U
</p>

<p>A0 Yp0 Cb0 Cr0  =&gt;  A0 R0 G0 B0
</p>

<p>YUV 444AYpCbCr8 can be used for 'y416' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert 'y416' with ITU 601 video range to ARGB16U, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
  </p>
<pre> 
     uint16_t *srcPixel = src.data;
     A0  = srcPixel[0];
     Yp0 = srcPixel[1];
     Cb0 = srcPixel[2];
     Cr0 = srcPixel[3];
     srcPixel += 4;
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 65535 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 65535 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 65535 )
     
     uint16_t ARGB[4];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
   </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB16U;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888;   name=vImageConvert_444AYpCbCr16ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888"></a>
<h3><a name="vImageConvert_444AYpCbCr16ToARGB8888">vImageConvert_444AYpCbCr16ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 444AYpCbCr16 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_444AYpCbCr16ToARGB8888 //apple_ref/c/clm/vImageConvert_444AYpCbCr16ToARGB8888 //apple_ref/c/intfcm/vImageConvert_444AYpCbCr16ToARGB8888 //apple_ref/c/intfm/vImageConvert_444AYpCbCr16ToARGB8888 //apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888" target="_top"><span class="function">vImageConvert_444AYpCbCr16ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444AYpCbCr16 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr16ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
    </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888;name=start --><p>Convert YUV 444AYpCbCr16 format to ARGB8888
</p>

<p>A0 Yp0 Cb0 Cr0  =&gt;  A0 R0 G0 B0
</p>

<p>YUV 444AYpCbCr8 can be used for 'y416' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert 'y416' with ITU 601 video range to ARGB8888, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
 </p>
<pre> 
     uint16_t *srcPixel = src.data;
     A0  = srcPixel[0];
     Yp0 = srcPixel[1];
     Cb0 = srcPixel[2];
     Cr0 = srcPixel[3];
     srcPixel += 4;
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[4];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
  </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr16ToARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888;   name=vImageConvert_444AYpCbCr8ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888"></a>
<h3><a name="vImageConvert_444AYpCbCr8ToARGB8888">vImageConvert_444AYpCbCr8ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 444AYpCbCr8 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_444AYpCbCr8ToARGB8888 //apple_ref/c/clm/vImageConvert_444AYpCbCr8ToARGB8888 //apple_ref/c/intfcm/vImageConvert_444AYpCbCr8ToARGB8888 //apple_ref/c/intfm/vImageConvert_444AYpCbCr8ToARGB8888 //apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888" target="_top"><span class="function">vImageConvert_444AYpCbCr8ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr8ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr8ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444AYpCbCr8 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr8ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr8ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr8ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr8ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr8ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr8ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr8ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444AYpCbCr8ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
    
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
    
    </pre>
 
<p>     Results are guaranteed to be faithfully rounded.
     This function can work in place.
 
 

<!-- end return value --></p>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888;name=start --><p>Convert YUV 444AYpCbCr8 format to ARGB8888
</p>

<p>A0 Yp0 Cb0 Cr0  =&gt;  A0 R0 G0 B0
</p>

<p>YUV 444AYpCbCr8 can be used for 'r408' and 'y408' that are defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert 'y408' with ITU 601 video range to ARGB8888, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
</p>
    <pre>
    
 
     uint8_t *srcPixel = src.data;
     A0  = srcPixel[0];
     Yp0 = srcPixel[1];
     Cb0 = srcPixel[2];
     Cr0 = srcPixel[3];
     srcPixel += 4;
 
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
 
     uint8_t ARGB[4];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
 
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
     
    
    <pre>
 
    <!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444AYpCbCr8ToARGB8888;name=end --><!-- end discussion -->
</pre></pre>
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888;   name=vImageConvert_444CbYpCrA8ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888"></a>
<h3><a name="vImageConvert_444CbYpCrA8ToARGB8888">vImageConvert_444CbYpCrA8ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 444CbYpCrA8 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_444CbYpCrA8ToARGB8888 //apple_ref/c/clm/vImageConvert_444CbYpCrA8ToARGB8888 //apple_ref/c/intfcm/vImageConvert_444CbYpCrA8ToARGB8888 //apple_ref/c/intfm/vImageConvert_444CbYpCrA8ToARGB8888 //apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888" target="_top"><span class="function">vImageConvert_444CbYpCrA8ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CbYpCrA8ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CbYpCrA8ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444CbYpCrA8 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CbYpCrA8ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CbYpCrA8ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CbYpCrA8ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CbYpCrA8ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CbYpCrA8ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CbYpCrA8ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CbYpCrA8ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CbYpCrA8ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
   
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
   
   </pre>

<p>Results are guaranteed to be faithfully rounded.
This function can work in place.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888;name=start --><p>Convert YUV 444CbYpCrA8 format to ARGB8888
</p>

<p>Cb0 Yp0 Cr0 A0  =&gt;  A0 R0 G0 B0
</p>

<p>YUV 444CbYpCrA8 can be used for 'v408' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert 'v408' with ITU 601 video range to ARGB8888, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
</p>
   <pre> 
     uint8_t *srcPixel = src.data;
     Cb0 = srcPixel[0];
     Yp0 = srcPixel[1];
     Cr0 = srcPixel[2];
     A0  = srcPixel[3];
     srcPixel += 4;
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[4];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
       </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444CbYpCrA8ToARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12;   name=vImageConvert_444CrYpCb10ToARGB16Q12 --><a name="//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12"></a>
<h3><a name="vImageConvert_444CrYpCb10ToARGB16Q12">vImageConvert_444CrYpCb10ToARGB16Q12</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12;name=start --><!-- begin abstract --></p>
<p>Convert YUV 444CrYpCb10 format to ARGB16Q12
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12" logicalPath="//apple_ref/c/instm/vImageConvert_444CrYpCb10ToARGB16Q12 //apple_ref/c/clm/vImageConvert_444CrYpCb10ToARGB16Q12 //apple_ref/c/intfcm/vImageConvert_444CrYpCb10ToARGB16Q12 //apple_ref/c/intfm/vImageConvert_444CrYpCb10ToARGB16Q12 //apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12" target="_top"><span class="function">vImageConvert_444CrYpCb10ToARGB16Q12</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_16Q12" logicalPath="//apple_ref/c/cl/Pixel_16Q12 //apple_ref/c/tdef/Pixel_16Q12" target="_top"><span class="type">Pixel_16Q12</span></a> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444CrYpCb10 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16Q12 ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A 16Q12 value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB16Q12/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12;name=start --><p>Convert YUV 444CrYpCb10 format to ARGB16Q12
</p>

<p>3 10-bit unsigned components are packed into a 32-bit little-endian word.
Decreasing Address order (32-bit little-endian)
byte3           byte2            byte1            byte0
10-bit Cr            10-bit Yp            10-bit Cb                   =&gt;  A0 R0 G0 B0
9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  X X

YUV 444CrYpCb10 can be used for 'v410' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert 'v410' with ITU 601 video range to ARGB16Q12, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
     </p>
<pre> 
     uint32_t *srcPixel = src.data;
     uint32_t pixel = *srcPixel;
     srcPixel += 1;
     
     Yp0 = getYpFromv410(pixel);
     Cb0 = getCbFromv410(pixel);
     Cr0 = getCrFromv410(pixel);
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 4096 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 4096 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                            ), 4096 )
     
     uint16_t ARGB[4];
     ARGB[0] = alpha;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
     </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB16Q12;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888;   name=vImageConvert_444CrYpCb10ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888"></a>
<h3><a name="vImageConvert_444CrYpCb10ToARGB8888">vImageConvert_444CrYpCb10ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 444CrYpCb10 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_444CrYpCb10ToARGB8888 //apple_ref/c/clm/vImageConvert_444CrYpCb10ToARGB8888 //apple_ref/c/intfcm/vImageConvert_444CrYpCb10ToARGB8888 //apple_ref/c/intfm/vImageConvert_444CrYpCb10ToARGB8888 //apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888" target="_top"><span class="function">vImageConvert_444CrYpCb10ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444CrYpCb10 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb10ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
    </pre>


<p>Results are guaranteed to be faithfully rounded.
This function can work in place.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888;name=start --><p>Convert YUV 444CrYpCb10 format to ARGB8888
</p>

<p>3 10-bit unsigned components are packed into a 32-bit little-endian word.
 </p>
<pre> 
           Decreasing Address order (32-bit little-endian)
      byte3           byte2            byte1            byte0
      10-bit Cr            10-bit Yp            10-bit Cb                   =&gt;  A0 R0 G0 B0
      9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  X X
  </pre>


<p>YUV 444CrYpCb10 can be used for 'v410' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert 'v410' with ITU 601 video range to ARGB8888, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
    </p>
<pre> 
     uint32_t *srcPixel = src.data;
     uint32_t pixel = *srcPixel;
     srcPixel += 1;
 
     Yp0 = getYpFromv410(pixel);
     Cb0 = getCbFromv410(pixel);
     Cr0 = getCrFromv410(pixel);
 
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[4];
     ARGB[0] = alpha;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
    </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444CrYpCb10ToARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888;   name=vImageConvert_444CrYpCb8ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888"></a>
<h3><a name="vImageConvert_444CrYpCb8ToARGB8888">vImageConvert_444CrYpCb8ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert YUV 444CrYpCb8 format to ARGB8888
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_444CrYpCb8ToARGB8888 //apple_ref/c/clm/vImageConvert_444CrYpCb8ToARGB8888 //apple_ref/c/intfcm/vImageConvert_444CrYpCb8ToARGB8888 //apple_ref/c/intfm/vImageConvert_444CrYpCb8ToARGB8888 //apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888" target="_top"><span class="function">vImageConvert_444CrYpCb8ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <span class="param">alpha</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444CrYpCb8 source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/alpha;   name=alpha -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/alpha"></a>
<code>alpha</code>
</dt>
<dd><p>A value for alpha channel in dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_444CrYpCb8ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
    
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
    
   </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888;name=start --><p>Convert YUV 444CrYpCb8 format to ARGB8888
</p>

<p>Cr0 Yp0 Cb0  =&gt;  A0 R0 G0 B0
</p>

<p>YUV 444CrYpCb8 can be used for 'v308' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert 'v308' with ITU 601 video range to ARGB8888, then we need
generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
</p>

<p>The per-pixel operation is:
    </p>
<pre>
    
     
     uint8_t *srcPixel = src.data;
     Cr0 = srcPixel[0];
     Yp0 = srcPixel[1];
     Cb0 = srcPixel[2];
     srcPixel += 3;
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[4];
     ARGB[0] = alpha;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
   
   </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_444CrYpCb8ToARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB1555toRGB565;   name=vImageConvert_ARGB1555toRGB565 --><a name="//apple_ref/c/func/vImageConvert_ARGB1555toRGB565"></a>
<h3><a name="vImageConvert_ARGB1555toRGB565">vImageConvert_ARGB1555toRGB565</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB1555toRGB565;name=start --><!-- begin abstract --></p>
<p>Convert from ARGB1555 to RGB565 image format
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB1555toRGB565;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB1555toRGB565;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB1555toRGB565" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB1555toRGB565 //apple_ref/c/clm/vImageConvert_ARGB1555toRGB565 //apple_ref/c/intfcm/vImageConvert_ARGB1555toRGB565 //apple_ref/c/intfm/vImageConvert_ARGB1555toRGB565 //apple_ref/c/func/vImageConvert_ARGB1555toRGB565" target="_top"><span class="function">vImageConvert_ARGB1555toRGB565</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB1555toRGB565;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB1555toRGB565/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB1555toRGB565/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to a vImage_Buffer struct which describes a memory region full of ARGB1555 pixels</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB1555toRGB565/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB1555toRGB565/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by RGB565 pixels</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB1555toRGB565/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB1555toRGB565/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are understood by this function:
</p>
          <pre>
          
          kvImageNoFlags                      Default operation.

          kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
                                              many such operations going concurrently, and in cases where it is desirable to keep
                                              CPU utilization to a single core.

          kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
          
          </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
          
          kvImageNoError                          Success

          kvImageBufferSizeMismatch               dest-&gt;height &gt; src-&gt;height OR dest-&gt;width &gt; src-&gt;width.  There are not enough pixels to fill the destination buffer.
          
          </pre>



<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB1555toRGB565;name=start --><p>Convert (with loss of alpha) from ARGB1555 to RGB565 format.
If you need something fancier done with alpha first, such as unpremultiplication or flattening, convert to 8 bit per channel first.
Both RGB565 and ARGB1555 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB1555toRGB565;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10;   name=vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10 --><a name="//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10"></a>
<h3><a name="vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10">vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=start --><!-- begin abstract --></p>
<p>Convert ARGB16Q12 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10 //apple_ref/c/clm/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10 //apple_ref/c/intfcm/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10 //apple_ref/c/intfm/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10 //apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10" target="_top"><span class="function">vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16Q12 ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.
Any ordering of channels is supported as long as each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     </pre>

<p>Results are guaranteed to be faithfully rounded.
Chroma is sampled at center by default.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=start --><p>Convert ARGB16Q12 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format
</p>

<p>6 ARGB16Q12 pixels are getting mapped into 6 packed YUV pixels.
     </p>
<pre> 
 
     A0 R0 G0 B0  A1 R1 G1 B1  A2 R2 G2 B2  A3 R3 G3 B3  A4 R4 G4 B4  A5 R5 G5 B5  =&gt;
     
     12 10-bit unsigned components are packed into 4 32-bit little-endian words.
     
     Word0
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cr0           10-bit Y0            10-bit Cb0
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word1
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y2            10-bit Cb1           10-bit Y1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word2
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cb2           10-bit Y3            10-bit Cr1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word3
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y5            10-bit Cr2           10-bit Y4
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
      </pre>
<p>YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 can be used for 'v210' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB16Q12 to 'v210' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>
<p>The per-pixel operation is:
</p>
    <pre> 
 
     uint16_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A2 = srcPixel[permuteMap[0]];
     R2 = srcPixel[permuteMap[1]];
     G2 = srcPixel[permuteMap[2]];
     B2 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A3 = srcPixel[permuteMap[0]];
     R3 = srcPixel[permuteMap[1]];
     G3 = srcPixel[permuteMap[2]];
     B3 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A4 = srcPixel[permuteMap[0]];
     R4 = srcPixel[permuteMap[1]];
     G4 = srcPixel[permuteMap[2]];
     B4 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A5 = srcPixel[permuteMap[0]];
     R5 = srcPixel[permuteMap[1]];
     G5 = srcPixel[permuteMap[2]];
     B5 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     Yp2 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R2 * R_Yp      + G2 * G_Yp + B2 * B_Yp     )
     Yp3 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R3 * R_Yp      + G3 * G_Yp + B3 * B_Yp     )
     Cb1 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R2 * R_Cb      + G2 * G_Cb + B2 * B_Cb_R_Cr
                                                   +   R3 * R_Cb      + G3 * G_Cb + B3 * B_Cb_R_Cr) / 2 )
     Cr1 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R2 * B_Cb_R_Cr + G2 * G_Cr + B2 * B_Cr
                                                   +   R3 * B_Cb_R_Cr + G3 * G_Cr + B3 * B_Cr     ) / 2 )
     Yp4 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R4 * R_Yp      + G4 * G_Yp + B4 * B_Yp     )
     Yp5 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R5 * R_Yp      + G5 * G_Yp + B5 * B_Yp     )
     Cb2 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R4 * R_Cb      + G4 * G_Cb + B4 * B_Cb_R_Cr
                                                   +   R5 * R_Cb      + G5 * G_Cb + B5 * B_Cb_R_Cr) / 2 )
     Cr2 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R4 * B_Cb_R_Cr + G4 * G_Cr + B4 * B_Cr
                                                   +   R5 * B_Cb_R_Cr + G5 * G_Cr + B5 * B_Cr     ) / 2 )
     
     uint32_t *destPixel = dest.data;
     packv210AndStore(destPixel, Yp0, Yp1, Yp2, Yp3, Yp4, Yp5, Cb0, Cb1, Cb2, Cr0, Cr1, Cr2);
     destPixel += 4;
      </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10;   name=vImageConvert_ARGB16Q12To444CrYpCb10 --><a name="//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10"></a>
<h3><a name="vImageConvert_ARGB16Q12To444CrYpCb10">vImageConvert_ARGB16Q12To444CrYpCb10</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10;name=start --><!-- begin abstract --></p>
<p>Convert ARGB16Q12 to YUV 444CrYpCb10 format
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB16Q12To444CrYpCb10 //apple_ref/c/clm/vImageConvert_ARGB16Q12To444CrYpCb10 //apple_ref/c/intfcm/vImageConvert_ARGB16Q12To444CrYpCb10 //apple_ref/c/intfm/vImageConvert_ARGB16Q12To444CrYpCb10 //apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10" target="_top"><span class="function">vImageConvert_ARGB16Q12To444CrYpCb10</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To444CrYpCb10/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To444CrYpCb10/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16Q12 ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To444CrYpCb10/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To444CrYpCb10/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444CrYpCb10 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To444CrYpCb10/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To444CrYpCb10/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To444CrYpCb10/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To444CrYpCb10/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.
Any ordering of channels is supported as long as each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To444CrYpCb10/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12To444CrYpCb10/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10;name=start --><p>Convert ARGB16Q12 to YUV 444CrYpCb10 format
</p>

<p>3 10-bit unsigned components are packed into a 32-bit little-endian word.
     </p>
<pre> 
                           Decreasing Address order (32-bit little-endian)
                      byte3           byte2            byte1            byte0
     A0 R0 G0 B0  =&gt;  10-bit Cr            10-bit Yp            10-bit Cb
                      9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  X X
      </pre>


<p>YUV 444CrYpCb10 can be used for 'v410' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB16Q12 to 'v410' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>

<p>The per-pixel operation is:
     </p>
<pre> 
     uint16_t *srcPixel = src.data;
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
     
     pixel = makev410(Yp0, Cb0, Cr0);
     
     uint32_t *destPixel = dest.data;
     destPixel[0] = pixel;
     destPixel += 1;
      </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12To444CrYpCb10;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102;   name=vImageConvert_ARGB16Q12ToRGBA1010102 --><a name="//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102"></a>
<h3><a name="vImageConvert_ARGB16Q12ToRGBA1010102">vImageConvert_ARGB16Q12ToRGBA1010102</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102;name=start --><!-- begin abstract --></p>
<p>Convert ARGB16Q12 to RGBA1010102 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB16Q12ToRGBA1010102 //apple_ref/c/clm/vImageConvert_ARGB16Q12ToRGBA1010102 //apple_ref/c/intfcm/vImageConvert_ARGB16Q12ToRGBA1010102 //apple_ref/c/intfm/vImageConvert_ARGB16Q12ToRGBA1010102 //apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102" target="_top"><span class="function">vImageConvert_ARGB16Q12ToRGBA1010102</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMin</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMax</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010Min</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010Max</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16Q12 ARGB interleaved source pixels.   ARGB16Q12 pixels must be at least 2 byte aligned.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 10-bit RGB interleaved destination pixels.  RGBA1010102 pixels must be at least 4 byte aligned.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/RGB101010RangeMax;   name=RGB101010RangeMax -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/RGB101010RangeMax"></a>
<code>RGB101010RangeMax</code>
</dt>
<dd><p>A maximum value for the range of 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/RGB101010RangeMin;   name=RGB101010RangeMin -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/RGB101010RangeMin"></a>
<code>RGB101010RangeMin</code>
</dt>
<dd><p>A minimum value for the range of 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/RGB101010Max;   name=RGB101010Max -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/RGB101010Max"></a>
<code>RGB101010Max</code>
</dt>
<dd><p>A maximum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/RGB101010Min;   name=RGB101010Min -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/RGB101010Min"></a>
<code>RGB101010Min</code>
</dt>
<dd><p>A minimum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16Q12ToRGBA1010102/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     kvImageInvalidParameter         Is returned when RGB101010Min &gt; RGB101010Max || RGB101010RangeMin &gt; RGB101010RangeMax
  </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102;name=start --><p>Convert ARGB16Q12 to RGBA1010102 format.
</p>
<p>RGBA1010102 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
except that this format uses the least significant 2 bits for alpha channel.
</p>
<p>This format is 10-bit big endian 32-bit pixels.
</p>
<p>RGB101010RangeMax &amp; RGB101010RangeMin are available for non-full-range pixel values.
For full-range pixel values, the user can set these as
</p>
 <pre> 
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
  </pre>

<p>RGB101010Max &amp; RGB101010Min are available to specify the min / max of the representation.
This will be used as clipping the results.
</p>
 <pre> 
     RGB101010Max  = 1023;
     RGB101010Min  = 0;
  </pre>

<p>This is needed because 16Q12 has a chance to be outside of [0.0, 1.0] range and we are converting those
values into video-range. Then, there will be some numbers outside of 10-bit video-range and we want those 
values to be representable as much as possible.
</p>
<p>The per-pixel operation is:
 </p>
<pre> 
 
     int16_t *srcPixel = src.data;
     A16 = srcPixel[permuteMap[0]];
     R16 = srcPixel[permuteMap[1]];
     G16 = srcPixel[permuteMap[2]];
     B16 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     int32_t R10, G10, B10;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
     R10 = CLAMP(RGB101010Min, ((R16 * range10 + 2048) &gt;&gt; 12) + RGB101010RangeMin, RGB101010Max);
     G10 = CLAMP(RGB101010Min, ((G16 * range10 + 2048) &gt;&gt; 12) + RGB101010RangeMin, RGB101010Max);
     B10 = CLAMP(RGB101010Min, ((B16 * range10 + 2048) &gt;&gt; 12) + RGB101010RangeMin, RGB101010Max);
     A10 = CLAMP( 0, (A16 * 3 + 2048) &gt;&gt; 12), 3);
     
     uint32_t *destPixel = dest.data;
     destPixel[0] = htonl((R10 &lt;&lt; 22) | (G10 &lt;&lt; 12) | (B10 &lt;&lt; 2) | A10);
     destPixel += 1;
  </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16Q12ToRGBA1010102;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16;   name=vImageConvert_ARGB16UTo422CbYpCrYp16 --><a name="//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16"></a>
<h3><a name="vImageConvert_ARGB16UTo422CbYpCrYp16">vImageConvert_ARGB16UTo422CbYpCrYp16</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16;name=start --><!-- begin abstract --></p>
<p>Convert ARGB16U to YUV 422CbYpCrYp16 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB16UTo422CbYpCrYp16 //apple_ref/c/clm/vImageConvert_ARGB16UTo422CbYpCrYp16 //apple_ref/c/intfcm/vImageConvert_ARGB16UTo422CbYpCrYp16 //apple_ref/c/intfm/vImageConvert_ARGB16UTo422CbYpCrYp16 //apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16" target="_top"><span class="function">vImageConvert_ARGB16UTo422CbYpCrYp16</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo422CbYpCrYp16/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo422CbYpCrYp16/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo422CbYpCrYp16/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo422CbYpCrYp16/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CbYpCrYp16 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo422CbYpCrYp16/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo422CbYpCrYp16/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
This is generated by vImageConvert_ARGBToYpCbCr_GenerateConversion().</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo422CbYpCrYp16/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo422CbYpCrYp16/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of src.
permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
permuteMap[4] = {3, 2, 1, 0} is BGRA16U.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo422CbYpCrYp16/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo422CbYpCrYp16/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
    </pre>

<p>Results are guaranteed to be faithfully rounded.
Chroma is sampled at center by default.
</p>
<p>Note: vImage doesn't do anything with the alpha here. It is just thrown away. The operation is therefore best suited for kCGImageAlphaNoneSkip&lt;First/Last&gt;
images.  If it has alpha, you may wish to composite against an opaque background first, before the transparency information is lost.
If it is premultiplied by alpha, you at minimum should unpremultiply it first, or composite it against an opaque background. See
vImageUnpremultiplyData_ARGB16U() and vImageFlatten_ARGB16U().
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16;name=start --><p>Convert ARGB16U to YUV 422CbYpCrYp16 format
     </p>
<pre> 
     
                                                        pixel0-1
                                   byte0 byte1   byte2 byte3   byte4 byte5   byte6 byte7
     A0 R0 G0 B0  A1 R1 G1 B1  =&gt;  LE-16-bit-Cb  LE-16-bit-Y0  LE-16-bit-Cr  LE-16-bit-Y1
     
     (LE and left-justified 16-bit-per-component)
      </pre>

<p>YUV 422CbYpCrYp16 can be used for 16-bit 'v216' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB16U to 16-bit 'v216' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>
<p>The per-pixel operation is:
     </p>
<pre> 
 
     uint16_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = Yp_bias + ROUND_TO_NEAREST_INTEGER( R0 * R_Yp + G0 * G_Yp + B0 * B_Yp )
     Yp1 = Yp_bias + ROUND_TO_NEAREST_INTEGER( R1 * R_Yp + G1 * G_Yp + B1 * B_Yp )
     R0 += R1;  G0 += G1;   B0 += B1;
     Cb0 = CbCr_bias + ROUND_TO_NEAREST_INTEGER( ( R0 * R_Cb + G0 * G_Cb + B0 * B_Cb_R_Cr) / 2 )
     Cr0 = CbCr_bias + ROUND_TO_NEAREST_INTEGER( ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr) / 2 )
     
     uint64_t *destPixel = dest.data;
     pack16bitv216AndStore(destPixel, Yp0, Yp1, Cb0, Cr0);
     destPixel += 1;
        
     </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo422CbYpCrYp16;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16;   name=vImageConvert_ARGB16UTo444AYpCbCr16 --><a name="//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16"></a>
<h3><a name="vImageConvert_ARGB16UTo444AYpCbCr16">vImageConvert_ARGB16UTo444AYpCbCr16</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 444AYpCbCr16 format
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB16UTo444AYpCbCr16 //apple_ref/c/clm/vImageConvert_ARGB16UTo444AYpCbCr16 //apple_ref/c/intfcm/vImageConvert_ARGB16UTo444AYpCbCr16 //apple_ref/c/intfm/vImageConvert_ARGB16UTo444AYpCbCr16 //apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16" target="_top"><span class="function">vImageConvert_ARGB16UTo444AYpCbCr16</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo444AYpCbCr16/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo444AYpCbCr16/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo444AYpCbCr16/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo444AYpCbCr16/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444AYpCbCr16 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo444AYpCbCr16/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo444AYpCbCr16/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo444AYpCbCr16/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo444AYpCbCr16/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
permuteMap[4] = {3, 2, 1, 0} is BGRA16U.
Any ordering of channels is supported as long as each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo444AYpCbCr16/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UTo444AYpCbCr16/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     </pre>

<p>Results are guaranteed to be faithfully rounded.
This function can work in place.

<!-- end return value --></p>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16;name=start --><p>Convert ARGB16U to YUV 444AYpCbCr16 format
</p>

<p>A0 R0 G0 B0  =&gt;  A0 Yp0 Cb0 Cr0
</p>

<p>YUV 444AYpCbCr8 can be used for 'y416' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB16U to 'y416' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>

<p>The per-pixel operation is:
  </p>
<pre> 
     uint16_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = A0;
     destPixel[1] = Yp0;
     destPixel[2] = Cb0;
     destPixel[3] = Cr0;
     destPixel += 4;
   </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16UTo444AYpCbCr16;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102;   name=vImageConvert_ARGB16UToRGBA1010102 --><a name="//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102"></a>
<h3><a name="vImageConvert_ARGB16UToRGBA1010102">vImageConvert_ARGB16UToRGBA1010102</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102;name=start --><!-- begin abstract --></p>
<p>Convert ARGB16U to RGBA1010102 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB16UToRGBA1010102 //apple_ref/c/clm/vImageConvert_ARGB16UToRGBA1010102 //apple_ref/c/intfcm/vImageConvert_ARGB16UToRGBA1010102 //apple_ref/c/intfm/vImageConvert_ARGB16UToRGBA1010102 //apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102" target="_top"><span class="function">vImageConvert_ARGB16UToRGBA1010102</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMin</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMax</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 10-bit RGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/RGB101010RangeMax;   name=RGB101010RangeMax -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/RGB101010RangeMax"></a>
<code>RGB101010RangeMax</code>
</dt>
<dd><p>A maximum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/RGB101010RangeMin;   name=RGB101010RangeMin -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/RGB101010RangeMin"></a>
<code>RGB101010RangeMin</code>
</dt>
<dd><p>A minimum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
permuteMap[4] = {3, 2, 1, 0} is BGRA16U.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB16UToRGBA1010102/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     kvImageInvalidParameter         Is returned when RGB101010RangeMin is bigger than RGB101010RangeMax.
  </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102;name=start --><p>Convert ARGB16U to RGB101010 format.
</p>
<p>RGB101010 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
except that this format uses the least significant 2 bits for alpha channel.
</p>
<p>This format is 10-bit big endian 32-bit pixels. 
</p>
<p>RGB101010RangeMax &amp; RGB101010RangeMin are available for non-full-range pixel values.
For full-range pixel values, the user can set these as
</p>
<p>RGB101010RangeMax  = 1023;
RGB101010RangeMin  = 0;
</p>
<p>The per-pixel operation is:
</p>
<p>uint16_t *srcPixel = src.data;
A16 = srcPixel[permuteMap[0]];
R16 = srcPixel[permuteMap[1]];
G16 = srcPixel[permuteMap[2]];
B16 = srcPixel[permuteMap[3]];
srcPixel += 4;
</p>
<p>int32_t R10, G10, B10;
int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
R10 = ((R16 * range10 + (USHRT_MAX &gt;&gt; 1)) / USHRT_MAX) + RGB101010RangeMin;
G10 = ((G16 * range10 + (USHRT_MAX &gt;&gt; 1)) / USHRT_MAX) + RGB101010RangeMin;
B10 = ((B16 * range10 + (USHRT_MAX &gt;&gt; 1)) / USHRT_MAX) + RGB101010RangeMin;
A10 = ((A16 * 3 + (USHRT_MAX &gt;&gt; 1)) / USHRT_MAX);
</p>
<p>uint32_t *destPixel = dest.data;
destPixel[0] = htonl((R10 &lt;&lt; 22) | (G10 &lt;&lt; 12) | (B10 &lt;&lt; 2) | A10);
destPixel += 1;
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB16UToRGBA1010102;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8;   name=vImageConvert_ARGB8888To420Yp8_Cb8_Cr8 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8"></a>
<h3><a name="vImageConvert_ARGB8888To420Yp8_Cb8_Cr8">vImageConvert_ARGB8888To420Yp8_Cb8_Cr8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 420Yp8_Cb8_Cr8 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8 //apple_ref/c/clm/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8 //apple_ref/c/intfcm/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8 //apple_ref/c/intfm/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8 //apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8" target="_top"><span class="function">vImageConvert_ARGB8888To420Yp8_Cb8_Cr8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">destYp</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">destCb</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">destCr</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 420Yp8_Cb8_Cr8 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, provided that each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
    
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
    
    </pre>

<p>Results are guaranteed to be faithfully rounded.
Chroma is sampled at center by default.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8;name=start --><p>Convert ARGB8888 to YUV 420Yp8_Cb8_Cr8 format
</p>

 <pre> 
     At0 Rt0 Gt0 Bt0  At1 Rt1 Gt1 Bt1  =&gt;  Ypt0 Ypt1
 
     Ab0 Rb0 Gb0 Bb0  Ab1 Rb1 Gb1 Bb1      Ypb0 Ypb1
 
                                           Cb0
 
                                           Cr0
 
    </pre>

<p>YUV 420Yp8_Cb8_Cr8 can be used for 'y420' and 'f420' that are defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 'y420' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>
<p>The per-pixel operation is:
  </p>
<pre>
  
     uint8_t *srcTPixel = src.data;
     At0 = srcTPixel[permuteMap[0]];
     Rt0 = srcTPixel[permuteMap[1]];
     Gt0 = srcTPixel[permuteMap[2]];
     Bt0 = srcTPixel[permuteMap[3]];
     srcTPixel += 4;
     At1 = srcTPixel[permuteMap[0]];
     Rt1 = srcTPixel[permuteMap[1]];
     Gt1 = srcTPixel[permuteMap[2]];
     Bt1 = srcTPixel[permuteMap[3]];
     srcTPixel += 4;
     uint8_t *srcBPixel = src.data + src.rowBytes;
     Ab0 = srcBPixel[permuteMap[0]];
     Rb0 = srcBPixel[permuteMap[1]];
     Gb0 = srcBPixel[permuteMap[2]];
     Bb0 = srcBPixel[permuteMap[3]];
     srcBPixel += 4;
     Ab1 = srcBPixel[permuteMap[0]];
     Rb1 = srcBPixel[permuteMap[1]];
     Gb1 = srcBPixel[permuteMap[2]];
     Bb1 = srcBPixel[permuteMap[3]];
     srcBPixel += 4;
 
     Ypt0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rt0 * R_Yp      + Gt0 * G_Yp + Bt0 * B_Yp     )
     Ypt1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rt1 * R_Yp      + Gt1 * G_Yp + Bt1 * B_Yp     )
     Ypb0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rb0 * R_Yp      + Gb0 * G_Yp + Bb0 * B_Yp     )
     Ypb1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rb1 * R_Yp      + Gb1 * G_Yp + Bb1 * B_Yp     )
     Cb0  = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( Rt0 * R_Cb      + Gt0 * G_Cb + Bt0 * B_Cb_R_Cr
                                                    +   Rt1 * R_Cb      + Gt1 * G_Cb + Bt1 * B_Cb_R_Cr
                                                    +   Rb0 * R_Cb      + Gb0 * G_Cb + Bb0 * B_Cb_R_Cr
                                                    +   Rb1 * R_Cb      + Gb1 * G_Cb + Bb1 * B_Cb_R_Cr) / 4 )
     Cr0  = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( Rt0 * B_Cb_R_Cr + Gt0 * G_Cr + Bt0 * B_Cr
                                                    +   Rt1 * B_Cb_R_Cr + Gt1 * G_Cr + Bt1 * B_Cr
                                                    +   Rb0 * B_Cb_R_Cr + Gb0 * G_Cr + Bb0 * B_Cr
                                                    +   Rb1 * B_Cb_R_Cr + Gb1 * G_Cr + Bb1 * B_Cr     ) / 4 )
     
     uint8_t *destYptPixel = destYp.data;
     uint8_t *destYpbPixel = destYp.data + destYp.rowBytes;
     destYptPixel[0] = Ypt0;
     destYptPixel[1] = Ypt1;
     destYpbPixel[0] = Ypb0;
     destYpbPixel[1] = Ypb1;
     destYptPixel += 2;
     destYpbPixel += 2;
     
     uint8_t *destCbPixel = destCb.data;
     uint8_t *destCrPixel = destCr.data;
     destCbPixel[0] = Cb0;
     destCrPixel[0] = Cr0;
     destCbPixel += 1;
     destCrPixel += 1;
   
   </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_Cb8_Cr8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8;   name=vImageConvert_ARGB8888To420Yp8_CbCr8 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8"></a>
<h3><a name="vImageConvert_ARGB8888To420Yp8_CbCr8">vImageConvert_ARGB8888To420Yp8_CbCr8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 420Yp8_CbCr8 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To420Yp8_CbCr8 //apple_ref/c/clm/vImageConvert_ARGB8888To420Yp8_CbCr8 //apple_ref/c/intfcm/vImageConvert_ARGB8888To420Yp8_CbCr8 //apple_ref/c/intfm/vImageConvert_ARGB8888To420Yp8_CbCr8 //apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8" target="_top"><span class="function">vImageConvert_ARGB8888To420Yp8_CbCr8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">destYp</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">destCbCr</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_CbCr8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_CbCr8/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_CbCr8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_CbCr8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 420Yp8_CbCr8 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_CbCr8/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_CbCr8/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_CbCr8/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_CbCr8/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as the channels don't repeat. For example, the pirate colorspace {0,1,1,1} (ARRR) is not supported, because the red channel appears more than once. (Pirates see red.)</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_CbCr8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To420Yp8_CbCr8/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
    
   </pre>


<p>Results are guaranteed to be faithfully rounded.
Chroma is sampled at center by default.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8;name=start --><p>Convert ARGB8888 to YUV 420Yp8_CbCr8 format
</p>

 <pre> 
     At0 Rt0 Gt0 Bt0  At1 Rt1 Gt1 Bt1  =&gt;  Ypt0 Ypt1
     
     Ab0 Rb0 Gb0 Bb0  Ab1 Rb1 Gb1 Bb1      Ypb0 Ypb1
     
                                           Cb0 Cr0
  </pre>


<p>YUV 420Yp8_CbCr8 can be used for '420v' and '420f' that are defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to '420v' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>
<p>The per-pixel operation is:
  </p>
<pre> 
     uint8_t *srcTPixel = src.data;
     At0 = srcTPixel[permuteMap[0]];
     Rt0 = srcTPixel[permuteMap[1]];
     Gt0 = srcTPixel[permuteMap[2]];
     Bt0 = srcTPixel[permuteMap[3]];
     srcTPixel += 4;
     At1 = srcTPixel[permuteMap[0]];
     Rt1 = srcTPixel[permuteMap[1]];
     Gt1 = srcTPixel[permuteMap[2]];
     Bt1 = srcTPixel[permuteMap[3]];
     srcTPixel += 4;
     uint8_t *srcBPixel = src.data + src.rowBytes;
     Ab0 = srcBPixel[permuteMap[0]];
     Rb0 = srcBPixel[permuteMap[1]];
     Gb0 = srcBPixel[permuteMap[2]];
     Bb0 = srcBPixel[permuteMap[3]];
     srcBPixel += 4;
     Ab1 = srcBPixel[permuteMap[0]];
     Rb1 = srcBPixel[permuteMap[1]];
     Gb1 = srcBPixel[permuteMap[2]];
     Bb1 = srcBPixel[permuteMap[3]];
     srcBPixel += 4;
     
     Ypt0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rt0 * R_Yp      + Gt0 * G_Yp + Bt0 * B_Yp     )
     Ypt1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rt1 * R_Yp      + Gt1 * G_Yp + Bt1 * B_Yp     )
     Ypb0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rb0 * R_Yp      + Gb0 * G_Yp + Bb0 * B_Yp     )
     Ypb1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rb1 * R_Yp      + Gb1 * G_Yp + Bb1 * B_Yp     )
     Cb0  = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( Rt0 * R_Cb      + Gt0 * G_Cb + Bt0 * B_Cb_R_Cr
                                                    +   Rt1 * R_Cb      + Gt1 * G_Cb + Bt1 * B_Cb_R_Cr
                                                    +   Rb0 * R_Cb      + Gb0 * G_Cb + Bb0 * B_Cb_R_Cr
                                                    +   Rb1 * R_Cb      + Gb1 * G_Cb + Bb1 * B_Cb_R_Cr) / 4 )
     Cr0  = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( Rt0 * B_Cb_R_Cr + Gt0 * G_Cr + Bt0 * B_Cr
                                                    +   Rt1 * B_Cb_R_Cr + Gt1 * G_Cr + Bt1 * B_Cr
                                                    +   Rb0 * B_Cb_R_Cr + Gb0 * G_Cr + Bb0 * B_Cr
                                                    +   Rb1 * B_Cb_R_Cr + Gb1 * G_Cr + Bb1 * B_Cr     ) / 4 )
     
     uint8_t *destYptPixel = destYp.data;
     uint8_t *destYpbPixel = destYp.data + destYp.rowBytes;
     destYptPixel[0] = Ypt0;
     destYptPixel[1] = Ypt1;
     destYpbPixel[0] = Ypb0;
     destYpbPixel[1] = Ypb1;
     destYptPixel += 2;
     destYpbPixel += 2;
     
     uint8_t *destCbCrPixel = destCbCr.data;
     destCbCrPixel[0] = Cb0;
     destCbCrPixel[1] = Cr0;
     destCbCrPixel += 2;
   </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To420Yp8_CbCr8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16;   name=vImageConvert_ARGB8888To422CbYpCrYp16 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16"></a>
<h3><a name="vImageConvert_ARGB8888To422CbYpCrYp16">vImageConvert_ARGB8888To422CbYpCrYp16</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 422CbYpCrYp16 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To422CbYpCrYp16 //apple_ref/c/clm/vImageConvert_ARGB8888To422CbYpCrYp16 //apple_ref/c/intfcm/vImageConvert_ARGB8888To422CbYpCrYp16 //apple_ref/c/intfm/vImageConvert_ARGB8888To422CbYpCrYp16 //apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16" target="_top"><span class="function">vImageConvert_ARGB8888To422CbYpCrYp16</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp16/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp16/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp16/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp16/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CbYpCrYp16 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp16/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp16/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp16/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp16/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp16/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp16/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     </pre>

<p>Results are guaranteed to be faithfully rounded.
Chroma is sampled at center by default.
This function can work in place.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16;name=start --><p>Convert ARGB8888 to YUV 422CbYpCrYp16 format
     </p>
<pre> 
     
                                                        pixel0-1
                                   byte0 byte1   byte2 byte3   byte4 byte5   byte6 byte7
     A0 R0 G0 B0  A1 R1 G1 B1  =&gt;  LE-16-bit-Cb  LE-16-bit-Y0  LE-16-bit-Cr  LE-16-bit-Y1
     
     (LE and left-justified 16-bit-per-component)
      </pre>

<p>YUV 422CbYpCrYp16 can be used for 16-bit 'v216' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 16-bit 'v216' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>
<p>The per-pixel operation is:
     </p>
<pre> 
 
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     
     uint64_t *destPixel = dest.data;
     pack16bitv216AndStore(destPixel, Yp0, Yp1, Cb0, Cr0);
     destPixel += 1;
   
      </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp16;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8;   name=vImageConvert_ARGB8888To422CbYpCrYp8 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8"></a>
<h3><a name="vImageConvert_ARGB8888To422CbYpCrYp8">vImageConvert_ARGB8888To422CbYpCrYp8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 422CbYpCrYp8 format
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To422CbYpCrYp8 //apple_ref/c/clm/vImageConvert_ARGB8888To422CbYpCrYp8 //apple_ref/c/intfcm/vImageConvert_ARGB8888To422CbYpCrYp8 //apple_ref/c/intfm/vImageConvert_ARGB8888To422CbYpCrYp8 //apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8" target="_top"><span class="function">vImageConvert_ARGB8888To422CbYpCrYp8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CbYpCrYp8 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once in the ordering.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
 
 </pre>

<p>Results are guaranteed to be faithfully rounded.
Chroma is sampled at center by default.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8;name=start --><p>Convert ARGB8888 to YUV 422CbYpCrYp8 format. Can be used for 2vuy.
</p>

<p>A0 R0 G0 B0  A1 R1 G1 B1 =&gt; Cb0 Yp0 Cr0 Yp1
</p>

<p>YUV 422CbYpCrYp8 can be used for '2vuy' and '2vuf' that are defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to '2vuy' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>

<p>The per-pixel operation is:
</p>
 <pre>
 
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = Cb0;
     destPixel[1] = Yp0;
     destPixel[2] = Cr0;
     destPixel[3] = Yp1;
     destPixel += 4;
 
 </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8;   name=vImageConvert_ARGB8888To422CbYpCrYp8_AA8 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8"></a>
<h3><a name="vImageConvert_ARGB8888To422CbYpCrYp8_AA8">vImageConvert_ARGB8888To422CbYpCrYp8_AA8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 422CbYpCrYp8_AA8 format
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To422CbYpCrYp8_AA8 //apple_ref/c/clm/vImageConvert_ARGB8888To422CbYpCrYp8_AA8 //apple_ref/c/intfcm/vImageConvert_ARGB8888To422CbYpCrYp8_AA8 //apple_ref/c/intfm/vImageConvert_ARGB8888To422CbYpCrYp8_AA8 //apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8" target="_top"><span class="function">vImageConvert_ARGB8888To422CbYpCrYp8_AA8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">destA</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8_AA8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8_AA8/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8_AA8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8_AA8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CbYpCrYp8_AA8 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8_AA8/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8_AA8/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8_AA8/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8_AA8/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears exactly once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8_AA8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CbYpCrYp8_AA8/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
     
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
    
    <pre>
 
     Results are guaranteed to be faithfully rounded.
     Chroma is sampled at center by default.
 
 

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8;name=start --><p>Convert ARGB8888 to YUV 422CbYpCrYp8_AA8 format
</p>

<p>A0 R0 G0 B0  A1 R1 G1 B1 =&gt; Cb0 Yp0 Cr0 Yp1
</p>
<p>A0 A1
</p>

<p>For example, if we want to use this function to convert ARGB8888 to 'a2vy' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>
<p>The per-pixel operation is:
</p>
     <pre>
     
 
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = Cb0;
     destPixel[1] = Yp0;
     destPixel[2] = Cr0;
     destPixel[3] = Yp1;
     destPixel += 4;
 
     uint8_t *alpha = destA.data;
     alpha[0] = A0;
     alpha[1] = A1;
     alpha += 2;
 
     
     </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CbYpCrYp8_AA8;name=end --><!-- end discussion -->
</pre></pre>
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10;   name=vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10"></a>
<h3><a name="vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10">vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10 //apple_ref/c/clm/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10 //apple_ref/c/intfcm/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10 //apple_ref/c/intfm/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10 //apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10" target="_top"><span class="function">vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     </pre>

<p>Results are guaranteed to be faithfully rounded.
Chroma is sampled at center by default.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=start --><p>Convert ARGB8888 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format
</p>

<p>6 ARGB8888 pixels are getting mapped into 6 packed YUV pixels.
A0 R0 G0 B0  A1 R1 G1 B1  A2 R2 G2 B2  A3 R3 G3 B3  A4 R4 G4 B4  A5 R5 G5 B5  =&gt;
</p>
<p>12 10-bit unsigned components are packed into 4 32-bit little-endian words.
    </p>
<pre> 
     Word0
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cr0           10-bit Y0            10-bit Cb0
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
 
     Word1
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y2            10-bit Cb1           10-bit Y1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
 
     Word2
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cb2           10-bit Y3            10-bit Cr1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
 
     Word3
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y5            10-bit Cr2           10-bit Y4
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     </pre>

<p>YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 can be used for 'v210' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 'v210' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>
<p>The per-pixel operation is:
   </p>
<pre> 
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A2 = srcPixel[permuteMap[0]];
     R2 = srcPixel[permuteMap[1]];
     G2 = srcPixel[permuteMap[2]];
     B2 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A3 = srcPixel[permuteMap[0]];
     R3 = srcPixel[permuteMap[1]];
     G3 = srcPixel[permuteMap[2]];
     B3 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A4 = srcPixel[permuteMap[0]];
     R4 = srcPixel[permuteMap[1]];
     G4 = srcPixel[permuteMap[2]];
     B4 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A5 = srcPixel[permuteMap[0]];
     R5 = srcPixel[permuteMap[1]];
     G5 = srcPixel[permuteMap[2]];
     B5 = srcPixel[permuteMap[3]];
     srcPixel += 4;
 
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     Yp2 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R2 * R_Yp      + G2 * G_Yp + B2 * B_Yp     )
     Yp3 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R3 * R_Yp      + G3 * G_Yp + B3 * B_Yp     )
     Cb1 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R2 * R_Cb      + G2 * G_Cb + B2 * B_Cb_R_Cr
                                                   +   R3 * R_Cb      + G3 * G_Cb + B3 * B_Cb_R_Cr) / 2 )
     Cr1 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R2 * B_Cb_R_Cr + G2 * G_Cr + B2 * B_Cr
                                                   +   R3 * B_Cb_R_Cr + G3 * G_Cr + B3 * B_Cr     ) / 2 )
     Yp4 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R4 * R_Yp      + G4 * G_Yp + B4 * B_Yp     )
     Yp5 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R5 * R_Yp      + G5 * G_Yp + B5 * B_Yp     )
     Cb2 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R4 * R_Cb      + G4 * G_Cb + B4 * B_Cb_R_Cr
                                                   +   R5 * R_Cb      + G5 * G_Cb + B5 * B_Cb_R_Cr) / 2 )
     Cr2 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R4 * B_Cb_R_Cr + G4 * G_Cr + B4 * B_Cr
                                                   +   R5 * B_Cb_R_Cr + G5 * G_Cr + B5 * B_Cr     ) / 2 )
 
     uint32_t *destPixel = dest.data;
     packv210AndStore(destPixel, Yp0, Yp1, Yp2, Yp3, Yp4, Yp5, Cb0, Cb1, Cb2, Cr0, Cr1, Cr2);
     destPixel += 4;
    </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8;   name=vImageConvert_ARGB8888To422YpCbYpCr8 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8"></a>
<h3><a name="vImageConvert_ARGB8888To422YpCbYpCr8">vImageConvert_ARGB8888To422YpCbYpCr8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 422YpCbYpCr8 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To422YpCbYpCr8 //apple_ref/c/clm/vImageConvert_ARGB8888To422YpCbYpCr8 //apple_ref/c/intfcm/vImageConvert_ARGB8888To422YpCbYpCr8 //apple_ref/c/intfm/vImageConvert_ARGB8888To422YpCbYpCr8 //apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8" target="_top"><span class="function">vImageConvert_ARGB8888To422YpCbYpCr8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422YpCbYpCr8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422YpCbYpCr8/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422YpCbYpCr8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422YpCbYpCr8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 422YpCbYpCr8 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422YpCbYpCr8/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422YpCbYpCr8/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422YpCbYpCr8/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422YpCbYpCr8/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422YpCbYpCr8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To422YpCbYpCr8/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
 
 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height

 </pre>

<p>Results are guaranteed to be faithfully rounded.
Chroma is sampled at center by default.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8;name=start --><p>Convert ARGB8888 to YUV 422YpCbYpCr8 format
</p>
<p>A0 R0 G0 B0  A1 R1 G1 B1 =&gt; Yp0 Cb0 Yp1 Cr0
</p>

<p>YUV 422YpCbYpCr8 can be used for 'yuvs' and 'yuvf' that are defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 'yuvs' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>
<p>The per-pixel operation is:
</p>
 <pre>
 
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = Yp0;
     destPixel[1] = Cb0;
     destPixel[2] = Yp1;
     destPixel[3] = Cr0;
     destPixel += 4;
 
 </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To422YpCbYpCr8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16;   name=vImageConvert_ARGB8888To444AYpCbCr16 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16"></a>
<h3><a name="vImageConvert_ARGB8888To444AYpCbCr16">vImageConvert_ARGB8888To444AYpCbCr16</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 444AYpCbCr16 format
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To444AYpCbCr16 //apple_ref/c/clm/vImageConvert_ARGB8888To444AYpCbCr16 //apple_ref/c/intfcm/vImageConvert_ARGB8888To444AYpCbCr16 //apple_ref/c/intfm/vImageConvert_ARGB8888To444AYpCbCr16 //apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16" target="_top"><span class="function">vImageConvert_ARGB8888To444AYpCbCr16</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr16/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr16/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr16/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr16/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444AYpCbCr16 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr16/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr16/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr16/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr16/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as the values are unique.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr16/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr16/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
   </pre>

<p>Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16;name=start --><p>Convert ARGB8888 to YUV 444AYpCbCr16 format
</p>

<p>A0 R0 G0 B0  =&gt;  A0 Yp0 Cb0 Cr0
</p>

<p>YUV 444AYpCbCr8 can be used for 'y416' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 'y416' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>

<p>The per-pixel operation is:
  </p>
<pre> 
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = A0;
     destPixel[1] = Yp0;
     destPixel[2] = Cb0;
     destPixel[3] = Cr0;
     destPixel += 4;
   </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr16;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8;   name=vImageConvert_ARGB8888To444AYpCbCr8 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8"></a>
<h3><a name="vImageConvert_ARGB8888To444AYpCbCr8">vImageConvert_ARGB8888To444AYpCbCr8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 444AYpCbCr8 format
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To444AYpCbCr8 //apple_ref/c/clm/vImageConvert_ARGB8888To444AYpCbCr8 //apple_ref/c/intfcm/vImageConvert_ARGB8888To444AYpCbCr8 //apple_ref/c/intfm/vImageConvert_ARGB8888To444AYpCbCr8 //apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8" target="_top"><span class="function">vImageConvert_ARGB8888To444AYpCbCr8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr8/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444AYpCbCr8 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr8/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr8/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr8/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr8/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears exactly once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444AYpCbCr8/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
   
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
   
   <pre>
 
     Results are guaranteed to be faithfully rounded.
     This function can work in place.
 
 

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8;name=start --><p>Convert ARGB8888 to YUV 444AYpCbCr8 format
</p>

<p>A0 R0 G0 B0  =&gt;  A0 Yp0 Cb0 Cr0
</p>

<p>YUV 444AYpCbCr8 can be used for 'r408' and 'y408' that are defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 'y408' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>
<p>The per-pixel operation is:
</p>
 <pre>
 
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
 
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
 
     uint8_t *destPixel = dest.data;
     destPixel[0] = A0;
     destPixel[1] = Yp0;
     destPixel[2] = Cb0;
     destPixel[3] = Cr0;
     destPixel += 4;
 
 </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444AYpCbCr8;name=end --><!-- end discussion -->
</pre></pre>
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8;   name=vImageConvert_ARGB8888To444CbYpCrA8 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8"></a>
<h3><a name="vImageConvert_ARGB8888To444CbYpCrA8">vImageConvert_ARGB8888To444CbYpCrA8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 444CbYpCrA8 format
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To444CbYpCrA8 //apple_ref/c/clm/vImageConvert_ARGB8888To444CbYpCrA8 //apple_ref/c/intfcm/vImageConvert_ARGB8888To444CbYpCrA8 //apple_ref/c/intfm/vImageConvert_ARGB8888To444CbYpCrA8 //apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8" target="_top"><span class="function">vImageConvert_ARGB8888To444CbYpCrA8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CbYpCrA8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CbYpCrA8/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CbYpCrA8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CbYpCrA8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444CbYpCrA8 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CbYpCrA8/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CbYpCrA8/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CbYpCrA8/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CbYpCrA8/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, provided that each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CbYpCrA8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CbYpCrA8/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
  </pre>

<p>Results are guaranteed to be faithfully rounded.
This function can work in place.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8;name=start --><p>Convert ARGB8888 to YUV 444CbYpCrA8 format
</p>

<p>A0 R0 G0 B0  =&gt;  Cb0 Yp0 Cr0 A0
</p>

<p>YUV 444CbYpCrA8 can be used for 'v408' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 'v408' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>
<p>The per-pixel operation is:
</p>
 <pre> 
    uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = Cb0;
     destPixel[1] = Yp0;
     destPixel[2] = Cr0;
     destPixel[3] = A0;
     destPixel += 4;
  </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CbYpCrA8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10;   name=vImageConvert_ARGB8888To444CrYpCb10 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10"></a>
<h3><a name="vImageConvert_ARGB8888To444CrYpCb10">vImageConvert_ARGB8888To444CrYpCb10</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 444CrYpCb10 format
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To444CrYpCb10 //apple_ref/c/clm/vImageConvert_ARGB8888To444CrYpCb10 //apple_ref/c/intfcm/vImageConvert_ARGB8888To444CrYpCb10 //apple_ref/c/intfm/vImageConvert_ARGB8888To444CrYpCb10 //apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10" target="_top"><span class="function">vImageConvert_ARGB8888To444CrYpCb10</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb10/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb10/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb10/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb10/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444CrYpCb10 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb10/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb10/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb10/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb10/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb10/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb10/flags"></a>
<code>flags</code>
</dt>
<dd><p>kvImageGetTempBufferSize    Returns 0. Does no work.
kvImageDoNotTile            Disables internal multithreading, if any.</p></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
   kvImageNoError                  Is returned when there was no error.
   kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
   kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
   </pre>


<p>Results are guaranteed to be faithfully rounded.
This function can work in place.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10;name=start --><p>Convert ARGB8888 to YUV 444CrYpCb10 format
</p>

<p>3 10-bit unsigned components are packed into a 32-bit little-endian word.
Decreasing Address order (32-bit little-endian)
byte3           byte2            byte1            byte0
A0 R0 G0 B0  =&gt;  10-bit Cr            10-bit Yp            10-bit Cb
9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  X X

YUV 444CrYpCb10 can be used for 'v410' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 'v410' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>

<p>The per-pixel operation is:
  </p>
<pre> 
   uint8_t *srcPixel = src.data;
   R0 = srcPixel[permuteMap[1]];
   G0 = srcPixel[permuteMap[2]];
   B0 = srcPixel[permuteMap[3]];
   srcPixel += 4;

   Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
   Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
   Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )

   pixel = makev410(Yp0, Cb0, Cr0);

   uint32_t *destPixel = dest.data;
   *destPixel = pixel;
   destPixel += 1;
   </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb10;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8;   name=vImageConvert_ARGB8888To444CrYpCb8 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8"></a>
<h3><a name="vImageConvert_ARGB8888To444CrYpCb8">vImageConvert_ARGB8888To444CrYpCb8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to YUV 444CrYpCb8 format
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888To444CrYpCb8 //apple_ref/c/clm/vImageConvert_ARGB8888To444CrYpCb8 //apple_ref/c/intfcm/vImageConvert_ARGB8888To444CrYpCb8 //apple_ref/c/intfm/vImageConvert_ARGB8888To444CrYpCb8 //apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8" target="_top"><span class="function">vImageConvert_ARGB8888To444CrYpCb8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">info</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb8/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references YUV 444CrYpCb8 destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb8/info;   name=info -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb8/info"></a>
<code>info</code>
</dt>
<dd><p>A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb8/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb8/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, provided that each channel appears only once.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888To444CrYpCb8/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
 
 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
 
 </pre>

<p>Note: Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8;name=start --><p>Convert ARGB8888 to YUV 444CrYpCb8 format
</p>

<p>A0 R0 G0 B0  =&gt;  Cr0 Yp0 Cb0
</p>

<p>YUV 444CrYpCb8 can be used for 'v308' that is defined in CVPixelBuffer.h.
</p>
<p>For example, if we want to use this function to convert ARGB8888 to 'v308' with ITU 601 video range, then we need
generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
</p>
<p>Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
</p>

<p>The per-pixel operation is:
</p>
 <pre>
 
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = Cr0;
     destPixel[1] = Yp0;
     destPixel[2] = Cb0;
     destPixel += 3;
  
  </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888To444CrYpCb8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102;   name=vImageConvert_ARGB8888ToRGBA1010102 --><a name="//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102"></a>
<h3><a name="vImageConvert_ARGB8888ToRGBA1010102">vImageConvert_ARGB8888ToRGBA1010102</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102;name=start --><!-- begin abstract --></p>
<p>Convert ARGB8888 to RGBA1010102 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102" logicalPath="//apple_ref/c/instm/vImageConvert_ARGB8888ToRGBA1010102 //apple_ref/c/clm/vImageConvert_ARGB8888ToRGBA1010102 //apple_ref/c/intfcm/vImageConvert_ARGB8888ToRGBA1010102 //apple_ref/c/intfm/vImageConvert_ARGB8888ToRGBA1010102 //apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102" target="_top"><span class="function">vImageConvert_ARGB8888ToRGBA1010102</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMin</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMax</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels. Source pixels may have any alignment.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 10-bit RGB interleaved destination pixels.  Destination pixels must be at least 4 byte aligned.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/RGB101010RangeMax;   name=RGB101010RangeMax -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/RGB101010RangeMax"></a>
<code>RGB101010RangeMax</code>
</dt>
<dd><p>A maximum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/RGB101010RangeMin;   name=RGB101010RangeMin -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/RGB101010RangeMin"></a>
<code>RGB101010RangeMin</code>
</dt>
<dd><p>A minimum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of src.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGB8888ToRGBA1010102/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageDoNotTile            Disables internal multithreading, if any.
  </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     kvImageInvalidParameter         Is returned when RGB101010RangeMin is bigger than RGB101010RangeMax.
  </pre>

<p>Note
----
Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102;name=start --><p>Convert ARGB8888 to RGBA1010102 format.
</p>
<p>RGBA1010102 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
except that this format uses the least significant 2 bits for alpha channel.
</p>
<p>This format is 10-bit big endian 32-bit pixels.
</p>
<p>RGB101010RangeMax &amp; RGB101010RangeMin are available for non-full-range pixel values.
For full-range pixel values, the user can set these as
</p>
 <pre> 
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
  </pre>

<p>The per-pixel operation is:
 </p>
<pre> 
 
     uint8_t *srcPixel = src.data;
     A8 = srcPixel[permuteMap[0]];
     R8 = srcPixel[permuteMap[1]];
     G8 = srcPixel[permuteMap[2]];
     B8 = srcPixel[permuteMap[3]];
     srcPixel += 4;
 
     int32_t R10, G10, B10;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
     int32_t rounding = UCHAR_MAX &gt;&gt; 1;
     R10 = ((R8 * range10 + rounding) / UCHAR_MAX) + RGB101010RangeMin;
     G10 = ((G8 * range10 + rounding) / UCHAR_MAX) + RGB101010RangeMin;
     B10 = ((B8 * range10 + rounding) / UCHAR_MAX) + RGB101010RangeMin;
     A10 = ((A10 * 3 + rounding) / UCHAR_MAX);
 
     uint32_t *destPixel = dest.data;
     destPixel[0] = htonl((R10 &lt;&lt; 22) | (G10 &lt;&lt; 12) | (B10 &lt;&lt; 2) | A10);
     destPixel += 1;
  </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGB8888ToRGBA1010102;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered;   name=vImageConvert_ARGBFFFFtoARGB8888_dithered --><a name="//apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered"></a>
<h3><a name="vImageConvert_ARGBFFFFtoARGB8888_dithered">vImageConvert_ARGBFFFFtoARGB8888_dithered</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered;name=start --><!-- begin abstract --></p>
<p>Convert an array of floating point data to 8 bit integer data with dithering.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered" logicalPath="//apple_ref/c/instm/vImageConvert_ARGBFFFFtoARGB8888_dithered //apple_ref/c/clm/vImageConvert_ARGBFFFFtoARGB8888_dithered //apple_ref/c/intfcm/vImageConvert_ARGBFFFFtoARGB8888_dithered //apple_ref/c/intfm/vImageConvert_ARGBFFFFtoARGB8888_dithered //apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered" target="_top"><span class="function">vImageConvert_ARGBFFFFtoARGB8888_dithered</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_FFFF" logicalPath="//apple_ref/c/cl/Pixel_FFFF //apple_ref/c/tdef/Pixel_FFFF" target="_top"><span class="type">Pixel_FFFF</span></a> <span class="param">maxFloat</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_FFFF" logicalPath="//apple_ref/c/cl/Pixel_FFFF //apple_ref/c/tdef/Pixel_FFFF" target="_top"><span class="type">Pixel_FFFF</span></a> <span class="param">minFloat</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int //apple_ref/c/tdef/int //apple_ref/c/tag/int //apple_ref/c/struct/int //apple_ref/c/intf/int //apple_ref/doc/anysymbol/int" machineGenerated="true" --><span class="type">int</span><!-- /a --> <span class="param">dither</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to a valid and initialized vImage_Buffer struct that points to a buffer containing the source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a valid and initialized vImage_Buffer struct that points to a allocated buffer to receive the result pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/maxFloat;   name=maxFloat -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/maxFloat"></a>
<code>maxFloat</code>
</dt>
<dd><p>The encoding for 1.0 in the src buffer, full intensity. Typically, this is 1.0 for floating-point data in the range[0,1] but if your data is [0,65535] then you would pass 65535.0f here.
A separate value is provided for each of the four channels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/minFloat;   name=minFloat -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/minFloat"></a>
<code>minFloat</code>
</dt>
<dd><p>The encoding for 0.0 in the src buffer, no light.  Typically this is 0.0 for floating-point data in the range [0,1], but if your data is [-.5,0.5] then you would pass -0.5f here.
A separate value is provided for each of the four channels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/dither;   name=dither -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/dither"></a>
<code>dither</code>
</dt>
<dd>
<p>The type of random noise to use for the dither. The following values are accepted:
</p>
          <pre>
          
                  kvImageConvert_DitherNone - Rounds to nearest.

                  kvImageConvert_DitherOrdered - pre-computed blue noise is added to the image before rounding to the values in
                      the destination format.  The offset into this blue noise is randomized per-call to avoid visible artifacts
                      if you do your own tiling or call the function on sequential frames of video.

                  kvImageConvert_DitherOrderedReproducible - pre-computed blue noise is added to the image before rounding to the
                      values in the destination format.  The offset into the blue noise is the same for every call to allow users
                      to get reproducible results. Fine for still images. For video kvImageConvert_DitherOrdered is a better choice.
          
          </pre>
<p>The ordered dither methods may be further influenced by shaping the distribution of the noise using the gaussian and uniform options below.
These options are OR-ed with kvImageConvert_DitherOrdered / kvImageConvert_DitherOrderedReproducible:
          </p>
<pre>
          
                  kvImageConvert_OrderedGaussianBlue - when using an ordered dither pattern, distribute the noise according to a gaussian
                      distribution. This generally gives more pleasing images --  less noisy and perhaps a little more saturated -- but color
                      fidelity can suffer. Its effect is between kvImageConvert_DitherNone and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
                      This is the default for kvImageConvert_DitherOrdered and kvImageConvert_DitherOrderedReproducible.

                  kvImageConvert_OrderedUniformBlue - when using an ordered dither pattern, distribute the noise uniformly. This generally gives
                      best color fidelity, but the resulting image is noisier and more obviously dithered. This is usually the best choice when low
                      bitdepth content is drawn next to high bitdepth content and in other circumstances where subtle changes to color arising from the conversion
                      could be easily noticed. It may be a poor choice when the image is likely to be enlarged -- this would cause the noise to become
                      more evident-- and for very flat / synthetic content with little inherent noise. The enlargement problem may be avoided by enlarging
                      first at high bitdepth, then convert to lower bitdepth.
          
          </pre>

<p>To clarify: "Blue" noise does not look blue, nor does it operate solely on the blue color channel. Blue noise is monochrome noise that is added to all color
channels equally. The name arises from blue light, which has a higher frequency than other colors of visible light. Thus, blue noise is noise which is
weighted heavily towards high frequencies. Low frequency noise tends to have visible shapes in it that would become apparent in an image if it was added in,
so it is excluded from the dither pattern.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>A 4 element array giving the order of the result channels.  This allows you to convert a ARGB float buffer to a BGRA result buffer by providing the
order {3,2,1,0}.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBFFFFtoARGB8888_dithered/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are honored:
          </p>
<pre>
          
                      kvImageNoFlags              Default operation

                      kvImageDoNotTile            Disable internal multithreading.  You should use this if you are doing your own threading / tiling.

                      kvImageGetTempBufferSize    Returns 0.  Does no work. Does not touch data.

          
          </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may be returned:
</p>
          <pre>
          
              kvImageNoError                      Success

              kvImageRoiLargerThanInputBuffer     The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.

              kvImageUnknownFlagsBit              Not all vImage flags are understood by this function. See description of flags parameter for supported flags.

              kvImageInvalidParameter             An unknown / unsupported dithering mode was requested.
          
          </pre>




<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered;name=start --><p>For each pixel, do the following:
</p>
          <pre>
          
          // convert to uint8_t
          Pixel_8888 temp;
          temp[0] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[0] - minFloat[0] ) / (maxFloat[0] - minFloat[0]) + random_float[0,1) );
          temp[1] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[1] - minFloat[1] ) / (maxFloat[1] - minFloat[1]) + random_float[0,1) );
          temp[2] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[2] - minFloat[2] ) / (maxFloat[2] - minFloat[2]) + random_float[0,1) );
          temp[3] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[3] - minFloat[3] ) / (maxFloat[3] - minFloat[3]) + random_float[0,1) );

          // place in requested output order
          Pixel_8888 result;
          result[0] = temp[permuteMap[0]];
          result[1] = temp[permuteMap[1]];
          result[2] = temp[permuteMap[2]];
          result[3] = temp[permuteMap[3]];
          
          </pre>

<p>This function will work for other channel orders, such as RGBA and BGRA.
</p>
<p>This function can work in place provided the following are true:
if src overlaps with dest,
src-&gt;data must be equal to dest-&gt;data and src-&gt;rowBytes &gt;= dest-&gt;rowBytes
If an overlapping src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
</p>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGBFFFFtoARGB8888_dithered;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion;   name=vImageConvert_ARGBToYpCbCr_GenerateConversion --><a name="//apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion"></a>
<h3><a name="vImageConvert_ARGBToYpCbCr_GenerateConversion">vImageConvert_ARGBToYpCbCr_GenerateConversion</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion;name=start --><!-- begin abstract --></p>
<p>Generates the conversion from a ARGB to a YpCbCr pixel format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion" logicalPath="//apple_ref/c/instm/vImageConvert_ARGBToYpCbCr_GenerateConversion //apple_ref/c/clm/vImageConvert_ARGBToYpCbCr_GenerateConversion //apple_ref/c/intfcm/vImageConvert_ARGBToYpCbCr_GenerateConversion //apple_ref/c/intfm/vImageConvert_ARGBToYpCbCr_GenerateConversion //apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion" target="_top"><span class="function">vImageConvert_ARGBToYpCbCr_GenerateConversion</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCrMatrix" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCrMatrix //apple_ref/c/tdef/vImage_ARGBToYpCbCrMatrix" target="_top"><span class="type">vImage_ARGBToYpCbCrMatrix</span></a> <span class="type">*</span><span class="param">matrix</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrPixelRange" logicalPath="//apple_ref/c/cl/vImage_YpCbCrPixelRange //apple_ref/c/tdef/vImage_YpCbCrPixelRange" target="_top"><span class="type">vImage_YpCbCrPixelRange</span></a> <span class="type">*</span><span class="param">pixelRange</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_ARGBToYpCbCr" logicalPath="//apple_ref/c/cl/vImage_ARGBToYpCbCr //apple_ref/c/tdef/vImage_ARGBToYpCbCr" target="_top"><span class="type">vImage_ARGBToYpCbCr</span></a> <span class="type">*</span><span class="param">outInfo</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImageARGBType" logicalPath="//apple_ref/c/cl/vImageARGBType //apple_ref/c/tdef/vImageARGBType" target="_top"><span class="type">vImageARGBType</span></a> <span class="param">inARGBType</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImageYpCbCrType" logicalPath="//apple_ref/c/cl/vImageYpCbCrType //apple_ref/c/tdef/vImageYpCbCrType" target="_top"><span class="type">vImageYpCbCrType</span></a> <span class="param">outYpCbCrType</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/matrix;   name=matrix -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/matrix"></a>
<code>matrix</code>
</dt>
<dd><p>A pointer to vImage_ARGBToYpCbCrMatrix that contains the matrix coefficients for the conversion
from a ARGB to a YpCbCr pixel format.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/pixelRange;   name=pixelRange -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/pixelRange"></a>
<code>pixelRange</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrPixelRange that contains the pixel range information for the conversion
from a ARGB to a YpCbCr pixel format.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/outInfo;   name=outInfo -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/outInfo"></a>
<code>outInfo</code>
</dt>
<dd><p>A pointer to vImage_ARGBToYpCbCr will be initialized with the information for the conversion function
will use later.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/inARGBType;   name=inARGBType -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/inARGBType"></a>
<code>inARGBType</code>
</dt>
<dd><p>A ARGBType to specify the output ARGB format.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/outYpCbCrType;   name=outYpCbCrType -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/outYpCbCrType"></a>
<code>outYpCbCrType</code>
</dt>
<dd><p>A YpCbCrType to specify the input YpCbCr format.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_ARGBToYpCbCr_GenerateConversion/flags"></a>
<code>flags</code>
</dt>
<dd><p>kvImagePrintDiagnosticsToConsole   Directs the function to print diagnostic information to the console in the event of failure.</p></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageUnsupportedConversion    Is returned when there is no conversion in vImage for inARGBType &amp; outYpCbCrType.
      </pre>



<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion;name=start --><p>This function is used to create the vImage_ARGBToYpCbCr conversion information necessary for all
of RGB -&gt; YUV conversion functions.
</p>
<p>For example, if we want to prepare for the conversion from ARGB8888 'yuvs' with ITU 601 video range, then we
need to do the following:
</p>
     <pre> 
     vImage_Error err = kvImageNoError;
     vImage_Flags flags = kvImageNoFlags;
     vImage_YpCbCrPixelRange pixelRange;
     vImage_ARGBToYpCbCr outInfo;
     
     pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' &gt; 1.
     pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' &lt; 0.
     pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr &gt; 0.5
     pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr &lt; -0.5
 
     err = vImageConvert_ARGBToYpCbCr_GenerateConversion(kvImage_ARGBToYpCbCrMatrix_ITU_R_601_4, &amp;pixelRange, &amp;outInfo, kvImageARGB8888, kvImage422YpCbYpCr8, flags);
 
 
     If we want to define our own conversion coefficents, then we can do
 
     vImage_ARGBToYpCbCrMatrix matrix;;
     vImage_YpCbCrPixelRange pixelRange;
 
     matrix.R_Yp          =  0.2989f;
     matrix.G_Yp          =  0.5866f;
     matrix.B_Yp          =  0.1144f;
     matrix.R_Cb          = -0.1688f;
     matrix.G_Cb          = -0.3312f;
     matrix.B_Cb_R_Cr     =  0.5f;
     matrix.G_Cr          = -0.4183f;
     matrix.B_Cr          = -0.0816f;
     pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' &gt; 1.
     pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' &lt; 0.
     pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr &gt; 0.5
     pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr &lt; -0.5
 
     err = vImageConvert_ARGBToYpCbCr_GenerateConversion(&amp;matrix, &amp;pixelRange, &amp;outInfo, kvImageARGB8888, kvImage422YpCbYpCr8, flags);
 
 
     vImage_ARGBToYpCbCr created may be reused multiple times from multiple threads concurrently.
 
     Here are the conversions available currently.
     
             RGB8   RGB16Q12    RGB16
     YUV8     Y        N          N
     YUV10    Y        Y          N
     YUV12    Y        Y          N
     YUV14    Y        N          Y
     YUV16    Y        N          Y
  </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_ARGBToYpCbCr_GenerateConversion;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered;   name=vImageConvert_PlanarFtoPlanar8_dithered --><a name="//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered"></a>
<h3><a name="vImageConvert_PlanarFtoPlanar8_dithered">vImageConvert_PlanarFtoPlanar8_dithered</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered;name=start --><!-- begin abstract --></p>
<p>Convert an array of floating point data to 8 bit integer data with dithering. 
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered" logicalPath="//apple_ref/c/instm/vImageConvert_PlanarFtoPlanar8_dithered //apple_ref/c/clm/vImageConvert_PlanarFtoPlanar8_dithered //apple_ref/c/intfcm/vImageConvert_PlanarFtoPlanar8_dithered //apple_ref/c/intfm/vImageConvert_PlanarFtoPlanar8_dithered //apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered" target="_top"><span class="function">vImageConvert_PlanarFtoPlanar8_dithered</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_F" logicalPath="//apple_ref/c/cl/Pixel_F //apple_ref/c/tdef/Pixel_F" target="_top"><span class="type">Pixel_F</span></a> <span class="param">maxFloat</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_F" logicalPath="//apple_ref/c/cl/Pixel_F //apple_ref/c/tdef/Pixel_F" target="_top"><span class="type">Pixel_F</span></a> <span class="param">minFloat</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int //apple_ref/c/tdef/int //apple_ref/c/tag/int //apple_ref/c/struct/int //apple_ref/c/intf/int //apple_ref/doc/anysymbol/int" machineGenerated="true" --><span class="type">int</span><!-- /a --> <span class="param">dither</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing the source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a valid and initialized vImage_Buffer struct, that points to a allocated buffer to receive the result pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/maxFloat;   name=maxFloat -->
<a name="//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/maxFloat"></a>
<code>maxFloat</code>
</dt>
<dd><p>The encoding for 1.0 in the src buffer, full intensity. Typically, this is 1.0 for floating-point data in the range[0,1] but if your data is [0,65535] then you would pass 65535.0f here.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/minFloat;   name=minFloat -->
<a name="//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/minFloat"></a>
<code>minFloat</code>
</dt>
<dd><p>The encoding for 0.0 in the src buffer, no light.  Typically this is 0.0 for floating-point data in the range [0,1], but if your data is [-.5,0.5] then you would pass -0.5f here.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/dither;   name=dither -->
<a name="//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/dither"></a>
<code>dither</code>
</dt>
<dd>
<p>The type of random noise to use for the dither. The following values are accepted:
</p>
          <pre>
          
                  kvImageConvert_DitherNone - Same as vImageConvert_PlanarFtoPlanar8().  Rounds to nearest.

                  kvImageConvert_DitherOrdered - pre-computed blue noise is added to the image before rounding to the values in
                      the destination format.  The offset into this blue noise is randomized per-call to avoid visible artifacts
                      if you do your own tiling or call the function on sequential frames of video.

                  kvImageConvert_DitherOrderedReproducible - pre-computed blue noise is added to the image before rounding to the
                      values in the destination format.  The offset into the blue noise is the same for every call to allow users
                      to get reproducible results. Fine for still images. For video kvImageConvert_DitherOrdered is a better choice.
          
          </pre>
<p>The ordered dither methods may be further influenced by shaping the distribution of the noise using the gaussian and uniform options below.
These options are OR-ed with kvImageConvert_DitherOrdered / kvImageConvert_DitherOrderedReproducible:
          </p>
<pre>
          
                  kvImageConvert_OrderedGaussianBlue - when using an ordered dither pattern, distribute the noise according to a gaussian
                      distribution. This generally gives more pleasing images --  less noisy and perhaps a little more saturated -- but color
                      fidelity can suffer. Its effect is between kvImageConvert_DitherNone and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
                      This is the default for kvImageConvert_DitherOrdered and kvImageConvert_DitherOrderedReproducible.

                  kvImageConvert_OrderedUniformBlue - when using an ordered dither pattern, distribute the noise uniformly. This generally gives
                      best color fidelity, but the resulting image is noisier and more obviously dithered. This is usually the best choice when low
                      bitdepth content is drawn next to high bitdepth content and in other circumstances where subtle changes to color arising from the conversion
                      could be easily noticed. It may be a poor choice when the image is likely to be enlarged -- this would cause the noise to become
                      more evident-- and for very flat / synthetic content with little inherent noise. The enlargement problem may be avoided by enlarging
                      first at high bitdepth, then convert to lower bitdepth.
          
          </pre>

<p>To clarify: "Blue" noise does not look blue, nor does it operate solely on the blue color channel. Blue noise is monochrome noise that is added to all color
channels equally. The name arises from blue light, which has a higher frequency than other colors of visible light. Thus, blue noise is noise which is
weighted heavily towards high frequencies. Low frequency noise tends to have visible shapes in it that would become apparent in an image if it was added in,
so it is excluded from the dither pattern.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_PlanarFtoPlanar8_dithered/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are honored:
          </p>
<pre>
          
                      kvImageNoFlags              Default operation

                      kvImageDoNotTile            Disable internal multithreading.  You should use this if you are doing your own threading / tiling.
                                                  
                      kvImageGetTempBufferSize    Returns 0.  Does no work. Does not touch data.

          
          </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may be returned:
</p>
          <pre>
          
              kvImageNoError                      Success

              kvImageRoiLargerThanInputBuffer     The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.

              kvImageUnknownFlagsBit              Not all vImage flags are understood by this function. See description of flags parameter for supported flags. 

              kvImageInvalidParameter             An unknown / unsupported dithering mode was requested.
          
          </pre>




<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered;name=start --><p>For each pixel, do the following:
</p>
          <pre>
          
         uint8_t result = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel - minFloat ) / (maxFloat - minFloat) + random_float[0,1) );
          
          </pre>

<p>Caution: unlike vImageConvert_PlanarFtoPlanar8, vImageConvert_PlanarFtoPlanar8_dithered usually should not be used for 
multichannel data. Otherwise the dithering will occur in the chrominance dimensions and the noise will cause
grain with varying hue.
</p>
<p>This function can work in place provided the following are true:
if src overlaps with dest,
src-&gt;data must be equal to dest-&gt;data and src-&gt;rowBytes &gt;= dest-&gt;rowBytes
If an overlapping src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
</p>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_PlanarFtoPlanar8_dithered;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_RGB565toARGB1555;   name=vImageConvert_RGB565toARGB1555 --><a name="//apple_ref/c/func/vImageConvert_RGB565toARGB1555"></a>
<h3><a name="vImageConvert_RGB565toARGB1555">vImageConvert_RGB565toARGB1555</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGB565toARGB1555;name=start --><!-- begin abstract --></p>
<p>Convert from RGB565 to ARGB1555 image format
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGB565toARGB1555;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGB565toARGB1555;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_RGB565toARGB1555" logicalPath="//apple_ref/c/instm/vImageConvert_RGB565toARGB1555 //apple_ref/c/clm/vImageConvert_RGB565toARGB1555 //apple_ref/c/intfcm/vImageConvert_RGB565toARGB1555 //apple_ref/c/intfm/vImageConvert_RGB565toARGB1555 //apple_ref/c/func/vImageConvert_RGB565toARGB1555" target="_top"><span class="function">vImageConvert_RGB565toARGB1555</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int //apple_ref/c/tdef/int //apple_ref/c/tag/int //apple_ref/c/struct/int //apple_ref/c/intf/int //apple_ref/doc/anysymbol/int" machineGenerated="true" --><span class="type">int</span><!-- /a --> <span class="param">dither</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGB565toARGB1555;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGB565toARGB1555/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGB565toARGB1555/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to a vImage_Buffer struct which describes a memory region full of RGB565 pixels</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGB565toARGB1555/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGB565toARGB1555/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by ARGB1555 pixels</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGB565toARGB1555/dither;   name=dither -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGB565toARGB1555/dither"></a>
<code>dither</code>
</dt>
<dd>
<p>A dithering method for the green channel.   Options:
</p>
<p>kvImageConvert_DitherNone - apply no dithering; input values
are rounded to the nearest value representable in the
destination format.
kvImageConvert_DitherOrdered - pre-computed blue noise is
added to the image before rounding to the values in
the destination format.  The offset into this blue
noise is randomized per-call to avoid visible artifacts
if you do your own tiling or call the function on
sequential frames of video.
kvImageConvert_DitherOrderedReproducible - pre-computed
blue noise is added to the image before rounding to the
values in the destination format.  The offset into the
blue noise is the same for every call to allow users
to get reproducible results.
</p>
<p>The ordered dither methods may be further influenced by shaping the
distribution of the noise using the gaussian and uniform options below.
These options are OR-ed with kvImageConvert_DitherOrdered / kvImageCon-
vert_DitherOrderedReproducible:
</p>
<p>kvImageConvert_OrderedGaussianBlue - when using an ordered dither
pattern, distribute the noise according to a gaussian
distribution. This generally gives more pleasing images --
less noisy and perhaps a little more saturated -- but color
fidelity can suffer. Its effect is between kvImageConvert_DitherNone
and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
This is the default for kvImageConvert_DitherOrdered and
kvImageConvert_DitherOrderedReproducible.
</p>
<p>kvImageConvert_OrderedUniformBlue - when using an ordered dither
pattern, distribute the noise uniformly. This generally gives
best color fidelity, but the resulting image is noisier and more
obviously dithered. This is usually the best choice when low
bitdepth content is drawn next to high bitdepth content and in other
circumstances where subtle changes to color arising from the conversion
could be easily noticed. It may be a poor choice when the image
is likely to be enlarged -- this would cause the noise to become
more evident-- and for very flat / synthetic content with little
inherent noise. The enlargement problem may be avoided by enlarging
first at high bitdepth, then convert to lower bitdepth.
</p>
<p>To clarify: "Blue" noise is not blue, nor does it operate solely on the blue
color channel. Blue noise is monochrome noise that is added to all color
channels equally. The name arises from blue light, which has a higher frequency
than other colors of visible light. Thus, blue noise is noise which is
weighted heavily towards high frequencies. Low frequency noise tends to have
visible shapes in it that would become apparent in an image if it was added in,
so it is excluded from the dither pattern.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGB565toARGB1555/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGB565toARGB1555/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are understood by this function:
</p>
          <pre>
          
          kvImageNoFlags                      Default operation.

          kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
                                              many such operations going concurrently, and in cases where it is desirable to keep
                                              CPU utilization to a single core.

          kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
          
          </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
          
          kvImageNoError                          Success

          kvImageBufferSizeMismatch               dest-&gt;height &gt; src-&gt;height OR dest-&gt;width &gt; src-&gt;width.  There are not enough pixels to fill the destination buffer.

          kvImageInvalidParameter                 Invalid / unknown dither value
          
          </pre>



<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGB565toARGB1555;name=start --><p>Convert from RGB565 to ARGB1555 format.  The new alpha is set to 1.
Both RGB565 and ARGB1555 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGB565toARGB1555;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_RGB565toRGBA5551;   name=vImageConvert_RGB565toRGBA5551 --><a name="//apple_ref/c/func/vImageConvert_RGB565toRGBA5551"></a>
<h3><a name="vImageConvert_RGB565toRGBA5551">vImageConvert_RGB565toRGBA5551</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGB565toRGBA5551;name=start --><!-- begin abstract --></p>
<p>Convert from RGB565 to RGBA5551 image format
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGB565toRGBA5551;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGB565toRGBA5551;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_RGB565toRGBA5551" logicalPath="//apple_ref/c/instm/vImageConvert_RGB565toRGBA5551 //apple_ref/c/clm/vImageConvert_RGB565toRGBA5551 //apple_ref/c/intfcm/vImageConvert_RGB565toRGBA5551 //apple_ref/c/intfm/vImageConvert_RGB565toRGBA5551 //apple_ref/c/func/vImageConvert_RGB565toRGBA5551" target="_top"><span class="function">vImageConvert_RGB565toRGBA5551</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int //apple_ref/c/tdef/int //apple_ref/c/tag/int //apple_ref/c/struct/int //apple_ref/c/intf/int //apple_ref/doc/anysymbol/int" machineGenerated="true" --><span class="type">int</span><!-- /a --> <span class="param">dither</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGB565toRGBA5551;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGB565toRGBA5551/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGB565toRGBA5551/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to a vImage_Buffer struct which describes a memory region full of RGB565 pixels</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGB565toRGBA5551/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGB565toRGBA5551/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by RGBA5551 pixels</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGB565toRGBA5551/dither;   name=dither -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGB565toRGBA5551/dither"></a>
<code>dither</code>
</dt>
<dd>
<p>A dithering method for the green channel.   Options:
</p>
<p>kvImageConvert_DitherNone - apply no dithering; input values
are rounded to the nearest value representable in the
destination format.
kvImageConvert_DitherOrdered - pre-computed blue noise is
added to the image before rounding to the values in
the destination format.  The offset into this blue
noise is randomized per-call to avoid visible artifacts
if you do your own tiling or call the function on
sequential frames of video.
kvImageConvert_DitherOrderedReproducible - pre-computed
blue noise is added to the image before rounding to the
values in the destination format.  The offset into the
blue noise is the same for every call to allow users
to get reproducible results.
</p>
<p>The ordered dither methods may be further influenced by shaping the
distribution of the noise using the gaussian and uniform options below.
These options are OR-ed with kvImageConvert_DitherOrdered / kvImageCon-
vert_DitherOrderedReproducible:
</p>
<p>kvImageConvert_OrderedGaussianBlue - when using an ordered dither
pattern, distribute the noise according to a gaussian
distribution. This generally gives more pleasing images --
less noisy and perhaps a little more saturated -- but color
fidelity can suffer. Its effect is between kvImageConvert_DitherNone
and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
This is the default for kvImageConvert_DitherOrdered and
kvImageConvert_DitherOrderedReproducible.
</p>
<p>kvImageConvert_OrderedUniformBlue - when using an ordered dither
pattern, distribute the noise uniformly. This generally gives
best color fidelity, but the resulting image is noisier and more
obviously dithered. This is usually the best choice when low
bitdepth content is drawn next to high bitdepth content and in other
circumstances where subtle changes to color arising from the conversion
could be easily noticed. It may be a poor choice when the image
is likely to be enlarged -- this would cause the noise to become
more evident-- and for very flat / synthetic content with little
inherent noise. The enlargement problem may be avoided by enlarging
first at high bitdepth, then convert to lower bitdepth.
</p>
<p>To clarify: "Blue" noise is not blue, nor does it operate solely on the blue
color channel. Blue noise is monochrome noise that is added to all color
channels equally. The name arises from blue light, which has a higher frequency
than other colors of visible light. Thus, blue noise is noise which is
weighted heavily towards high frequencies. Low frequency noise tends to have
visible shapes in it that would become apparent in an image if it was added in,
so it is excluded from the dither pattern.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGB565toRGBA5551/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGB565toRGBA5551/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are understood by this function:
</p>
          <pre>
          
          kvImageNoFlags                      Default operation.

          kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
                                              many such operations going concurrently, and in cases where it is desirable to keep
                                              CPU utilization to a single core.

          kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
          
          </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
          
          kvImageNoError                          Success

          kvImageBufferSizeMismatch               dest-&gt;height &gt; src-&gt;height OR dest-&gt;width &gt; src-&gt;width.  There are not enough pixels to fill the destination buffer.

          kvImageInvalidParameter                 Invalid / unknown dither value
          
          </pre>



<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGB565toRGBA5551;name=start --><p>Convert from RGB565 to RGBA5551 format.  The new alpha is set to 1.
Both RGB565 and RGBA5551 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGB565toRGBA5551;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12;   name=vImageConvert_RGBA1010102ToARGB16Q12 --><a name="//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12"></a>
<h3><a name="vImageConvert_RGBA1010102ToARGB16Q12">vImageConvert_RGBA1010102ToARGB16Q12</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12;name=start --><!-- begin abstract --></p>
<p>Convert RGBA1010102 to ARGB16Q12 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12" logicalPath="//apple_ref/c/instm/vImageConvert_RGBA1010102ToARGB16Q12 //apple_ref/c/clm/vImageConvert_RGBA1010102ToARGB16Q12 //apple_ref/c/intfcm/vImageConvert_RGBA1010102ToARGB16Q12 //apple_ref/c/intfm/vImageConvert_RGBA1010102ToARGB16Q12 //apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12" target="_top"><span class="function">vImageConvert_RGBA1010102ToARGB16Q12</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMin</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMax</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 10-bit RGB interleaved source pixels.  Samples must be at least 4 byte aligned.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16Q12 ARGB interleaved destination pixels.  Samples must be at least 2 byte aligned.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/RGB101010RangeMax;   name=RGB101010RangeMax -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/RGB101010RangeMax"></a>
<code>RGB101010RangeMax</code>
</dt>
<dd><p>A maximum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/RGB101010RangeMin;   name=RGB101010RangeMin -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/RGB101010RangeMin"></a>
<code>RGB101010RangeMin</code>
</dt>
<dd><p>A minimum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel is unique.  That is, ARRG is not an allowed order
because R is repeated.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16Q12/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageDoNotTile            Disables internal multithreading, if any.
  </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     kvImageInvalidParameter         Is returned when RGB101010RangeMin is bigger than RGB101010RangeMax.
  </pre>

<p>Note: Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12;name=start --><p>Convert RGBA1010102 to ARGB16Q12 format
</p>
<p>RGBA1010102 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
except that this format uses the least significant 2 bits for alpha channel.
</p>
<p>This format is 10-bit big endian 32-bit pixels.
</p>
<p>RGB101010RangeMax &amp; RGB101010RangeMin are available for non-full-range pixel values.
For full-range pixel values, the user can set these as
</p>
 <pre> 
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
  </pre>

<p>The per-pixel operation is:
</p>
 <pre> 
     uint32_t *srcPixel = src.data;
     uint32_t pixel = ntohl(srcPixel[0]);
     srcPixel += 1;
     
     int32_t A2  = pixel &amp; 0x3;
     int32_t R10 = (pixel &gt;&gt; 22) &amp; 0x3ff;
     int32_t G10 = (pixel &gt;&gt; 12) &amp; 0x3ff;
     int32_t B10 = (pixel &gt;&gt;  2) &amp; 0x3ff;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
     
     int16_t R16, G16, B16;
     A2  = (A2 * 4096 + 1) / 3;
     R16 = ((R10 - RGB101010RangeMin) * 4096 + (range10 &gt;&gt; 1)) / range10;
     G16 = ((G10 - RGB101010RangeMin) * 4096 + (range10 &gt;&gt; 1)) / range10;
     B16 = ((B10 - RGB101010RangeMin) * 4096 + (range10 &gt;&gt; 1)) / range10;
     
     R16 = CLAMP(INT16_MIN, R16, INT16_MAX);
     G16 = CLAMP(INT16_MIN, G16, INT16_MAX);
     B16 = CLAMP(INT16_MIN, B16, INT16_MAX);
     
     int16_t ARGB[4];
     ARGB[0] = A2;
     ARGB[1] = R16;
     ARGB[2] = G16;
     ARGB[3] = B16;
     
     int16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
  </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16Q12;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U;   name=vImageConvert_RGBA1010102ToARGB16U --><a name="//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U"></a>
<h3><a name="vImageConvert_RGBA1010102ToARGB16U">vImageConvert_RGBA1010102ToARGB16U</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U;name=start --><!-- begin abstract --></p>
<p>Convert RGBA1010102 to ARGB16U format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U" logicalPath="//apple_ref/c/instm/vImageConvert_RGBA1010102ToARGB16U //apple_ref/c/clm/vImageConvert_RGBA1010102ToARGB16U //apple_ref/c/intfcm/vImageConvert_RGBA1010102ToARGB16U //apple_ref/c/intfm/vImageConvert_RGBA1010102ToARGB16U //apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U" target="_top"><span class="function">vImageConvert_RGBA1010102ToARGB16U</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMin</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMax</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 10-bit RGB interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 16-bit ARGB interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/RGB101010RangeMax;   name=RGB101010RangeMax -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/RGB101010RangeMax"></a>
<code>RGB101010RangeMax</code>
</dt>
<dd><p>A maximum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/RGB101010RangeMin;   name=RGB101010RangeMin -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/RGB101010RangeMin"></a>
<code>RGB101010RangeMin</code>
</dt>
<dd><p>A minimum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
permuteMap[4] = {3, 2, 1, 0} is BGRA16U.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB16U/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     kvImageInvalidParameter         Is returned when RGB101010RangeMin is bigger than RGB101010RangeMax.
  </pre>

<p>Note: Results are guaranteed to be faithfully rounded.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U;name=start --><p>Convert RGBA1010102 to ARGB16U format
</p>
<p>RGBA1010102 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
except that this format uses the least significant 2 bits for alpha channel.
</p>
<p>This format is 10-bit big endian 32-bit pixels.
</p>
<p>RGB101010RangeMax &amp; RGB101010RangeMin are available for non-full-range pixel values.
For full-range pixel values, the user can set these as
</p>
 <pre> 
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
  </pre>

<p>The per-pixel operation is:
 </p>
<pre> 
 
     uint32_t *srcPixel = src.data;
     uint32_t pixel = ntohl(srcPixel[0]);
     srcPixel += 1;
     
     int32_t A2  = pixel &amp; 0x3;
     int32_t R10 = (pixel &gt;&gt; 22) &amp; 0x3ff;
     int32_t G10 = (pixel &gt;&gt; 12) &amp; 0x3ff;
     int32_t B10 = (pixel &gt;&gt;  2) &amp; 0x3ff;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
     
     A2  = (A2 * USHRT_MAX + 1) / 3;
     R10 = ((R10 - RGB101010RangeMin) * USHRT_MAX + (range10 &gt;&gt; 1)) / range10;
     G10 = ((G10 - RGB101010RangeMin) * USHRT_MAX + (range10 &gt;&gt; 1)) / range10;
     B10 = ((B10 - RGB101010RangeMin) * USHRT_MAX + (range10 &gt;&gt; 1)) / range10;
     
     uint16_t R16, G16, B16;
     R16 = CLAMP(0, R10, USHRT_MAX);
     G16 = CLAMP(0, G10, USHRT_MAX);
     B16 = CLAMP(0, B10, USHRT_MAX);
     
     uint16_t ARGB[4];
     ARGB[0] = A2;
     ARGB[1] = R16;
     ARGB[2] = G16;
     ARGB[3] = B16;
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
  </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB16U;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888;   name=vImageConvert_RGBA1010102ToARGB8888 --><a name="//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888"></a>
<h3><a name="vImageConvert_RGBA1010102ToARGB8888">vImageConvert_RGBA1010102ToARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888;name=start --><!-- begin abstract --></p>
<p>Convert RGBA1010102 to ARGB8888 format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888" logicalPath="//apple_ref/c/instm/vImageConvert_RGBA1010102ToARGB8888 //apple_ref/c/clm/vImageConvert_RGBA1010102ToARGB8888 //apple_ref/c/intfcm/vImageConvert_RGBA1010102ToARGB8888 //apple_ref/c/intfm/vImageConvert_RGBA1010102ToARGB8888 //apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888" target="_top"><span class="function">vImageConvert_RGBA1010102ToARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMin</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">RGB101010RangeMax</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">4</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 10-bit RGB interleaved source pixels. Source pixels must be at least 4 byte aligned.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels. Destination pixels may have any alignment.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/RGB101010RangeMax;   name=RGB101010RangeMax -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/RGB101010RangeMax"></a>
<code>RGB101010RangeMax</code>
</dt>
<dd><p>A maximum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/RGB101010RangeMin;   name=RGB101010RangeMin -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/RGB101010RangeMin"></a>
<code>RGB101010RangeMin</code>
</dt>
<dd><p>A minimum value for 10-bit RGB pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA1010102ToARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageDoNotTile            Disables internal multithreading, if any.
  <pre></pre></pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
     kvImageInvalidParameter         Is returned when RGB101010RangeMin is bigger than RGB101010RangeMax.
  </pre>
 
<p>     Note: Results are guaranteed to be faithfully rounded.
 
 

<!-- end return value --></p>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888;name=start --><p>Convert RGBA1010102 to ARGB8888 format
     
     RGBA1010102 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
     except that this format uses the least significant 2 bits for alpha channel.
 
     This format is 10-bit big endian 32-bit pixels.
 
     RGB101010RangeMax &amp; RGB101010RangeMin are available for non-full-range pixel values.
     For full-range pixel values, the user can set these as
 
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
 
     The per-pixel operation is:
     </p>
<pre> 
 
     uint32_t *srcPixel = src.data;
     uint32_t pixel = ntohl(srcPixel[0]);
     srcPixel += 1;
 
     int32_t A2  = pixel &amp; 0x3;
     int32_t R10 = (pixel &gt;&gt; 22) &amp; 0x3ff;
     int32_t G10 = (pixel &gt;&gt; 12) &amp; 0x3ff;
     int32_t B10 = (pixel &gt;&gt;  2) &amp; 0x3ff;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
 
     A2  = (A2 * UCHAR_MAX + 1) / 3;
     R10 = ((R10 - RGB101010RangeMin) * UCHAR_MAX + (range10 &gt;&gt; 1)) / range10;
     G10 = ((G10 - RGB101010RangeMin) * UCHAR_MAX + (range10 &gt;&gt; 1)) / range10;
     B10 = ((B10 - RGB101010RangeMin) * UCHAR_MAX + (range10 &gt;&gt; 1)) / range10;
 
     uint8_t R8, G8, B8;
     R8 = CLAMP(0, R10, UCHAR_MAX);
     G8 = CLAMP(0, G10, UCHAR_MAX);
     B8 = CLAMP(0, B10, UCHAR_MAX);
 
     uint8_t ARGB[4];
     ARGB[0] = A2;
     ARGB[1] = R8;
     ARGB[2] = G8;
     ARGB[3] = B8;
 
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
      <pre>
 
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGBA1010102ToARGB8888;name=end --><!-- end discussion -->
</pre></pre>
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_RGBA5551toRGB565;   name=vImageConvert_RGBA5551toRGB565 --><a name="//apple_ref/c/func/vImageConvert_RGBA5551toRGB565"></a>
<h3><a name="vImageConvert_RGBA5551toRGB565">vImageConvert_RGBA5551toRGB565</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGBA5551toRGB565;name=start --><!-- begin abstract --></p>
<p>Convert from RGBA5551 to RGB565 image format
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGBA5551toRGB565;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGBA5551toRGB565;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_RGBA5551toRGB565" logicalPath="//apple_ref/c/instm/vImageConvert_RGBA5551toRGB565 //apple_ref/c/clm/vImageConvert_RGBA5551toRGB565 //apple_ref/c/intfcm/vImageConvert_RGBA5551toRGB565 //apple_ref/c/intfm/vImageConvert_RGBA5551toRGB565 //apple_ref/c/func/vImageConvert_RGBA5551toRGB565" target="_top"><span class="function">vImageConvert_RGBA5551toRGB565</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGBA5551toRGB565;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA5551toRGB565/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA5551toRGB565/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to a vImage_Buffer struct which describes a memory region full of RGBA5551 pixels</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA5551toRGB565/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA5551toRGB565/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by RGB565 pixels</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBA5551toRGB565/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBA5551toRGB565/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are understood by this function:
</p>
          <pre>
          
          kvImageNoFlags                      Default operation.

          kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
                                              many such operations going concurrently, and in cases where it is desirable to keep
                                              CPU utilization to a single core.

          kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
          
          </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre>
          
          kvImageNoError                          Success

          kvImageBufferSizeMismatch               dest-&gt;height &gt; src-&gt;height OR dest-&gt;width &gt; src-&gt;width.  There are not enough pixels to fill the destination buffer.
          
          </pre>



<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGBA5551toRGB565;name=start --><p>Convert (with loss of alpha) from RGBA5551 to RGB565 format.
If you need something fancier done with alpha first, such as unpremultiplication or flattening, convert to 8 bit per channel first. 
Both RGB565 and RGBA5551 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGBA5551toRGB565;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered;   name=vImageConvert_RGBFFFtoRGB888_dithered --><a name="//apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered"></a>
<h3><a name="vImageConvert_RGBFFFtoRGB888_dithered">vImageConvert_RGBFFFtoRGB888_dithered</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered;name=start --><!-- begin abstract --></p>
<p>Convert an array of floating point data to 8 bit integer data with dithering.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered" logicalPath="//apple_ref/c/instm/vImageConvert_RGBFFFtoRGB888_dithered //apple_ref/c/clm/vImageConvert_RGBFFFtoRGB888_dithered //apple_ref/c/intfcm/vImageConvert_RGBFFFtoRGB888_dithered //apple_ref/c/intfm/vImageConvert_RGBFFFtoRGB888_dithered //apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered" target="_top"><span class="function">vImageConvert_RGBFFFtoRGB888_dithered</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_F" logicalPath="//apple_ref/c/cl/Pixel_F //apple_ref/c/tdef/Pixel_F" target="_top"><span class="type">Pixel_F</span></a> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/maxFloat" logicalPath="//apple_ref/c/cl/maxFloat //apple_ref/c/tdef/maxFloat //apple_ref/c/tag/maxFloat //apple_ref/c/struct/maxFloat //apple_ref/c/intf/maxFloat //apple_ref/doc/anysymbol/maxFloat" target="_top"><span class="type">maxFloat</span></a>[<span class="number">3</span>],
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_F" logicalPath="//apple_ref/c/cl/Pixel_F //apple_ref/c/tdef/Pixel_F" target="_top"><span class="type">Pixel_F</span></a> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/minFloat" logicalPath="//apple_ref/c/cl/minFloat //apple_ref/c/tdef/minFloat //apple_ref/c/tag/minFloat //apple_ref/c/struct/minFloat //apple_ref/c/intf/minFloat //apple_ref/doc/anysymbol/minFloat" target="_top"><span class="type">minFloat</span></a>[<span class="number">3</span>],
    <!-- a logicalPath="//apple_ref/c/cl/int //apple_ref/c/tdef/int //apple_ref/c/tag/int //apple_ref/c/struct/int //apple_ref/c/intf/int //apple_ref/doc/anysymbol/int" machineGenerated="true" --><span class="type">int</span><!-- /a --> <span class="param">dither</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to a valid and initialized vImage_Buffer struct that points to a buffer containing the source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a valid and initialized vImage_Buffer struct that points to a allocated buffer to receive the result pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/maxFloat;   name=maxFloat -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/maxFloat"></a>
<code>maxFloat</code>
</dt>
<dd><p>The encoding for 1.0 in the src buffer, full intensity. Typically, this is 1.0 for floating-point data in the range[0,1] but if your data is [0,65535] then you would pass 65535.0f here.
A separate value is provided for each of the four channels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/minFloat;   name=minFloat -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/minFloat"></a>
<code>minFloat</code>
</dt>
<dd><p>The encoding for 0.0 in the src buffer, no light.  Typically this is 0.0 for floating-point data in the range [0,1], but if your data is [-.5,0.5] then you would pass -0.5f here.
A separate value is provided for each of the four channels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/dither;   name=dither -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/dither"></a>
<code>dither</code>
</dt>
<dd>
<p>The type of random noise to use for the dither. The following values are accepted:
</p>
          <pre>
          
                  kvImageConvert_DitherNone - Rounds to nearest.

                  kvImageConvert_DitherOrdered - pre-computed blue noise is added to the image before rounding to the values in
                      the destination format.  The offset into this blue noise is randomized per-call to avoid visible artifacts
                      if you do your own tiling or call the function on sequential frames of video.

                  kvImageConvert_DitherOrderedReproducible - pre-computed blue noise is added to the image before rounding to the
                      values in the destination format.  The offset into the blue noise is the same for every call to allow users
                      to get reproducible results. Fine for still images. For video kvImageConvert_DitherOrdered is a better choice.
          
          </pre>
<p>The ordered dither methods may be further influenced by shaping the distribution of the noise using the gaussian and uniform options below.
These options are OR-ed with kvImageConvert_DitherOrdered / kvImageConvert_DitherOrderedReproducible:
          </p>
<pre>
          
                  kvImageConvert_OrderedGaussianBlue - when using an ordered dither pattern, distribute the noise according to a gaussian
                      distribution. This generally gives more pleasing images --  less noisy and perhaps a little more saturated -- but color
                      fidelity can suffer. Its effect is between kvImageConvert_DitherNone and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
                      This is the default for kvImageConvert_DitherOrdered and kvImageConvert_DitherOrderedReproducible.

                  kvImageConvert_OrderedUniformBlue - when using an ordered dither pattern, distribute the noise uniformly. This generally gives
                      best color fidelity, but the resulting image is noisier and more obviously dithered. This is usually the best choice when low
                      bitdepth content is drawn next to high bitdepth content and in other circumstances where subtle changes to color arising from the conversion
                      could be easily noticed. It may be a poor choice when the image is likely to be enlarged -- this would cause the noise to become
                      more evident-- and for very flat / synthetic content with little inherent noise. The enlargement problem may be avoided by enlarging
                      first at high bitdepth, then convert to lower bitdepth.
          
          </pre>

<p>To clarify: "Blue" noise does not look blue, nor does it operate solely on the blue color channel. Blue noise is monochrome noise that is added to all color
channels equally. The name arises from blue light, which has a higher frequency than other colors of visible light. Thus, blue noise is noise which is
weighted heavily towards high frequencies. Low frequency noise tends to have visible shapes in it that would become apparent in an image if it was added in,
so it is excluded from the dither pattern.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_RGBFFFtoRGB888_dithered/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are honored:
          </p>
<pre>
          
                      kvImageNoFlags              Default operation

                      kvImageDoNotTile            Disable internal multithreading.  You should use this if you are doing your own threading / tiling.

                      kvImageGetTempBufferSize    Returns 0.  Does no work. Does not touch data.

          
          </pre>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following error codes may be returned:
</p>
          <pre>
          
              kvImageNoError                      Success

              kvImageRoiLargerThanInputBuffer     The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.

              kvImageUnknownFlagsBit              Not all vImage flags are understood by this function. See description of flags parameter for supported flags.

              kvImageInvalidParameter             An unknown / unsupported dithering mode was requested.
          
          </pre>




<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered;name=start --><p>For each pixel, do the following:
</p>
          <pre>
          
          // convert to uint8_t
          result[0] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[0] - minFloat[0] ) / (maxFloat[0] - minFloat[0]) + random_float[0,1) );
          result[1] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[1] - minFloat[1] ) / (maxFloat[1] - minFloat[1]) + random_float[0,1) );
          result[2] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[2] - minFloat[2] ) / (maxFloat[2] - minFloat[2]) + random_float[0,1) );

          
          </pre>

<p>This function will work for other channel orders, such as BGR, and other colorspaces such as L*a*b*.
If you need to change channel orders, please see vImagePermuteChannels_RGB888().
</p>
<p>This function can work in place provided the following are true:
if src overlaps with dest,
src-&gt;data must be equal to dest-&gt;data and src-&gt;rowBytes &gt;= dest-&gt;rowBytes
If an overlapping src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
</p>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_RGBFFFtoRGB888_dithered;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion;   name=vImageConvert_YpCbCrToARGB_GenerateConversion --><a name="//apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion"></a>
<h3><a name="vImageConvert_YpCbCrToARGB_GenerateConversion">vImageConvert_YpCbCrToARGB_GenerateConversion</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion;name=start --><!-- begin abstract --></p>
<p>Generates the conversion from a YpCbCr to a ARGB pixel format.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion" logicalPath="//apple_ref/c/instm/vImageConvert_YpCbCrToARGB_GenerateConversion //apple_ref/c/clm/vImageConvert_YpCbCrToARGB_GenerateConversion //apple_ref/c/intfcm/vImageConvert_YpCbCrToARGB_GenerateConversion //apple_ref/c/intfm/vImageConvert_YpCbCrToARGB_GenerateConversion //apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion" target="_top"><span class="function">vImageConvert_YpCbCrToARGB_GenerateConversion</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGBMatrix" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGBMatrix //apple_ref/c/tdef/vImage_YpCbCrToARGBMatrix" target="_top"><span class="type">vImage_YpCbCrToARGBMatrix</span></a> <span class="type">*</span><span class="param">matrix</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrPixelRange" logicalPath="//apple_ref/c/cl/vImage_YpCbCrPixelRange //apple_ref/c/tdef/vImage_YpCbCrPixelRange" target="_top"><span class="type">vImage_YpCbCrPixelRange</span></a> <span class="type">*</span><span class="param">pixelRange</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_YpCbCrToARGB" logicalPath="//apple_ref/c/cl/vImage_YpCbCrToARGB //apple_ref/c/tdef/vImage_YpCbCrToARGB" target="_top"><span class="type">vImage_YpCbCrToARGB</span></a> <span class="type">*</span><span class="param">outInfo</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImageYpCbCrType" logicalPath="//apple_ref/c/cl/vImageYpCbCrType //apple_ref/c/tdef/vImageYpCbCrType" target="_top"><span class="type">vImageYpCbCrType</span></a> <span class="param">inYpCbCrType</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImageARGBType" logicalPath="//apple_ref/c/cl/vImageARGBType //apple_ref/c/tdef/vImageARGBType" target="_top"><span class="type">vImageARGBType</span></a> <span class="param">outARGBType</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/matrix;   name=matrix -->
<a name="//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/matrix"></a>
<code>matrix</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToARGBMatrix that contains the matrix coefficients for the conversion
from a YpCbCr to a ARGB pixel format.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/pixelRange;   name=pixelRange -->
<a name="//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/pixelRange"></a>
<code>pixelRange</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrPixelRange that contains the pixel range information for the conversion
from a YpCbCr to a ARGB pixel format.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/outInfo;   name=outInfo -->
<a name="//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/outInfo"></a>
<code>outInfo</code>
</dt>
<dd><p>A pointer to vImage_YpCbCrToRGB will be initialized with the information for the conversion function
will use later.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/inYpCbCrType;   name=inYpCbCrType -->
<a name="//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/inYpCbCrType"></a>
<code>inYpCbCrType</code>
</dt>
<dd><p>A YpCbCrType to specify the input YpCbCr format.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/outARGBType;   name=outARGBType -->
<a name="//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/outARGBType"></a>
<code>outARGBType</code>
</dt>
<dd><p>A ARGBType to specify the output ARGB format.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvert_YpCbCrToARGB_GenerateConversion/flags"></a>
<code>flags</code>
</dt>
<dd><p>kvImagePrintDiagnosticsToConsole   Directs the function to print diagnostic information to the console in the event of failure.</p></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following return codes may occur:
     </p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageUnsupportedConversion    Is returned when there is no conversion in vImage for inYpCbCrType &amp; outARGBType.
       </pre>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion;name=start --><p>This function is used to create the vImage_YpCbCrToARGB conversion information necessary for all
of YUV -&gt; RGB conversion functions.
</p>
<p>For example, if we want to prepare for the conversion from 'yuvs' with ITU 601 video range to ARGB8888, then we
need to do the following:
</p>
     <pre> 
     vImage_Error err = kvImageNoError;
     vImage_Flags flags = kvImageNoFlags;
     vImage_YpCbCrPixelRange pixelRange;
     vImage_YpCbCrToARGB outInfo;
 
     pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' &gt; 1.
     pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' &lt; 0.
     pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr &gt; 0.5
     pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr &lt; -0.5
                                            //                ( pixelRange.CbCr_bias - (pixelRange.CbCrRangeMax - pixelRange.CbCr_bias) = 2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax )
 
     err = vImageConvert_YpCbCrToARGB_GenerateConversion(kvImageITU601_YpCbCrToARGBMatrix, &amp;pixelRange, &amp;outInfo, kvImage422YpCbYpCr8, kvImageARGB8888, flags);
      </pre>

<p>If we want to define our own conversion coefficents, then we can do
</p>
 <pre> 
     vImage_YpCbCrToARGBMatrix matrix;
     vImage_YpCbCrPixelRange pixelRange;
 
     matrix.Yp                  =  1.0f;
     matrix.Cb_G                = -0.3441f;
     matrix.Cb_B                =  1.772f;
     matrix.Cr_R                =  1.402f;
     matrix.Cr_G                = -0.7141f;
 
     pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' &gt; 1.
     pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' &lt; 0.
     pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr &gt; 0.5
     pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr &lt; -0.5
                                            //                ( pixelRange.CbCr_bias - (pixelRange.CbCrRangeMax - pixelRange.CbCr_bias) = 2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax )
 
     err = vImageConvert_YpCbCrToARGB_GenerateConversion(&amp;matrix, &amp;pixelRange, &amp;outInfo, kvImage422YpCbYpCr8, kvImageARGB8888, flags).
  </pre>


<p>vImage_YpCbCrToARGB created may be reused multiple times from multiple threads concurrently.
</p>
<p>Here are the conversions available currently.
</p>
 <pre>
 
             RGB8   RGB16Q12    RGB16
     YUV8     Y        N          N
     YUV10    Y        Y          N
     YUV12    Y        Y          N
     YUV14    Y        N          Y
     YUV16    Y        N          Y
 
 </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvert_YpCbCrToARGB_GenerateConversion;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageCopyBuffer;   name=vImageCopyBuffer --><a name="//apple_ref/c/func/vImageCopyBuffer"></a>
<h3><a name="vImageCopyBuffer">vImageCopyBuffer</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageCopyBuffer;name=start --><!-- begin abstract --></p>
<p>Copy vImage buffer from src to dest.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageCopyBuffer;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageCopyBuffer;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageCopyBuffer" logicalPath="//apple_ref/c/instm/vImageCopyBuffer //apple_ref/c/clm/vImageCopyBuffer //apple_ref/c/intfcm/vImageCopyBuffer //apple_ref/c/intfm/vImageCopyBuffer //apple_ref/c/func/vImageCopyBuffer" target="_top"><span class="function">vImageCopyBuffer</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/size_t //apple_ref/c/tdef/size_t //apple_ref/c/tag/size_t //apple_ref/c/struct/size_t //apple_ref/c/intf/size_t //apple_ref/doc/anysymbol/size_t" machineGenerated="true" --><span class="type">size_t</span><!-- /a --> <span class="param">pixelSize</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageCopyBuffer;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageCopyBuffer/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageCopyBuffer/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to source vImage_Buffer.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageCopyBuffer/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageCopyBuffer/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to destination vImage_Buffer.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageCopyBuffer/pixelSize;   name=pixelSize -->
<a name="//apple_ref/doc/functionparam/vImageCopyBuffer/pixelSize"></a>
<code>pixelSize</code>
</dt>
<dd><p>Number of bytes for one pixel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageCopyBuffer/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageCopyBuffer/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageDoNotTile            Disables internal multithreading, if any.
     kvImageGetTempBufferSize    Returns 0. Does no work.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageBufferSizeMismatch       Is returned when src.width &lt; dest.width || src.height &lt; dest.height
  </pre>



<!-- end return value --><dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageExtractChannel_ARGB16U;   name=vImageExtractChannel_ARGB16U --><a name="//apple_ref/c/func/vImageExtractChannel_ARGB16U"></a>
<h3><a name="vImageExtractChannel_ARGB16U">vImageExtractChannel_ARGB16U</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageExtractChannel_ARGB16U;name=start --><!-- begin abstract --></p>
<p>Extract one channel from a 4-channel interleaved 16-bit per component buffer. 
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageExtractChannel_ARGB16U;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageExtractChannel_ARGB16U;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageExtractChannel_ARGB16U" logicalPath="//apple_ref/c/instm/vImageExtractChannel_ARGB16U //apple_ref/c/clm/vImageExtractChannel_ARGB16U //apple_ref/c/intfcm/vImageExtractChannel_ARGB16U //apple_ref/c/intfm/vImageExtractChannel_ARGB16U //apple_ref/c/func/vImageExtractChannel_ARGB16U" target="_top"><span class="function">vImageExtractChannel_ARGB16U</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/long //apple_ref/c/tdef/long //apple_ref/c/tag/long //apple_ref/c/struct/long //apple_ref/c/intf/long //apple_ref/doc/anysymbol/long" machineGenerated="true" --><span class="type">long</span><!-- /a --> <span class="param">channelIndex</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageExtractChannel_ARGB16U;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGB16U/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGB16U/src"></a>
<code>src</code>
</dt>
<dd><p>A valid pointer to a vImage_Buffer struct which describes a 16-bit per component, four channel buffer.
It does not have to be ARGB16U. It can be BGRA, RGBA, CMYK, etc. The data can be any 16-bit per component
type such as int16_t or half-precision floating-point. Data must be at least 2-byte aligned.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGB16U/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGB16U/dest"></a>
<code>dest</code>
</dt>
<dd><p>A valid pointer to a vImage_Buffer struct which describes a 16-bit per component, one channel buffer.
The buffer pointed to by dest should be allocated by you. It will be overwritten with one of the
channels.  This function does work in place, so long as the rowBytes is the same for src and dest
images and the start address also matches. The data returned will be in the same format (uint16_t, 
int16_t, half-float, etc.) as the data provided in the src format, except that only a single channel
is present. Data must be at least 2-byte aligned.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGB16U/channelIndex;   name=channelIndex -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGB16U/channelIndex"></a>
<code>channelIndex</code>
</dt>
<dd><p>The index of the channel to extract. For alpha in a ARGB image, this is 0.  For alpha in a BGRA image, this is 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGB16U/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGB16U/flags"></a>
<code>flags</code>
</dt>
<dd><p>The following flags are allowed:  kvImageDoNotTile, kvImageGetTempBufferSize, kvImageNoFlags, kvImagePrintDiagnosticsToConsole</p></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following errors may be returned:
</p>
               <pre>

                  kvImageNoError                      Success. However, see also 0 below, if the kvImageGetTempBufferSize flag is passed.

                      0                               If the kvImageGetTempBufferSize flag is passed, this function returns 0 and does no work.

                  kvImageRoiLargerThanInputBuffer     The destination height or width is larger than the src height or width, respectively.

                  kvImageUnknownFlagsBit              A flag was used which was not among the approved set of flags. See flags param description above.

                  kvImageInvalidParameter             channelIndex must be in the range [0,3]

                </pre>



<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageExtractChannel_ARGB16U;name=start --><p>vImageExtractChannel_ARGB16U reads one component from the four channel 16-bit per component buffer 
and writes it into a Planar16U buffer.  Since this just copies data around, the data may be any 
16-bit per component data type, including signed 16 bit integers and half-precision floating point,
of any endianness. Likewise, the channel order does not need to be ARGB. RGBA, BGRA, CMYK, etc. all work.
</p>
               <pre>

                  for each pixel i in src:

                      Pixel_ARGB_16U *src_pixel;
                      Pixel_16U *dest_pixel;

                      dest_pixel[i] = src_pixel[i][channelIndex];

                </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageExtractChannel_ARGB16U;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageExtractChannel_ARGB8888;   name=vImageExtractChannel_ARGB8888 --><a name="//apple_ref/c/func/vImageExtractChannel_ARGB8888"></a>
<h3><a name="vImageExtractChannel_ARGB8888">vImageExtractChannel_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageExtractChannel_ARGB8888;name=start --><!-- begin abstract --></p>
<p>Extract one channel from a 4-channel interleaved 8-bit per component buffer
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageExtractChannel_ARGB8888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageExtractChannel_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageExtractChannel_ARGB8888" logicalPath="//apple_ref/c/instm/vImageExtractChannel_ARGB8888 //apple_ref/c/clm/vImageExtractChannel_ARGB8888 //apple_ref/c/intfcm/vImageExtractChannel_ARGB8888 //apple_ref/c/intfm/vImageExtractChannel_ARGB8888 //apple_ref/c/func/vImageExtractChannel_ARGB8888" target="_top"><span class="function">vImageExtractChannel_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/long //apple_ref/c/tdef/long //apple_ref/c/tag/long //apple_ref/c/struct/long //apple_ref/c/intf/long //apple_ref/doc/anysymbol/long" machineGenerated="true" --><span class="type">long</span><!-- /a --> <span class="param">channelIndex</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageExtractChannel_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>A valid pointer to a vImage_Buffer struct which describes a 8-bit per component, four channel buffer.
It does not have to be ARGB8888. It can be BGRA, RGBA, CMYK, etc.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A valid pointer to a vImage_Buffer struct which describes a 8-bit per component, one channel buffer.
The buffer pointed to by dest should be allocated by you. It will be overwritten with one of the 
channels.  This function does work in place, so long as the rowBytes is the same for src and dest
images and the start address also matches.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGB8888/channelIndex;   name=channelIndex -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGB8888/channelIndex"></a>
<code>channelIndex</code>
</dt>
<dd><p>The index of the channel to extract. For alpha in a ARGB image, this is 0.  For alpha in a BGRA image, this is 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd><p>The following flags are allowed:  kvImageDoNotTile, kvImageGetTempBufferSize, kvImageNoFlags, kvImagePrintDiagnosticsToConsole</p></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following errors may be returned:
</p>
               <pre>

                  kvImageNoError                      Success. However, see also 0 below, if the kvImageGetTempBufferSize flag is passed.

                      0                               If the kvImageGetTempBufferSize flag is passed, this function returns 0 and does no work.

                  kvImageRoiLargerThanInputBuffer     The destination height or width is larger than the src height or width, respectively.

                  kvImageUnknownFlagsBit              A flag was used which was not among the approved set of flags. See flags param description above.

                  kvImageInvalidParameter             channelIndex must be in the range [0,3]

                </pre>



<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageExtractChannel_ARGB8888;name=start --><p>This is the opposite operation from vImageOverwriteChannels_ARGB8888. It reads one component
from the four channel 8-bit per component buffer and writes it into a Planar8 buffer.
</p>
               <pre>

                  for each pixel i in src:

                      Pixel_8888 *src_pixel;
                      Pixel_8 *dest_pixel;

                      dest_pixel[i] = src_pixel[i][channelIndex];

                </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageExtractChannel_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageExtractChannel_ARGBFFFF;   name=vImageExtractChannel_ARGBFFFF --><a name="//apple_ref/c/func/vImageExtractChannel_ARGBFFFF"></a>
<h3><a name="vImageExtractChannel_ARGBFFFF">vImageExtractChannel_ARGBFFFF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageExtractChannel_ARGBFFFF;name=start --><!-- begin abstract --></p>
<p>Extract one channel from a 4-channel interleaved 32-bit per component buffer
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageExtractChannel_ARGBFFFF;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageExtractChannel_ARGBFFFF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageExtractChannel_ARGBFFFF" logicalPath="//apple_ref/c/instm/vImageExtractChannel_ARGBFFFF //apple_ref/c/clm/vImageExtractChannel_ARGBFFFF //apple_ref/c/intfcm/vImageExtractChannel_ARGBFFFF //apple_ref/c/intfm/vImageExtractChannel_ARGBFFFF //apple_ref/c/func/vImageExtractChannel_ARGBFFFF" target="_top"><span class="function">vImageExtractChannel_ARGBFFFF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/long //apple_ref/c/tdef/long //apple_ref/c/tag/long //apple_ref/c/struct/long //apple_ref/c/intf/long //apple_ref/doc/anysymbol/long" machineGenerated="true" --><span class="type">long</span><!-- /a --> <span class="param">channelIndex</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageExtractChannel_ARGBFFFF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGBFFFF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGBFFFF/src"></a>
<code>src</code>
</dt>
<dd><p>A valid pointer to a vImage_Buffer struct which describes a 32-bit per component, four channel buffer.
It does not have to be ARGBFFFF. It can be BGRA, RGBA, CMYK, etc. of any endianness. Data must be at 
least 4-byte aligned.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGBFFFF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGBFFFF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A valid pointer to a vImage_Buffer struct which describes a 32-bit per component, one channel buffer.
The buffer pointed to by dest should be allocated by you. It will be overwritten with one of the
channels.  This function does work in place, so long as the rowBytes is the same for src and dest
images and the start address also matches. Data must be at least 4 byte aligned.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGBFFFF/channelIndex;   name=channelIndex -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGBFFFF/channelIndex"></a>
<code>channelIndex</code>
</dt>
<dd><p>The index of the channel to extract. For alpha in a ARGB image, this is 0.  For alpha in a BGRA image, this is 3.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageExtractChannel_ARGBFFFF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageExtractChannel_ARGBFFFF/flags"></a>
<code>flags</code>
</dt>
<dd><p>The following flags are allowed:  kvImageDoNotTile, kvImageGetTempBufferSize, kvImageNoFlags, kvImagePrintDiagnosticsToConsole</p></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>The following errors may be returned:
</p>
               <pre>

                  kvImageNoError                      Success. However, see also 0 below, if the kvImageGetTempBufferSize flag is passed.

                      0                               If the kvImageGetTempBufferSize flag is passed, this function returns 0 and does no work.

                  kvImageRoiLargerThanInputBuffer     The destination height or width is larger than the src height or width, respectively.

                  kvImageUnknownFlagsBit              A flag was used which was not among the approved set of flags. See flags param description above.

                  kvImageInvalidParameter             channelIndex must be in the range [0,3]

                </pre>



<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageExtractChannel_ARGBFFFF;name=start --><p>This is the opposite operation from vImageOverwriteChannels_ARGBFFFF. It reads one component
from the four channel 32-bit per component buffer and writes it into a PlanarF buffer. NaNs and 
and sNaNs are not modified. Sign of zero shall be preserved.
</p>
               <pre>

                  for each pixel i in src:

                      Pixel_FFFF *src_pixel;
                      Pixel_F *dest_pixel;

                      dest_pixel[i] = src_pixel[i][channelIndex];

                </pre>


<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageExtractChannel_ARGBFFFF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImagePermuteChannels_RGB888;   name=vImagePermuteChannels_RGB888 --><a name="//apple_ref/c/func/vImagePermuteChannels_RGB888"></a>
<h3><a name="vImagePermuteChannels_RGB888">vImagePermuteChannels_RGB888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImagePermuteChannels_RGB888;name=start --><!-- begin abstract --></p>
<p>Reorder 3 color channels within the buffer according to the permute map.
</p>
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImagePermuteChannels_RGB888;name=end -->
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImagePermuteChannels_RGB888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImagePermuteChannels_RGB888" logicalPath="//apple_ref/c/instm/vImagePermuteChannels_RGB888 //apple_ref/c/clm/vImagePermuteChannels_RGB888 //apple_ref/c/intfcm/vImagePermuteChannels_RGB888 //apple_ref/c/intfm/vImagePermuteChannels_RGB888 //apple_ref/c/func/vImagePermuteChannels_RGB888" target="_top"><span class="function">vImagePermuteChannels_RGB888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/uint8_t //apple_ref/c/tdef/uint8_t //apple_ref/c/tag/uint8_t //apple_ref/c/struct/uint8_t //apple_ref/c/intf/uint8_t //apple_ref/doc/anysymbol/uint8_t" machineGenerated="true" --><span class="type">uint8_t</span><!-- /a --> <a machinegenerated="true" href="index.html#//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap" logicalPath="//apple_ref/c/cl/permuteMap //apple_ref/c/tdef/permuteMap //apple_ref/c/tag/permuteMap //apple_ref/c/struct/permuteMap //apple_ref/c/intf/permuteMap //apple_ref/doc/anysymbol/permuteMap" target="_top"><span class="type">permuteMap</span></a>[<span class="number">3</span>],
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span>) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImagePermuteChannels_RGB888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/src"></a>
<code>src</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit 3-channel interleaved source pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to vImage_Buffer that references 8-bit 3-channel interleaved destination pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap;   name=permuteMap -->
<a name="//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/permuteMap"></a>
<code>permuteMap</code>
</dt>
<dd><p>Values that can be used to switch the channel order of dest.
For exmaple, permuteMap[3] = {0, 1, 2} or NULL will produce the same dest pixels as the src.
permuteMap[3] = {2, 1, 0} is the reverse ordered dest pixels from the dest.
Any order of permuteMap is allowed when each permuteMap value is 0, 1, or 2.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImagePermuteChannels_RGB888/flags"></a>
<code>flags</code>
</dt>
<dd><pre> 
     kvImageDoNotTile            Disables internal multithreading, if any.
   </pre></dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<pre> 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width &lt; dest.width || src.height &lt; dest.height
  </pre>

<p>Works in place.
</p>


<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImagePermuteChannels_RGB888;name=start --><p>This function can be used to reorder 3 color channel buffer.
</p>
<p>The per-pixel operation is:
     </p>
<pre> 
 
     uint8_t *srcRow = src.data;
     uint8_t *destRow = dest.data;
 
     R = srcRow[permuteMap[0]];
     G = srcRow[permuteMap[1]];
     B = srcRow[permuteMap[2]];
     srcRow += 3;
 
     destRow[0] = R;
     destRow[1] = G;
     destRow[2] = B;
     destRow += 3;
    
      </pre>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImagePermuteChannels_RGB888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.10. Available in iOS v8.0.</dd>
</dl>
<p class="gapBeforeFooter">&nbsp;</p>
<hr class="afterFooter">
<div class="hd_copyright_and_timestamp">
<p class="hd_copyright">&copy; Copyright (c) 2003-2015 by Apple Inc. All rights reserved.

 </p>
<p class="hd_timestamp">Last Updated: Thursday, December 24, 2015
</p>
</div>
</td>
</tr></table>
</body>
</html>
