<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head>
<title>Convolution.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="HeaderDoc">
<meta name="xcode-display" content="render">
<style type="text/css"><!--.char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;}body {border: 0px; margin: 0px;}div {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}td {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}span.hd_tocAccessSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroupSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroup { display: block; font-weight: bold; font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; margin-left: 0px; padding-left: 40px; }span.hd_tocGroup + span.hd_tocAccess { padding-top: 5px; }td.toc_contents_text {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; }li.tocSubEntry {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}p {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}a:link {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:active {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}h2.h2tight { margin-top: 0px; padding-top: 0px; }h1 { margin-top: 13px; padding-top: 0px; }h4 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: tiny; font-weight: bold;}h5 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: 10.1pt; font-weight: bold;}pre {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666; font-size: 10pt;}pre a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}pre a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}body  {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt; padding-left: 0px; padding-top: 0px; margin-left: 0px; margin-top: 0px; border: none; }#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }.afterName { display: none; }.list_indent { margin-left: 40px; }.declaration_indent { margin-left: 40px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; min-height: 12px; vertical-align: middle; }.declaration_indent pre { margin-top: 20px; padding-top: 0px; margin-bottom: 20px; padding-bottom: 0px; }.gapBeforeFooter { display: none; }hr { height: 0px; min-height: 0px; border-top: none; border-left: none; border-right: none; border-bottom: 1px solid #909090;}hr.afterHeader { display: none }.param_group_indent { margin-left: 25px; }.param_indent { margin-left: 40px; margin-top: 0px; padding-top: 0px; }.param_indent dl { margin-top: 4px; padding-top: 0px; }dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.param_indent dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.group_indent { margin-left: 40px; }.group_desc_indent { margin-left: 20px; }.warning_indent { margin-left: 40px; }.important_indent { margin-left: 40px; }.note_indent { margin-left: 40px; }h3 {       color: #3C4C6C;}.tight {       margin-top: 2px; margin-bottom: 0px;       padding-top: 0px; padding-bottom: 0px;}h3 a {       color: #3C4C6C;	font-size: 16px;	font-style: normal;	font-variant: normal;	font-weight: bold;	height: 0px;	line-height: normal;}.hd_tocAccess { display: block; margin-left: 40px; font-style: italic; font-size: 10px; font-weight: normal; color: #303030; }.tocSubheading { margin-bottom: 4px; }--></style>
<style><!--
body {
    padding: 0px;
    margin: 0px;
    border: 0px;
}
.toc_contents_text {
    padding-left: 1em;
    text-indent: -1em;
}

ul.tocSubEntryList li.tocSubEntry {
    list-style: none;
}

#colorbox {
		display: none;
}
.spec_sheet_line {
		margin-bottom: 1px;
}
.collapsible {
		display: none;
}
.toc_leadspace {
		width: 10; min-width: 10;
}
.disclosure_triangle_td {
		width: 14; min-width: 14;
		font-size: 10px;
		vertical-align: middle;
}
.specbox td {
		font-size: 13px;
}
.specbox td a {
		font-size: 13px;
}
.specbox td code {
		font-size: 13px;
}
.specbox td tt {
		font-size: 13px;
}
.specbox td pre {
		font-size: 13px;
}
.specbox a {
		font-size: 12px;
}
.disclosure_triangle_td a {
		text-decoration: none;
}
.disclosure_triangle_td a:link {
		text-decoration: none;
}
.disclosure_triangle_td a:active {
		text-decoration: none;
}
.disclosure_triangle_td a:visited:hover {
		text-decoration: none;
}
.disclosure_triangle_td a:hover {
		text-decoration: none;
}
.hd_toc_box {
		padding-top: 10px;
		padding-right: 15px;
}.tocSeparator {
		margin-top: 15px;
		padding-bottom: 0px;
		margin-bottom: 0px;
}
.tocSubEntryList {
		margin-left: 0px;
		padding-left: 40px;
		padding-top: 0px;
		margin-top: 2px;
		padding-bottom: 0px;
		margin-bottom: 8px;
}
.hd_toc_heading_table {
		margin-top: 2px;
		margin-bottom: 2px;
}
.hd_toc_entry_table {
		margin-top: 2px;
		margin-bottom: 2px;
}
.tocSubEntry {
		margin-left: 0px;
		padding-left: 0px;
		margin-top: 0px;
		margin-bottom: 1px;
}
.tocSubEntry a {
		font-size: 10pt;
}
.tocSubheading {
		padding-left: 14px;
		margin-left: 0px;
		margin-top: 5px;
		padding-top: 0px;
		font-size: 16px;
		color: #808080;
}

#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }
#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }
#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }

#tocMenu {
		border-right: 1px solid #c0c0c0;
		background-color: #f4f4ff;
		top:0px;
		left:0px;
		width:230px;
		height:100%;
}
#bodyContents {
		width: auto;
		padding-left: 15px;
}
--></style>
<style id="disable_before_iOS_5"><!--
#tocMenu {
		position: fixed;
		height: 100%;
		overflow: auto;
}
#bodyContents {
		width: auto;
		left: 235px;
		right: 0;
		padding-left: 15px;
		position: fixed;
		height: 100%;
		overflow-y: scroll;
}
--></style>
<script language="JavaScript" type="text/javascript"><!--
    if (navigator.platform && (navigator.platform.match(/iPad/) || navigator.platform.match(/iPhone/) || navigator.platform.match(/iPod/))) {
        if (navigator.userAgent.match(/OS 1(_\d)+/) ||
            navigator.userAgent.match(/OS 2(_\d)+/) ||
            navigator.userAgent.match(/OS 3(_\d)+/) ||
            navigator.userAgent.match(/OS 4(_\d)+/)) {
                /* Earlier iOS versions require different scrolling gestures with position: fixed. */
                var del_style_elt = document.getElementById("disable_before_iOS_5");
                if (del_style_elt) del_style_elt.parentNode.removeChild(del_style_elt);
        }
    }
// --></script><script language="JavaScript" type="text/javascript"><!--
function getNewHTTPObject()
{
        var xmlhttp;

        /** Special IE only code ... */
        /*@cc_on
          @if (@_jscript_version >= 5)
              try
              {
                  xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');
              }
              catch (e)
              {
                  try
                  {
                      xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');
                  }
                  catch (E)
                  {
                      xmlhttp = false;
                  }
             }
          @else
             xmlhttp = false;
        @end @*/

        /** Every other browser on the planet */
        if (!xmlhttp && typeof XMLHttpRequest != 'undefined')
        {
            try
            {
                xmlhttp = new XMLHttpRequest();
            }
            catch (e)
            {
                xmlhttp = false;
            }
        }

        return xmlhttp;
}

function hidetoc() {
	var toc = document.getElementById('tocMenu');
	var src = toc.getAttribute('src');
	var xhr = getNewHTTPObject();
	xhr.open('GET', src, true);
	xhr.onreadystatechange = function() {
		if(xhr.readyState == 4) {
			var toc = document.getElementById('tocMenu');
			toc.innerHTML = xhr.responseText;
		}
	}
	xhr.send(null);
	var origURL = parent.document.URL;
	var contentURL = origURL.substring(origURL.indexOf('?')+1, origURL.length);
	if (contentURL.length == origURL.length) {
		jumpPos = origURL.substring(origURL.indexOf('#')+1, origURL.length);
	}
	if (contentURL == "hidetoc") {
		var body = document.getElementById('bodyContents');
		if (toc && body) {
			toc.style.display = 'none';
			body.style.marginLeft = '0px';
		}
	}
}

function disclosure_triangle(elt) {
   var linkelt = elt;
   while (elt && elt.tagName != 'TABLE') { elt = elt.parentNode;}
   if (!elt) { return; }
   while (elt && elt.tagName != 'DIV') { elt = elt.nextSibling;}
   if (!elt) { return; }
   if (parseInt(linkelt.getAttribute('state'))) {
      // It's open.  Close it
      linkelt.innerHTML = '&#x25B7;';
      linkelt.setAttribute('state', 0);
      linkelt.setAttribute('class', 'closed_disclosure_triangle');
      elt.style.display = 'none';
   } else {
      // It's closed.  Open it
      linkelt.innerHTML = '&#x25BC;';
      linkelt.setAttribute('state', 1);
      linkelt.setAttribute('class', 'open_disclosure_triangle');
      elt.style.display = 'block';
   }
}
--></script><style type="text/css"><!--.char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;}body {border: 0px; margin: 0px;}div {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}td {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}span.hd_tocAccessSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroupSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroup { display: block; font-weight: bold; font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; margin-left: 0px; padding-left: 40px; }span.hd_tocGroup + span.hd_tocAccess { padding-top: 5px; }td.toc_contents_text {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; }li.tocSubEntry {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}p {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}a:link {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:active {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}h2.h2tight { margin-top: 0px; padding-top: 0px; }h1 { margin-top: 13px; padding-top: 0px; }h4 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: tiny; font-weight: bold;}h5 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: 10.1pt; font-weight: bold;}pre {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666; font-size: 10pt;}pre a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}pre a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}body  {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt; padding-left: 0px; padding-top: 0px; margin-left: 0px; margin-top: 0px; border: none; }#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }.afterName { display: none; }.list_indent { margin-left: 40px; }.declaration_indent { margin-left: 40px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; min-height: 12px; vertical-align: middle; }.declaration_indent pre { margin-top: 20px; padding-top: 0px; margin-bottom: 20px; padding-bottom: 0px; }.gapBeforeFooter { display: none; }hr { height: 0px; min-height: 0px; border-top: none; border-left: none; border-right: none; border-bottom: 1px solid #909090;}hr.afterHeader { display: none }.param_group_indent { margin-left: 25px; }.param_indent { margin-left: 40px; margin-top: 0px; padding-top: 0px; }.param_indent dl { margin-top: 4px; padding-top: 0px; }dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.param_indent dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.group_indent { margin-left: 40px; }.group_desc_indent { margin-left: 20px; }.warning_indent { margin-left: 40px; }.important_indent { margin-left: 40px; }.note_indent { margin-left: 40px; }h3 {       color: #3C4C6C;}.tight {       margin-top: 2px; margin-bottom: 0px;       padding-top: 0px; padding-bottom: 0px;}h3 a {       color: #3C4C6C;	font-size: 16px;	font-style: normal;	font-variant: normal;	font-weight: bold;	height: 0px;	line-height: normal;}.hd_tocAccess { display: block; margin-left: 40px; font-style: italic; font-size: 10px; font-weight: normal; color: #303030; }.tocSubheading { margin-bottom: 4px; }--></style>
</head>
<body bgcolor="#ffffff" onload="hidetoc();">
<!-- headerDoc=Header;  uid=//apple_ref/doc/header/Convolution.h;   name=Convolution.h -->
<a name="//apple_ref/doc/header/Convolution.h"></a>
<table id="hd_outermost_table" height="100%" width="100%"><tr>
<td valign="top" id="tocMenu" src="toc.html"></td>
<td id="bodyContents" valign="top">
<a name="top"></a>
<h1><a name="Convolution.h">Convolution.h</a></h1>
<div class="spec_sheet_info_box"><table cellspacing="0" class="specbox"><tr>
<td scope="row"><b>Includes:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text">
<a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/header/vImage_Types.h" logicalPath="//apple_ref/doc/header/vImage_Types.h" target="_top">&lt;vImage/vImage_Types.h&gt;</a></div></div></td>
</tr></table></div>
<h2>Introduction</h2>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/doc/header/Convolution.h;name=start --><p>Convolution is a weighted average between a pixel and its neighboring pixels. By smoothing
out high frequency signal, convolution can be used to blur an image. By subtracting out the
low frequency signal, it can be used to produce a sharpening effect. Convolution is also used
with a variety of filters such as Laplace and Sobel to detect edges in the image. Here we also 
provide a deconvolution filter that attempts to iteratively undo the effect of a convolution. 
Where the convolution kernel can be accurately determined, it can be used to remove focus 
problems, motion blur and distortion introduced by the lens.
</p>
      <pre>
              =========================================================================
              ======    MOST VIMAGE CONVOLUTION FUNCTIONS DO NOT WORK IN PLACE    =====
              =========================================================================
       </pre>

<p>Since a weighted average of nearby pixels can for some positions extend off the edge of the
input image, a variety of edging modes are provided which specify what happens in such
cases:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually 
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0} 
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image. 
              
              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels. 
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content. 

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel 
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.
       </pre>
<p>Only one edging mode may be active at a time.  Please see the Convolution section in
the vImage Programming Guide for a better description of edging modes.
(https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/vImage.pdf)
</p>

<p>When calling these interfaces from within the context of your own tiling engine,
it may be necessary to produce a result tile starting from different points in the
input image. Simply repackaging the input image by adjusting the height, width and
src-&gt;data to achieve this affect will not work correctly because it introduces 
artificial edges into the input image. (See discussion of edging modes above.)
Instead, X and Y offset parameters are provided. Simply pass in the whole input image
and use the X and Y offsets to adjust the position of the content used to produce
the output image.  The size of the output tile is given by the dest-&gt;height and width.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/doc/header/Convolution.h;name=end --><!-- end discussion -->
<hr class="afterClassOrHeaderInfo">
<br><a name="HeaderDoc_groups"><h2 class="h2tight">Groups</h2></a>

<h3>Richardson-Lucy Deconvolution</h3>
<div class="group_desc_indent">
<p></p>
<p>Richardson-Lucy deconvolution (a.k.a. Lucy-Richardson) is an iterative procedure for estimating what an original image
probably was before a convolution, given the convolution end result and the kernel used to create it.  It is typically used to fix blurring caused
by lens distortion, most famously for the Hubble telescope, but also to improve images in confocal microscopy and other uses. When used
to correct loss of signal due to physical limitations of the imaging system, the point spread function (kernel) is estimated from known
parameters associated with the lensing system. It can also be used to sharpen images that have been digitally blurred, as long as the 
original convolution kernel is known or can be estimated.
</p>
<p>This routine iteratively uses the following formula:
      </p>
<pre>
		e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )

		where:
              e[0] = the observed image (src parameter)
              e[n] = the result of the nth iteration
              psf  = point spread function (kernel for call to convolution)
				x    = multiply operator
              '*'  = convolution operator
       </pre>
<p>As with any sharpening operation, Richardson-Lucy amplifies noise, and at some number of iterations the noise becomes noticeable as artifacts.
      </p>
<pre>
              =========================================================================
              ======    MOST VIMAGE CONVOLUTION FUNCTIONS DO NOT WORK IN PLACE    =====
              =========================================================================
       </pre>
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888" logicalPath="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888" target="_top">vImageRichardsonLucyDeConvolve_ARGB8888</a></tt></dt>
<dd><p>Perform N iterations of a Lucy-Richardson deconvolution on ARGB8888 data.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF" logicalPath="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF" target="_top">vImageRichardsonLucyDeConvolve_ARGBFFFF</a></tt></dt>
<dd><p>Perform N iterations of a Lucy-Richardson deconvolution on ARGBFFFF data
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8" logicalPath="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8" target="_top">vImageRichardsonLucyDeConvolve_Planar8</a></tt></dt>
<dd><p>Perform N iterations of a Lucy-Richardson deconvolution on Planar8 data
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF" logicalPath="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF" target="_top">vImageRichardsonLucyDeConvolve_PlanarF</a></tt></dt>
<dd><p>Perform N iterations of a Lucy-Richardson deconvolution on PlanarF data
</p></dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>General Convolution</h3>
<div class="group_desc_indent">
<p></p>
<p>A general convolve filter allows you to provide an arbitrary set of weights to use 
in the weighted average between each pixel and its neighbors. As such, it is a 
very flexible tool for achieving a variety of image effects, from blurring to sharpening
to edge detection to sub-pixel image translation and motion blur.  
</p>
<p>Some filters such as edge detection filters take the first derivative of the image 
surface. Since a derivative can be either positive or negative  and some formats such
as Planar8 (unorm8) can only represent positive numbers, the general convolution is also
available in a form which allows you to provide a bias to add to the weighted sum before
the divisor is applied, to shift the values into the positive.  You might provide a 
bias of 128 * divisor to move the encoding for 0 to 128 so that negative numbers are
representable, for example. (In this case, -20 would now be encoded as 128-20=108.)
</p>
<p>Finally, vImage provides multikernel convolution, which allows a different kernel, bias
and divisor to be used for each color channel. This might allow for the position of the
different color channels to be shifted independently, or for alpha to be blurred differently
from color.
      </p>
<pre>
              =========================================================================
              ======    MOST VIMAGE CONVOLUTION FUNCTIONS DO NOT WORK IN PLACE    =====
              =========================================================================
       </pre>
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolve_ARGB8888" logicalPath="//apple_ref/c/func/vImageConvolve_ARGB8888" target="_top">vImageConvolve_ARGB8888</a></tt></dt>
<dd><p>General convolution on a ARGB888 image of any channel order.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolve_ARGBFFFF" logicalPath="//apple_ref/c/func/vImageConvolve_ARGBFFFF" target="_top">vImageConvolve_ARGBFFFF</a></tt></dt>
<dd><p>General convolution on a ARGBFFFF image of any channel order.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolve_Planar8" logicalPath="//apple_ref/c/func/vImageConvolve_Planar8" target="_top">vImageConvolve_Planar8</a></tt></dt>
<dd><p>General convolution on a Planar8 image.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolve_PlanarF" logicalPath="//apple_ref/c/func/vImageConvolve_PlanarF" target="_top">vImageConvolve_PlanarF</a></tt></dt>
<dd><p>General convolution on a PlanarF image.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888" logicalPath="//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888" target="_top">vImageConvolveMultiKernel_ARGB8888</a></tt></dt>
<dd><p>General convolution on a ARGB8888 image of any channel order with separate bias, kernel and divisor for each channel.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF" logicalPath="//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF" target="_top">vImageConvolveMultiKernel_ARGBFFFF</a></tt></dt>
<dd><p>General convolution on a ARGBFFFF image of any channel order with separate bias and kernel for each channel.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveWithBias_ARGB8888" logicalPath="//apple_ref/c/func/vImageConvolveWithBias_ARGB8888" target="_top">vImageConvolveWithBias_ARGB8888</a></tt></dt>
<dd><p>General convolution on a ARGB888 image of any channel order with bias.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF" logicalPath="//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF" target="_top">vImageConvolveWithBias_ARGBFFFF</a></tt></dt>
<dd><p>General convolution on a ARGBFFFF image of any channel order with bias.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveWithBias_Planar8" logicalPath="//apple_ref/c/func/vImageConvolveWithBias_Planar8" target="_top">vImageConvolveWithBias_Planar8</a></tt></dt>
<dd><p>General convolution on a Planar8 image with added bias.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveWithBias_PlanarF" logicalPath="//apple_ref/c/func/vImageConvolveWithBias_PlanarF" target="_top">vImageConvolveWithBias_PlanarF</a></tt></dt>
<dd><p>General convolution on a PlanarF image with added bias.
</p></dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>Tent Convolve</h3>
<div class="group_desc_indent">
<p></p>
<p>A tent convolve is a special case of the standard convolution, which has a much faster algorithm.
A tent kernel is a kernel populated with slope of 1 rising towards the center. 2D kernels
are calculated as the product of the appropriate 1D kernels. e.g.
               </p>
<pre> 
                  {1,2,3,2,1}
                </pre>
<p>or 
               </p>
<pre> 
               |1|                { {1,2,1},
               |2| *  {1,2,1} =     {2,4,2},
               |1|                  {1,2,1}   }
                </pre>
<p>This returns a blur that is more heavily weighted towards the center pixel than a box blur.
</p>
<p>Unlike general purpose convolution, the cost of a tent convolve algorithm is theoretically constant 
regardless of kernel size, so it can be an inexpensive choice for very large blurs. The tent convolve 
behavior may not be as desired, however, because the blur effect is rectangular in appearance, whereas 
most expect a blurring effect to be gaussian or roughly circular. The rectangularity of the tent blur
is less obvious than the box blur.  A tent blur has somewhat larger constant cost than a box blur.
</p>
      <pre>
              =========================================================================
              ======    MOST VIMAGE CONVOLUTION FUNCTIONS DO NOT WORK IN PLACE    =====
              =========================================================================
       </pre>
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageTentConvolve_ARGB8888" logicalPath="//apple_ref/c/func/vImageTentConvolve_ARGB8888" target="_top">vImageTentConvolve_ARGB8888</a></tt></dt>
<dd><p>Special purpose tent convolution on a 4-channel interleaved, 8-bit per channel image.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageTentConvolve_Planar8" logicalPath="//apple_ref/c/func/vImageTentConvolve_Planar8" target="_top">vImageTentConvolve_Planar8</a></tt></dt>
<dd><p>Special purpose tent convolution on a Planar8 image.
</p></dd>
</dl>
</div>
<p>&nbsp;</p>
<h3>Box Convolve</h3>
<div class="group_desc_indent">
<p></p>
<p>A box convolve is a special case of the standard convolution, which has a much faster algorithm.
A box kernel is a kernel populated with all 1's. This returns the unweighted average of the pixels
near the result pixel. Unlike general purpose convolution, the cost of a box convolve algorithm
is theoretically constant regardless of kernel size, so it can be an inexpensive choice for very
large blurs. The box convolve behavior may not be as desired, however, because the blur effect is
rectangular in appearance, whereas most expect it to be gaussian or roughly circular. A tent blur has 
similar rectangular character, but because the weighting is non uniform, it is less obvious. A
tent blur is also constant cost per pixel, but larger constant cost.
</p>
<p>Two box blur passes of the same kernel size results in a tent blur.  To see this we can take a 1-d starting image:
                </p>
<pre> 
                      p0          p1          p2          p3          p4          p5          p6
                 </pre>
<p>and blur it once with a 3 wide box blur, ignoring for the moment what happens at the edges:
                </p>
<pre> 
                     (edge)    p0+p1+p2    p1+p2+p3    p2+p3+p4    p3+p4+p5    p4+p5+p6    p5+p6+p7
                 </pre>
<p>and a second time:
                </p>
<pre> 
                     (edge)           p0+2p1+3p2+2p3+p4       p2+2p3+3p4+2p5+p6       p4+2p5+3p6+2p7+p8 .....
                               (edge)             p1+2p2+3p3+2p4+p5       p3+2p4+3p5+2p6+p7
                 </pre>

<p>If this process is continued, the shape converges towards a gaussian over multiple passes.
      </p>
<pre>
              =========================================================================
              ======    MOST VIMAGE CONVOLUTION FUNCTIONS DO NOT WORK IN PLACE    =====
              =========================================================================
       </pre>
</div>
<h4>Group members:</h4>
<div class="group_indent">
<dl>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageBoxConvolve_ARGB8888" logicalPath="//apple_ref/c/func/vImageBoxConvolve_ARGB8888" target="_top">vImageBoxConvolve_ARGB8888</a></tt></dt>
<dd><p>Special purpose box convolution on a 4-channel interleaved, 8-bit per channel image.
</p></dd>
<dt><tt><a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageBoxConvolve_Planar8" logicalPath="//apple_ref/c/func/vImageBoxConvolve_Planar8" target="_top">vImageBoxConvolve_Planar8</a></tt></dt>
<dd><p>Special purpose box convolution on a Planar8 image.
</p></dd>
</dl>
</div>
<hr class="afterGroupHeading">
<a name="HeaderDoc_functions"></a>
<h2 class="h2tight">Functions</h2>
<dl>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageBoxConvolve_ARGB8888" target="_top">vImageBoxConvolve_ARGB8888</a></tt></dt>
<dd><p>Special purpose box convolution on a 4-channel interleaved, 8-bit per channel image.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageBoxConvolve_Planar8" target="_top">vImageBoxConvolve_Planar8</a></tt></dt>
<dd><p>Special purpose box convolution on a Planar8 image.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvolve_ARGB8888" target="_top">vImageConvolve_ARGB8888</a></tt></dt>
<dd><p>General convolution on a ARGB888 image of any channel order.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvolve_ARGBFFFF" target="_top">vImageConvolve_ARGBFFFF</a></tt></dt>
<dd><p>General convolution on a ARGBFFFF image of any channel order.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvolve_Planar8" target="_top">vImageConvolve_Planar8</a></tt></dt>
<dd><p>General convolution on a Planar8 image.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvolve_PlanarF" target="_top">vImageConvolve_PlanarF</a></tt></dt>
<dd><p>General convolution on a PlanarF image.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888" target="_top">vImageConvolveMultiKernel_ARGB8888</a></tt></dt>
<dd><p>General convolution on a ARGB8888 image of any channel order with separate bias, kernel and divisor for each channel.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF" target="_top">vImageConvolveMultiKernel_ARGBFFFF</a></tt></dt>
<dd><p>General convolution on a ARGBFFFF image of any channel order with separate bias and kernel for each channel.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvolveWithBias_ARGB8888" target="_top">vImageConvolveWithBias_ARGB8888</a></tt></dt>
<dd><p>General convolution on a ARGB888 image of any channel order with bias.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF" target="_top">vImageConvolveWithBias_ARGBFFFF</a></tt></dt>
<dd><p>General convolution on a ARGBFFFF image of any channel order with bias.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvolveWithBias_Planar8" target="_top">vImageConvolveWithBias_Planar8</a></tt></dt>
<dd><p>General convolution on a Planar8 image with added bias.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageConvolveWithBias_PlanarF" target="_top">vImageConvolveWithBias_PlanarF</a></tt></dt>
<dd><p>General convolution on a PlanarF image with added bias.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888" target="_top">vImageRichardsonLucyDeConvolve_ARGB8888</a></tt></dt>
<dd><p>Perform N iterations of a Lucy-Richardson deconvolution on ARGB8888 data.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF" target="_top">vImageRichardsonLucyDeConvolve_ARGBFFFF</a></tt></dt>
<dd><p>Perform N iterations of a Lucy-Richardson deconvolution on ARGBFFFF data
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8" target="_top">vImageRichardsonLucyDeConvolve_Planar8</a></tt></dt>
<dd><p>Perform N iterations of a Lucy-Richardson deconvolution on Planar8 data
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF" target="_top">vImageRichardsonLucyDeConvolve_PlanarF</a></tt></dt>
<dd><p>Perform N iterations of a Lucy-Richardson deconvolution on PlanarF data
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageTentConvolve_ARGB8888" target="_top">vImageTentConvolve_ARGB8888</a></tt></dt>
<dd><p>Special purpose tent convolution on a 4-channel interleaved, 8-bit per channel image.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/vImageTentConvolve_Planar8" target="_top">vImageTentConvolve_Planar8</a></tt></dt>
<dd><p>Special purpose tent convolution on a Planar8 image.
</p></dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageBoxConvolve_ARGB8888;   name=vImageBoxConvolve_ARGB8888 --><a name="//apple_ref/c/func/vImageBoxConvolve_ARGB8888"></a>
<h3><a name="vImageBoxConvolve_ARGB8888">vImageBoxConvolve_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageBoxConvolve_ARGB8888;name=start --><!-- begin abstract --></p>
<p>Special purpose box convolution on a 4-channel interleaved, 8-bit per channel image.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageBoxConvolve_ARGB8888;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageBoxConvolve_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageBoxConvolve_ARGB8888" logicalPath="//apple_ref/c/instm/vImageBoxConvolve_ARGB8888 //apple_ref/c/clm/vImageBoxConvolve_ARGB8888 //apple_ref/c/intfcm/vImageBoxConvolve_ARGB8888 //apple_ref/c/intfm/vImageBoxConvolve_ARGB8888 //apple_ref/c/func/vImageBoxConvolve_ARGB8888" target="_top"><span class="function">vImageBoxConvolve_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8888" logicalPath="//apple_ref/c/cl/Pixel_8888 //apple_ref/c/tdef/Pixel_8888" target="_top"><span class="type">Pixel_8888</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageBoxConvolve_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageLeaveAlphaUnchanged  Apply the convolution to the last three channels in memory, only.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageBoxConvolve_ARGB8888;name=start --><p>This filter applies a box filter to a 4-channel interleaved, 8-bit per channel imagee.
A box filter uses a much faster algorithm than a standard convolution, and may be a good
solution for real time application of large blur radii against images.
For each pixel:
      </p>
<pre>
          vImagePixelCount kernel_area = kernel_height * kernel_width;
          for each pixel[y][x] in image{
              int sumA = 0;
              int sumR = 0;
              int sumG = 0;
              int sumB = 0;

              // Calculate unweighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sumA += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
                               [x+j+srcOffsetToROI_X- kernel_width/2][0];
                  sumR += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
                               [x+j+srcOffsetToROI_X- kernel_width/2][1];
                  sumG += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
                               [x+j+srcOffsetToROI_X- kernel_width/2][2];
                  sumB += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
                               [x+j+srcOffsetToROI_X- kernel_width/2][3];
              }
              // Correct for the scaling introduced by multiplying by the weights table
              sumA = (sumA + kernel_area/2) / kernel_area;
              sumR = (sumR + kernel_area/2) / kernel_area;
              sumG = (sumG + kernel_area/2) / kernel_area;
              sumB = (sumB + kernel_area/2) / kernel_area;

              // write out result
              result[y][x][0] = CLAMP(sumA, 0, 255);
              result[y][x][1] = CLAMP(sumR, 0, 255);
              result[y][x][2] = CLAMP(sumG, 0, 255);
              result[y][x][3] = CLAMP(sumB, 0, 255);
          }
       </pre>

<p>This filter does not work in place.
</p>
<p>This filter will work without modification for other byte orders such as RGBA, BGRA, AGBR, CMYK, etc. 
The image should be non-premultiplied to avoid odd results in non-opaque regions.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageBoxConvolve_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageBoxConvolve_Planar8;   name=vImageBoxConvolve_Planar8 --><a name="//apple_ref/c/func/vImageBoxConvolve_Planar8"></a>
<h3><a name="vImageBoxConvolve_Planar8">vImageBoxConvolve_Planar8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageBoxConvolve_Planar8;name=start --><!-- begin abstract --></p>
<p>Special purpose box convolution on a Planar8 image.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageBoxConvolve_Planar8;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageBoxConvolve_Planar8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageBoxConvolve_Planar8" logicalPath="//apple_ref/c/instm/vImageBoxConvolve_Planar8 //apple_ref/c/clm/vImageBoxConvolve_Planar8 //apple_ref/c/intfcm/vImageBoxConvolve_Planar8 //apple_ref/c/intfm/vImageBoxConvolve_Planar8 //apple_ref/c/func/vImageBoxConvolve_Planar8" target="_top"><span class="function">vImageBoxConvolve_Planar8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8" logicalPath="//apple_ref/c/cl/Pixel_8 //apple_ref/c/tdef/Pixel_8" target="_top"><span class="type">Pixel_8</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageBoxConvolve_Planar8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageBoxConvolve_Planar8/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageBoxConvolve_Planar8;name=start --><p>This filter applies a box filter to a Planar8 image.  A box filter uses a much faster algorithm
than a standard convolution, and may be a good solution for real time application of large blur
radii against images.
For each pixel:
      </p>
<pre>
          vImagePixelCount kernel_area = kernel_height * kernel_width;
          for each pixel[y][x] in image{
              int sum = 0;

              // Calculate unweighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sum += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
                              [x+j+srcOffsetToROI_X- kernel_width/2];
              }
              // Correct for the scaling introduced by multiplying by the weights table
              sum = (sum + kernel_area/2) / kernel_area;

              // write out result
              result[y][x] = CLAMP(sum, 0, 255);
          }
       </pre>

<p>This filter does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageBoxConvolve_Planar8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvolve_ARGB8888;   name=vImageConvolve_ARGB8888 --><a name="//apple_ref/c/func/vImageConvolve_ARGB8888"></a>
<h3><a name="vImageConvolve_ARGB8888">vImageConvolve_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolve_ARGB8888;name=start --><!-- begin abstract --></p>
<p>General convolution on a ARGB888 image of any channel order.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolve_ARGB8888;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolve_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolve_ARGB8888" logicalPath="//apple_ref/c/instm/vImageConvolve_ARGB8888 //apple_ref/c/clm/vImageConvolve_ARGB8888 //apple_ref/c/intfcm/vImageConvolve_ARGB8888 //apple_ref/c/intfm/vImageConvolve_ARGB8888 //apple_ref/c/func/vImageConvolve_ARGB8888" target="_top"><span class="function">vImageConvolve_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int16_t //apple_ref/c/tdef/int16_t //apple_ref/c/tag/int16_t //apple_ref/c/struct/int16_t //apple_ref/c/intf/int16_t //apple_ref/doc/anysymbol/int16_t" machineGenerated="true" --><span class="type">int16_t</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">divisor</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8888" logicalPath="//apple_ref/c/cl/Pixel_8888 //apple_ref/c/tdef/Pixel_8888" target="_top"><span class="type">Pixel_8888</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolve_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const int16_t kernel[9] = { 1, 2, 1,
                                                      2, 4, 2,
                                                      1, 2, 1 };
                           </pre>

<p>The kernel values may not sum in any combination to be outside the range
[-2**23, 2**23), or modulo overflow in the accumulator may result.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/divisor;   name=divisor -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/divisor"></a>
<code>divisor</code>
</dt>
<dd><p>The weighted sum of nearby pixels is typically a large number, which must be corrected
to fit back into the image format of the destination image. The correction factor
is passed in as divisor here, and is divided from the sum before the result is
returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
is 0, 1 will be used instead.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolve_ARGB8888;name=start --><p>This filter applies a convolution filter of your choosing to a ARGB8888 image.
This filter will work on any four-channel, 8-bit per component image format, not just ARGB.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              int sumA = 0;
              int sumR = 0;
              int sumG = 0;
              int sumB = 0;

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sumA += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][0];
                  sumR += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][1];
                  sumG += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][2];
                  sumB += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][3];
              }
              // Correct for the scaling introduced by multiplying by the weights table
              sumA = (sumA + divisor/2) / divisor;
              sumR = (sumR + divisor/2) / divisor;
              sumG = (sumG + divisor/2) / divisor;
              sumB = (sumB + divisor/2) / divisor;

              // write out result
              result[y][x][0] = CLAMP(sumA, 0, 255);
              result[y][x][1] = CLAMP(sumR, 0, 255);
              result[y][x][2] = CLAMP(sumG, 0, 255);
              result[y][x][3] = CLAMP(sumB, 0, 255);
          }
       </pre>
<p>(Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
However, in practice it is passed in as a contiguous 1D array of size kernel_height *
kernel_width.)
</p>
<p>This filter does not work in place.
</p>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolve_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvolve_ARGBFFFF;   name=vImageConvolve_ARGBFFFF --><a name="//apple_ref/c/func/vImageConvolve_ARGBFFFF"></a>
<h3><a name="vImageConvolve_ARGBFFFF">vImageConvolve_ARGBFFFF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolve_ARGBFFFF;name=start --><!-- begin abstract --></p>
<p>General convolution on a ARGBFFFF image of any channel order.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolve_ARGBFFFF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolve_ARGBFFFF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolve_ARGBFFFF" logicalPath="//apple_ref/c/instm/vImageConvolve_ARGBFFFF //apple_ref/c/clm/vImageConvolve_ARGBFFFF //apple_ref/c/intfcm/vImageConvolve_ARGBFFFF //apple_ref/c/intfm/vImageConvolve_ARGBFFFF //apple_ref/c/func/vImageConvolve_ARGBFFFF" target="_top"><span class="function">vImageConvolve_ARGBFFFF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_FFFF" logicalPath="//apple_ref/c/cl/Pixel_FFFF //apple_ref/c/tdef/Pixel_FFFF" target="_top"><span class="type">Pixel_FFFF</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolve_ARGBFFFF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const float kernel[9] =   { 1./16, 2./16, 1./16,
                                                      2./16, 4./16, 2./16,
                                                      1./16, 2./16, 1./16 };
                           </pre>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_ARGBFFFF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolve_ARGBFFFF;name=start --><p>This filter applies a convolution filter of your choosing to a ARGBFFFF image.
This filter will work on any four-channel, float per component image format, not just ARGB.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              float sumA = 0;
              float sumR = 0;
              float sumG = 0;
              float sumB = 0;

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sumA += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][0];
                  sumR += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][1];
                  sumG += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][2];
                  sumB += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][3];
              }

              // write out result
              result[y][x][0] = sumA;
              result[y][x][1] = sumR;
              result[y][x][2] = sumG;
              result[y][x][3] = sumB;
          }
       </pre>
<p>(Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
However, in practice it is passed in as a contiguous 1D array of size kernel_height *
kernel_width.)
</p>
<p>This filter does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolve_ARGBFFFF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvolve_Planar8;   name=vImageConvolve_Planar8 --><a name="//apple_ref/c/func/vImageConvolve_Planar8"></a>
<h3><a name="vImageConvolve_Planar8">vImageConvolve_Planar8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolve_Planar8;name=start --><!-- begin abstract --></p>
<p>General convolution on a Planar8 image.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolve_Planar8;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolve_Planar8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolve_Planar8" logicalPath="//apple_ref/c/instm/vImageConvolve_Planar8 //apple_ref/c/clm/vImageConvolve_Planar8 //apple_ref/c/intfcm/vImageConvolve_Planar8 //apple_ref/c/intfm/vImageConvolve_Planar8 //apple_ref/c/func/vImageConvolve_Planar8" target="_top"><span class="function">vImageConvolve_Planar8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int16_t //apple_ref/c/tdef/int16_t //apple_ref/c/tag/int16_t //apple_ref/c/struct/int16_t //apple_ref/c/intf/int16_t //apple_ref/doc/anysymbol/int16_t" machineGenerated="true" --><span class="type">int16_t</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">divisor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8" logicalPath="//apple_ref/c/cl/Pixel_8 //apple_ref/c/tdef/Pixel_8" target="_top"><span class="type">Pixel_8</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolve_Planar8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const int16_t kernel[9] = { 1, 2, 1,
                                                      2, 4, 2,
                                                      1, 2, 1 };
                           </pre>

<p>The kernel values may not sum in any combination to be outside the range
[-2**23, 2**23), or modulo overflow in the accumulator may result.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/divisor;   name=divisor -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/divisor"></a>
<code>divisor</code>
</dt>
<dd><p>The weighted sum of nearby pixels is typically a large number, which must be corrected
to fit back into the image format of the destination image. The correction factor 
is passed in as divisor here, and is divided from the sum before the result is 
returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
is 0, 1 will be used instead.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the 
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_Planar8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_Planar8/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of 
                                      the temp buffer to use with this function and this set of 
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided: 
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal 
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolve_Planar8;name=start --><p>This filter applies a convolution filter of your choosing to a Planar8 image. 
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              int sum = 0;
              
              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sum += kernel_element[i][j] * 
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
                               [x+j+srcOffsetToROI_X- kernel_width/2];
              }
              // Correct for the scaling introduced by multiplying by the weights table
              sum = (sum + divisor/2) / divisor;

              // write out result
              result[y][x] = CLAMP(sum, 0, 255);
          }
       </pre>
<p>(Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
However, in practice it is passed in as a contiguous 1D array of size kernel_height *
kernel_width.)
</p>
<p>This filter does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolve_Planar8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvolve_PlanarF;   name=vImageConvolve_PlanarF --><a name="//apple_ref/c/func/vImageConvolve_PlanarF"></a>
<h3><a name="vImageConvolve_PlanarF">vImageConvolve_PlanarF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolve_PlanarF;name=start --><!-- begin abstract --></p>
<p>General convolution on a PlanarF image.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolve_PlanarF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolve_PlanarF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolve_PlanarF" logicalPath="//apple_ref/c/instm/vImageConvolve_PlanarF //apple_ref/c/clm/vImageConvolve_PlanarF //apple_ref/c/intfcm/vImageConvolve_PlanarF //apple_ref/c/intfm/vImageConvolve_PlanarF //apple_ref/c/func/vImageConvolve_PlanarF" target="_top"><span class="function">vImageConvolve_PlanarF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_F" logicalPath="//apple_ref/c/cl/Pixel_F //apple_ref/c/tdef/Pixel_F" target="_top"><span class="type">Pixel_F</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolve_PlanarF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_PlanarF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_PlanarF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_PlanarF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_PlanarF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_PlanarF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_PlanarF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_PlanarF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_PlanarF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_PlanarF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_PlanarF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_PlanarF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_PlanarF/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const float kernel[9] =   { 1./16, 2./16, 1./16,
                                                      2./16, 4./16, 2./16,
                                                      1./16, 2./16, 1./16 };
                           </pre>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_PlanarF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_PlanarF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_PlanarF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_PlanarF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_PlanarF/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_PlanarF/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolve_PlanarF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvolve_PlanarF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolve_PlanarF;name=start --><p>This filter applies a convolution filter of your choosing to a PlanarF image.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              float sum = 0;

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sum += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
                               [x+j+srcOffsetToROI_X- kernel_width/2];
              }

              // write out result
              result[y][x] = sum;
          }
       </pre>
<p>(Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
However, in practice it is passed in as a contiguous 1D array of size kernel_height *
kernel_width.)
</p>
<p>This filter does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolve_PlanarF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.3. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888;   name=vImageConvolveMultiKernel_ARGB8888 --><a name="//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888"></a>
<h3><a name="vImageConvolveMultiKernel_ARGB8888">vImageConvolveMultiKernel_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888;name=start --><!-- begin abstract --></p>
<p>General convolution on a ARGB8888 image of any channel order with separate bias, kernel and divisor for each channel.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888" logicalPath="//apple_ref/c/instm/vImageConvolveMultiKernel_ARGB8888 //apple_ref/c/clm/vImageConvolveMultiKernel_ARGB8888 //apple_ref/c/intfcm/vImageConvolveMultiKernel_ARGB8888 //apple_ref/c/intfm/vImageConvolveMultiKernel_ARGB8888 //apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888" target="_top"><span class="function">vImageConvolveMultiKernel_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>, 
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>, 
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>, 
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>, 
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>, 
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int16_t //apple_ref/c/tdef/int16_t //apple_ref/c/tag/int16_t //apple_ref/c/struct/int16_t //apple_ref/c/intf/int16_t //apple_ref/doc/anysymbol/int16_t" machineGenerated="true" --><span class="type">int16_t</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//apple_ref/c/cl/kernels //apple_ref/c/tdef/kernels //apple_ref/c/tag/kernels //apple_ref/c/struct/kernels //apple_ref/c/intf/kernels //apple_ref/doc/anysymbol/kernels" machineGenerated="true" --><span class="type">kernels</span><!-- /a -->[<span class="number">4</span>], 
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>, 
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>, 
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/cl/divisors //apple_ref/c/tdef/divisors //apple_ref/c/tag/divisors //apple_ref/c/struct/divisors //apple_ref/c/intf/divisors //apple_ref/doc/anysymbol/divisors" machineGenerated="true" --><span class="type">divisors</span><!-- /a -->[<span class="number">4</span>], 
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/cl/biases //apple_ref/c/tdef/biases //apple_ref/c/tag/biases //apple_ref/c/struct/biases //apple_ref/c/intf/biases //apple_ref/doc/anysymbol/biases" machineGenerated="true" --><span class="type">biases</span><!-- /a -->[<span class="number">4</span>], 
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8888" logicalPath="//apple_ref/c/cl/Pixel_8888 //apple_ref/c/tdef/Pixel_8888" target="_top"><span class="type">Pixel_8888</span></a> <span class="param">backgroundColor</span>, 
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/kernel"></a>
<code>kernel</code>
</dt>
<dd><p>An array of 4 pointers to weights of dimension kernel_height x kernel_width.
The kernel values in each array may not sum in any combination to be outside the range
[-2**23, 2**23), or modulo overflow in the accumulator may result.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/divisor;   name=divisor -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/divisor"></a>
<code>divisor</code>
</dt>
<dd><p>The weighted sum of nearby pixels is typically a large number, which must be corrected
to fit back into the image format of the destination image. The correction factor
is passed in as divisor here, and is divided from the sum before the result is
returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
is 0, 1 will be used instead.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/bias;   name=bias -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/bias"></a>
<code>bias</code>
</dt>
<dd><p>This array of values is added to the sum of weighted pixels for each channel respectively
before the divisor is applied. It can serve to both control rounding and adjust the 
brightness of the result. A large bias (e.g 128 * divisor) may be required for some 
kernels, such as edge detection filters, to return representable results.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888;name=start --><p>This filter applies a convolution filter of your choosing to a ARGB8888 image.
This filter will work on any four-channel, 8-bit per component image format, not just ARGB.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              int sumA = 0;
              int sumR = 0;
              int sumG = 0;
              int sumB = 0;
				const int16_t *kA = kernel[0];
				const int16_t *kR = kernel[1];
				const int16_t *kG = kernel[2];
				const int16_t *kB = kernel[3];

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sumA += kA[i*kernel_width+j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][0];
                  sumR += kR[i*kernel_width+j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][1];
                  sumG += kG[i*kernel_width+j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][2];
                  sumB += kB[i*kernel_width+j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][3];
              }
              // Correct for the scaling introduced by multiplying by the weights table
              sumA = (sumA + bias[0]) / divisor[0];
              sumR = (sumR + bias[1]) / divisor[1];
              sumG = (sumG + bias[2]) / divisor[2];
              sumB = (sumB + bias[3]) / divisor[3];

              // write out result
              result[y][x][0] = CLAMP(sumA, 0, 255);
              result[y][x][1] = CLAMP(sumR, 0, 255);
              result[y][x][2] = CLAMP(sumG, 0, 255);
              result[y][x][3] = CLAMP(sumB, 0, 255);
          }
       </pre>
<p>(Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
However, in practice it is passed in as a contiguous 1D array of size kernel_height *
kernel_width.)
</p>
<p>This filter does not work in place.
</p>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF;   name=vImageConvolveMultiKernel_ARGBFFFF --><a name="//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF"></a>
<h3><a name="vImageConvolveMultiKernel_ARGBFFFF">vImageConvolveMultiKernel_ARGBFFFF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF;name=start --><!-- begin abstract --></p>
<p>General convolution on a ARGBFFFF image of any channel order with separate bias and kernel for each channel.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF" logicalPath="//apple_ref/c/instm/vImageConvolveMultiKernel_ARGBFFFF //apple_ref/c/clm/vImageConvolveMultiKernel_ARGBFFFF //apple_ref/c/intfcm/vImageConvolveMultiKernel_ARGBFFFF //apple_ref/c/intfm/vImageConvolveMultiKernel_ARGBFFFF //apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF" target="_top"><span class="function">vImageConvolveMultiKernel_ARGBFFFF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>, 
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>, 
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>, 
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>, 
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>, 
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//apple_ref/c/cl/kernels //apple_ref/c/tdef/kernels //apple_ref/c/tag/kernels //apple_ref/c/struct/kernels //apple_ref/c/intf/kernels //apple_ref/doc/anysymbol/kernels" machineGenerated="true" --><span class="type">kernels</span><!-- /a -->[<span class="number">4</span>], 
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>, 
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>, 
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/cl/biases //apple_ref/c/tdef/biases //apple_ref/c/tag/biases //apple_ref/c/struct/biases //apple_ref/c/intf/biases //apple_ref/doc/anysymbol/biases" machineGenerated="true" --><span class="type">biases</span><!-- /a -->[<span class="number">4</span>], 
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_FFFF" logicalPath="//apple_ref/c/cl/Pixel_FFFF //apple_ref/c/tdef/Pixel_FFFF" target="_top"><span class="type">Pixel_FFFF</span></a> <span class="param">backgroundColor</span>, 
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const float kernel[9] =   { 1./16, 2./16, 1./16,
                                                      2./16, 4./16, 2./16,
                                                      1./16, 2./16, 1./16 };
                           </pre>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/bias;   name=bias -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/bias"></a>
<code>bias</code>
</dt>
<dd><p>This value is added to the sum of weighted pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvolveMultiKernel_ARGBFFFF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF;name=start --><p>This filter applies a convolution filter of your choosing to a ARGBFFFF image.
This filter will work on any four-channel, float per component image format, not just ARGB.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              float sumA = bias[0];
              float sumR = bias[1];
              float sumG = bias[2];
              float sumB = bias[3];
				const float *kA = kernel[0];
				const float *kR = kernel[1];
				const float *kG = kernel[2];
				const float *kB = kernel[3];

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sumA += kA[i*kernel_width+j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][0];
                  sumR += kR[i*kernel_width+j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][1];
                  sumG += kG[i*kernel_width+j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][2];
                  sumB += kB[i*kernel_width+j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][3];
              }

              // write out result
              result[y][x][0] = sumA;
              result[y][x][1] = sumR;
              result[y][x][2] = sumG;
              result[y][x][3] = sumB;
          }
       </pre>
<p>(Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
However, in practice it is passed in as a contiguous 1D array of size kernel_height *
kernel_width.)
</p>
<p>This filter does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvolveWithBias_ARGB8888;   name=vImageConvolveWithBias_ARGB8888 --><a name="//apple_ref/c/func/vImageConvolveWithBias_ARGB8888"></a>
<h3><a name="vImageConvolveWithBias_ARGB8888">vImageConvolveWithBias_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGB8888;name=start --><!-- begin abstract --></p>
<p>General convolution on a ARGB888 image of any channel order with bias.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGB8888;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveWithBias_ARGB8888" logicalPath="//apple_ref/c/instm/vImageConvolveWithBias_ARGB8888 //apple_ref/c/clm/vImageConvolveWithBias_ARGB8888 //apple_ref/c/intfcm/vImageConvolveWithBias_ARGB8888 //apple_ref/c/intfm/vImageConvolveWithBias_ARGB8888 //apple_ref/c/func/vImageConvolveWithBias_ARGB8888" target="_top"><span class="function">vImageConvolveWithBias_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int16_t //apple_ref/c/tdef/int16_t //apple_ref/c/tag/int16_t //apple_ref/c/struct/int16_t //apple_ref/c/intf/int16_t //apple_ref/doc/anysymbol/int16_t" machineGenerated="true" --><span class="type">int16_t</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">divisor</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">bias</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8888" logicalPath="//apple_ref/c/cl/Pixel_8888 //apple_ref/c/tdef/Pixel_8888" target="_top"><span class="type">Pixel_8888</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const int16_t kernel[9] = { 1, 2, 1,
                                                      2, 4, 2,
                                                      1, 2, 1 };
                           </pre>

<p>The kernel values may not sum in any combination to be outside the range
[-2**23, 2**23), or modulo overflow in the accumulator may result.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/divisor;   name=divisor -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/divisor"></a>
<code>divisor</code>
</dt>
<dd><p>The weighted sum of nearby pixels is typically a large number, which must be corrected
to fit back into the image format of the destination image. The correction factor
is passed in as divisor here, and is divided from the sum before the result is
returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
is 0, 1 will be used instead.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/bias;   name=bias -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/bias"></a>
<code>bias</code>
</dt>
<dd><p>This value is added to the sum of weighted pixels before the divisor is applied.
It can serve to both control rounding and adjust the brightness of the result.
A large bias (e.g 128 * divisor) may be required for some kernels, such as edge 
detection filters, to return representable results.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGB8888;name=start --><p>This filter applies a convolution filter of your choosing to a ARGB8888 image.
This filter will work on any four-channel, 8-bit per component image format, not just ARGB.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              int sumA = 0;
              int sumR = 0;
              int sumG = 0;
              int sumB = 0;

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sumA += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][0];
                  sumR += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][1];
                  sumG += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][2];
                  sumB += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][3];
              }
              // Correct for the scaling introduced by multiplying by the weights table
              sumA = (sumA + bias[0]) / divisor;
              sumR = (sumR + bias[1]) / divisor;
              sumG = (sumG + bias[2]) / divisor;
              sumB = (sumB + bias[3]) / divisor;

              // write out result
              result[y][x][0] = CLAMP(sumA, 0, 255);
              result[y][x][1] = CLAMP(sumR, 0, 255);
              result[y][x][2] = CLAMP(sumG, 0, 255);
              result[y][x][3] = CLAMP(sumB, 0, 255);
          }
       </pre>
<p>(Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
However, in practice it is passed in as a contiguous 1D array of size kernel_height *
kernel_width.)
</p>
<p>This filter does not work in place.
</p>

<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF;   name=vImageConvolveWithBias_ARGBFFFF --><a name="//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF"></a>
<h3><a name="vImageConvolveWithBias_ARGBFFFF">vImageConvolveWithBias_ARGBFFFF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF;name=start --><!-- begin abstract --></p>
<p>General convolution on a ARGBFFFF image of any channel order with bias.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF" logicalPath="//apple_ref/c/instm/vImageConvolveWithBias_ARGBFFFF //apple_ref/c/clm/vImageConvolveWithBias_ARGBFFFF //apple_ref/c/intfcm/vImageConvolveWithBias_ARGBFFFF //apple_ref/c/intfm/vImageConvolveWithBias_ARGBFFFF //apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF" target="_top"><span class="function">vImageConvolveWithBias_ARGBFFFF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="param">bias</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_FFFF" logicalPath="//apple_ref/c/cl/Pixel_FFFF //apple_ref/c/tdef/Pixel_FFFF" target="_top"><span class="type">Pixel_FFFF</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const float kernel[9] =   { 1./16, 2./16, 1./16,
                                                      2./16, 4./16, 2./16,
                                                      1./16, 2./16, 1./16 };
                           </pre>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/bias;   name=bias -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/bias"></a>
<code>bias</code>
</dt>
<dd><p>This value is added to the sum of weighted pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_ARGBFFFF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF;name=start --><p>This filter applies a convolution filter of your choosing to a ARGBFFFF image.
This filter will work on any four-channel, float per component image format, not just ARGB.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              float sumA = bias[0];
              float sumR = bias[1];
              float sumG = bias[2];
              float sumB = bias[3];

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sumA += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][0];
                  sumR += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][1];
                  sumG += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][2];
                  sumB += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][3];
              }

              // write out result
              result[y][x][0] = sumA;
              result[y][x][1] = sumR;
              result[y][x][2] = sumG;
              result[y][x][3] = sumB;
          }
       </pre>
<p>(Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
However, in practice it is passed in as a contiguous 1D array of size kernel_height *
kernel_width.)
</p>
<p>This filter does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvolveWithBias_Planar8;   name=vImageConvolveWithBias_Planar8 --><a name="//apple_ref/c/func/vImageConvolveWithBias_Planar8"></a>
<h3><a name="vImageConvolveWithBias_Planar8">vImageConvolveWithBias_Planar8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveWithBias_Planar8;name=start --><!-- begin abstract --></p>
<p>General convolution on a Planar8 image with added bias.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveWithBias_Planar8;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveWithBias_Planar8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveWithBias_Planar8" logicalPath="//apple_ref/c/instm/vImageConvolveWithBias_Planar8 //apple_ref/c/clm/vImageConvolveWithBias_Planar8 //apple_ref/c/intfcm/vImageConvolveWithBias_Planar8 //apple_ref/c/intfm/vImageConvolveWithBias_Planar8 //apple_ref/c/func/vImageConvolveWithBias_Planar8" target="_top"><span class="function">vImageConvolveWithBias_Planar8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int16_t //apple_ref/c/tdef/int16_t //apple_ref/c/tag/int16_t //apple_ref/c/struct/int16_t //apple_ref/c/intf/int16_t //apple_ref/doc/anysymbol/int16_t" machineGenerated="true" --><span class="type">int16_t</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">divisor</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">bias</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8" logicalPath="//apple_ref/c/cl/Pixel_8 //apple_ref/c/tdef/Pixel_8" target="_top"><span class="type">Pixel_8</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveWithBias_Planar8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const int16_t kernel[9] = { 1, 2, 1,
                                                      2, 4, 2,
                                                      1, 2, 1 };
                           </pre>

<p>The kernel values may not sum in any combination to be outside the range
[-2**23, 2**23), or modulo overflow in the accumulator may result.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/divisor;   name=divisor -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/divisor"></a>
<code>divisor</code>
</dt>
<dd><p>The weighted sum of nearby pixels is typically a large number, which must be corrected
to fit back into the image format of the destination image. The correction factor
is passed in as divisor here, and is divided from the sum before the result is
returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
is 0, 1 will be used instead.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/bias;   name=bias -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/bias"></a>
<code>bias</code>
</dt>
<dd><p>This value is added to the sum of weighted pixels before the divisor is applied.
It can serve to both control rounding and adjust the brightness of the result.
A large bias (e.g 128 * divisor) may be required for some kernels to return
representable results, such as edge detection filters.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_Planar8/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveWithBias_Planar8;name=start --><p>This filter applies a convolution filter of your choosing to a Planar8 image.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              int sum = 0;

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sum += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
                               [x+j+srcOffsetToROI_X- kernel_width/2];
              }
              // Correct for the scaling introduced by multiplying by the weights table
              sum = (sum + bias) / divisor;

              // write out result
              result[y][x] = CLAMP(sum, 0, 255);
          }
       </pre>
<p>(Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
However, in practice it is passed in as a contiguous 1D array of size kernel_height *
kernel_width.)
</p>
<p>This filter does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveWithBias_Planar8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageConvolveWithBias_PlanarF;   name=vImageConvolveWithBias_PlanarF --><a name="//apple_ref/c/func/vImageConvolveWithBias_PlanarF"></a>
<h3><a name="vImageConvolveWithBias_PlanarF">vImageConvolveWithBias_PlanarF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveWithBias_PlanarF;name=start --><!-- begin abstract --></p>
<p>General convolution on a PlanarF image with added bias.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageConvolveWithBias_PlanarF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveWithBias_PlanarF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageConvolveWithBias_PlanarF" logicalPath="//apple_ref/c/instm/vImageConvolveWithBias_PlanarF //apple_ref/c/clm/vImageConvolveWithBias_PlanarF //apple_ref/c/intfcm/vImageConvolveWithBias_PlanarF //apple_ref/c/intfm/vImageConvolveWithBias_PlanarF //apple_ref/c/func/vImageConvolveWithBias_PlanarF" target="_top"><span class="function">vImageConvolveWithBias_PlanarF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="param">bias</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_F" logicalPath="//apple_ref/c/cl/Pixel_F //apple_ref/c/tdef/Pixel_F" target="_top"><span class="type">Pixel_F</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageConvolveWithBias_PlanarF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const float kernel[9] =   { 1./16, 2./16, 1./16,
                                                      2./16, 4./16, 2./16,
                                                      1./16, 2./16, 1./16 };
                           </pre>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/bias;   name=bias -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/bias"></a>
<code>bias</code>
</dt>
<dd><p>This value is added to the sum of weighted pixels.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageConvolveWithBias_PlanarF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveWithBias_PlanarF;name=start --><p>This filter applies a convolution filter of your choosing to a PlanarF image.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              float sum = bias;

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sum += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
                               [x+j+srcOffsetToROI_X- kernel_width/2];
              }

              // write out result
              result[y][x] = sum;
          }
       </pre>
<p>(Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
However, in practice it is passed in as a contiguous 1D array of size kernel_height *
kernel_width.)
</p>
<p>This filter does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageConvolveWithBias_PlanarF;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888;   name=vImageRichardsonLucyDeConvolve_ARGB8888 --><a name="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888"></a>
<h3><a name="vImageRichardsonLucyDeConvolve_ARGB8888">vImageRichardsonLucyDeConvolve_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888;name=start --><!-- begin abstract --></p>
<p>Perform N iterations of a Lucy-Richardson deconvolution on ARGB8888 data.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888" logicalPath="//apple_ref/c/instm/vImageRichardsonLucyDeConvolve_ARGB8888 //apple_ref/c/clm/vImageRichardsonLucyDeConvolve_ARGB8888 //apple_ref/c/intfcm/vImageRichardsonLucyDeConvolve_ARGB8888 //apple_ref/c/intfm/vImageRichardsonLucyDeConvolve_ARGB8888 //apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888" target="_top"><span class="function">vImageRichardsonLucyDeConvolve_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int16_t //apple_ref/c/tdef/int16_t //apple_ref/c/tag/int16_t //apple_ref/c/struct/int16_t //apple_ref/c/intf/int16_t //apple_ref/doc/anysymbol/int16_t" machineGenerated="true" --><span class="type">int16_t</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int16_t //apple_ref/c/tdef/int16_t //apple_ref/c/tag/int16_t //apple_ref/c/struct/int16_t //apple_ref/c/intf/int16_t //apple_ref/doc/anysymbol/int16_t" machineGenerated="true" --><span class="type">int16_t</span><!-- /a --> <span class="type">*</span><span class="param">kernel2</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height2</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width2</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">divisor</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">divisor2</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8888" logicalPath="//apple_ref/c/cl/Pixel_8888 //apple_ref/c/tdef/Pixel_8888" target="_top"><span class="type">Pixel_8888</span></a> <span class="param">backgroundColor</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">iterationCount</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const int16_t kernel[9] = { 1, 2, 1,
                                                      2, 4, 2,
                                                      1, 2, 1 };
                           </pre>

<p>This is psf0 in the formula given in the discussion.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel2;   name=kernel2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel2"></a>
<code>kernel2</code>
</dt>
<dd><p>A pointer to a second 1D array of weights of dimension kernel_height2 x kernel_width2.
This is psf1 in the formula given in the discussion.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel1. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel1. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel_height2;   name=kernel_height2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel_height2"></a>
<code>kernel_height2</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel2. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel_width2;   name=kernel_width2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/kernel_width2"></a>
<code>kernel_width2</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel2. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/divisor;   name=divisor -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/divisor"></a>
<code>divisor</code>
</dt>
<dd><p>The divisor to use to correct for the volume under kernel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/divisor2;   name=divisor2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/divisor2"></a>
<code>divisor2</code>
</dt>
<dd><p>The divisor to use to correct for the volume under kernel2.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/iterationCount;   name=iterationCount -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/iterationCount"></a>
<code>iterationCount</code>
</dt>
<dd><p>The number of Richardson-Lucy iterations to perform on the data before returning.
If 0, the src buffer is coped to dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

              kvImageLeaveAlphaUnchanged  Operate only on the last 3 channels in memory. Leave the first channel
                                          unmodified.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888;name=start --><p>This routine iteratively uses the following formula:
      </p>
<pre>
		e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )

		where:
              e[0] = the observed image (src parameter)
              e[n] = the result of the nth iteration
              psf  = point spread function (kernel for call to convolution)
				x    = multiply operator
              '*'  = convolution operator
       </pre>
<p>The channels are operated on independently of one another. Consequently, this function will work on
any 4-channel interleaved 8-bit per component format (e.g. RGBA, BGRA...), not just ARGB. 
</p>
<p>The work in these functions is currently done internally with floating point precision. If you plan to call this function multiple times
(rather than with iterationCount &gt; 1) on 8-bit per channel images, you can save some computation by converting the 8-bit image data to
single precision floating-point yourself using something like vImageConvert_Planar8toPlanarF and iterating on the appropriate
floating-point Richardson Lucy variant. Convert back, when you are done.
</p>
<p>Does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF;   name=vImageRichardsonLucyDeConvolve_ARGBFFFF --><a name="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF"></a>
<h3><a name="vImageRichardsonLucyDeConvolve_ARGBFFFF">vImageRichardsonLucyDeConvolve_ARGBFFFF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF;name=start --><!-- begin abstract --></p>
<p>Perform N iterations of a Lucy-Richardson deconvolution on ARGBFFFF data
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF" logicalPath="//apple_ref/c/instm/vImageRichardsonLucyDeConvolve_ARGBFFFF //apple_ref/c/clm/vImageRichardsonLucyDeConvolve_ARGBFFFF //apple_ref/c/intfcm/vImageRichardsonLucyDeConvolve_ARGBFFFF //apple_ref/c/intfm/vImageRichardsonLucyDeConvolve_ARGBFFFF //apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF" target="_top"><span class="function">vImageRichardsonLucyDeConvolve_ARGBFFFF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel2</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height2</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width2</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_FFFF" logicalPath="//apple_ref/c/cl/Pixel_FFFF //apple_ref/c/tdef/Pixel_FFFF" target="_top"><span class="type">Pixel_FFFF</span></a> <span class="param">backgroundColor</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">iterationCount</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const float kernel[9] =   { 1./16, 2./16, 1./16,
                                                      2./16, 4./16, 2./16,
                                                      1./16, 2./16, 1./16 };
                           </pre>

<p>This is psf0 in the formula given in the discussion.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel2;   name=kernel2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel2"></a>
<code>kernel2</code>
</dt>
<dd><p>A pointer to a second 1D array of weights of dimension kernel_height2 x kernel_width2.
This is psf1 in the formula given in the discussion.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel1. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel1. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel_height2;   name=kernel_height2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel_height2"></a>
<code>kernel_height2</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel2. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel_width2;   name=kernel_width2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/kernel_width2"></a>
<code>kernel_width2</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel2. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/iterationCount;   name=iterationCount -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/iterationCount"></a>
<code>iterationCount</code>
</dt>
<dd><p>The number of Richardson-Lucy iterations to perform on the data before returning.
If 0, the src buffer is coped to dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_ARGBFFFF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

              kvImageLeaveAlphaUnchanged  Operate only on the last 3 channels in memory. Leave the first channel
                                          unmodified.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF;name=start --><p>This routine iteratively uses the following formula:
      </p>
<pre>
		e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )

		where:
              e[0] = the observed image (src parameter)
              e[n] = the result of the nth iteration
              psf  = point spread function (kernel for call to convolution)
				x    = multiply operator
              '*'  = convolution operator
       </pre>

<p>The channels are operated on independently of one another. Consequently, this function will work on
any 4-channel interleaved 8-bit per component format (e.g. RGBA, BGRA...), not just ARGB.
</p>
<p>Does not work in place.
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF;name=end --><!-- end discussion -->
</p>
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8;   name=vImageRichardsonLucyDeConvolve_Planar8 --><a name="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8"></a>
<h3><a name="vImageRichardsonLucyDeConvolve_Planar8">vImageRichardsonLucyDeConvolve_Planar8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8;name=start --><!-- begin abstract --></p>
<p>Perform N iterations of a Lucy-Richardson deconvolution on Planar8 data
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8" logicalPath="//apple_ref/c/instm/vImageRichardsonLucyDeConvolve_Planar8 //apple_ref/c/clm/vImageRichardsonLucyDeConvolve_Planar8 //apple_ref/c/intfcm/vImageRichardsonLucyDeConvolve_Planar8 //apple_ref/c/intfm/vImageRichardsonLucyDeConvolve_Planar8 //apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8" target="_top"><span class="function">vImageRichardsonLucyDeConvolve_Planar8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int16_t //apple_ref/c/tdef/int16_t //apple_ref/c/tag/int16_t //apple_ref/c/struct/int16_t //apple_ref/c/intf/int16_t //apple_ref/doc/anysymbol/int16_t" machineGenerated="true" --><span class="type">int16_t</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/int16_t //apple_ref/c/tdef/int16_t //apple_ref/c/tag/int16_t //apple_ref/c/struct/int16_t //apple_ref/c/intf/int16_t //apple_ref/doc/anysymbol/int16_t" machineGenerated="true" --><span class="type">int16_t</span><!-- /a --> <span class="type">*</span><span class="param">kernel2</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height2</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width2</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">divisor</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">divisor2</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8" logicalPath="//apple_ref/c/cl/Pixel_8 //apple_ref/c/tdef/Pixel_8" target="_top"><span class="type">Pixel_8</span></a> <span class="param">backgroundColor</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">iterationCount</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to receive the result image. 
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const int16_t kernel[9] = { 1, 2, 1,
                                                      2, 4, 2,
                                                      1, 2, 1 };
                           </pre>

<p>This is psf0 in the formula given in the discussion.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel2;   name=kernel2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel2"></a>
<code>kernel2</code>
</dt>
<dd><p>A pointer to a second 1D array of weights of dimension kernel_height2 x kernel_width2.
This is psf1 in the formula given in the discussion.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel1. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel1. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel_height2;   name=kernel_height2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel_height2"></a>
<code>kernel_height2</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel2. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel_width2;   name=kernel_width2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/kernel_width2"></a>
<code>kernel_width2</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel2. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/divisor;   name=divisor -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/divisor"></a>
<code>divisor</code>
</dt>
<dd><p>The divisor to use to correct for the volume under kernel.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/divisor2;   name=divisor2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/divisor2"></a>
<code>divisor2</code>
</dt>
<dd><p>The divisor to use to correct for the volume under kernel2.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/iterationCount;   name=iterationCount -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/iterationCount"></a>
<code>iterationCount</code>
</dt>
<dd><p>The number of Richardson-Lucy iterations to perform on the data before returning. 
If 0, the src buffer is coped to dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_Planar8/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8;name=start --><p>This routine iteratively uses the following formula:
      </p>
<pre>
		e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )

		where:
              e[0] = the observed image (src parameter)
              e[n] = the result of the nth iteration
              psf  = point spread function (kernel for call to convolution)
				x    = multiply operator
              '*'  = convolution operator
       </pre>

<p>The work in these functions is currently done internally with floating point precision. If you plan to call this function multiple times
(rather than with iterationCount &gt; 1) on 8-bit per channel images, you can save some computation by converting the 8-bit image data to
single precision floating-point yourself using something like vImageConvert_Planar8toPlanarF and iterating on the appropriate
floating-point Richardson Lucy variant. Convert back, when you are done.
</p>
<p>Does not work in place.
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8;name=end --><!-- end discussion -->
</p>
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF;   name=vImageRichardsonLucyDeConvolve_PlanarF --><a name="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF"></a>
<h3><a name="vImageRichardsonLucyDeConvolve_PlanarF">vImageRichardsonLucyDeConvolve_PlanarF</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF;name=start --><!-- begin abstract --></p>
<p>Perform N iterations of a Lucy-Richardson deconvolution on PlanarF data
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF" logicalPath="//apple_ref/c/instm/vImageRichardsonLucyDeConvolve_PlanarF //apple_ref/c/clm/vImageRichardsonLucyDeConvolve_PlanarF //apple_ref/c/intfcm/vImageRichardsonLucyDeConvolve_PlanarF //apple_ref/c/intfm/vImageRichardsonLucyDeConvolve_PlanarF //apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF" target="_top"><span class="function">vImageRichardsonLucyDeConvolve_PlanarF</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel</span>,
    <span class="keyword">const</span> <!-- a logicalPath="//apple_ref/c/cl/float //apple_ref/c/tdef/float //apple_ref/c/tag/float //apple_ref/c/struct/float //apple_ref/c/intf/float //apple_ref/doc/anysymbol/float" machineGenerated="true" --><span class="type">float</span><!-- /a --> <span class="type">*</span><span class="param">kernel2</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height2</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width2</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_F" logicalPath="//apple_ref/c/cl/Pixel_F //apple_ref/c/tdef/Pixel_F" target="_top"><span class="type">Pixel_F</span></a> <span class="param">backgroundColor</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">iterationCount</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/dest"></a>
<code>dest</code>
</dt>
<dd><p>A preallocated buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel;   name=kernel -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel"></a>
<code>kernel</code>
</dt>
<dd>
<p>A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
For example, for a simple 3x3 blur, it might be:
                          </p>
<pre>
                          const float kernel[9] =   { 1./16, 2./16, 1./16,
                                                      2./16, 4./16, 2./16,
                                                      1./16, 2./16, 1./16 };
                           </pre>

<p>This is psf0 in the formula given in the discussion.</p>
</dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel2;   name=kernel2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel2"></a>
<code>kernel2</code>
</dt>
<dd><p>A pointer to a second 1D array of weights of dimension kernel_height2 x kernel_width2.
This is psf1 in the formula given in the discussion.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel1. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel1. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel_height2;   name=kernel_height2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel_height2"></a>
<code>kernel_height2</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel2. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel_width2;   name=kernel_width2 -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/kernel_width2"></a>
<code>kernel_width2</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel2. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/iterationCount;   name=iterationCount -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/iterationCount"></a>
<code>iterationCount</code>
</dt>
<dd><p>The number of Richardson-Lucy iterations to perform on the data before returning.
If 0, the src buffer is coped to dest.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageRichardsonLucyDeConvolve_PlanarF/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageNullPointerArgument  kernel may not be NULL

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF;name=start --><p>This routine iteratively uses the following formula:
      </p>
<pre>
		e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )

		where:
              e[0] = the observed image (src parameter)
              e[n] = the result of the nth iteration
              psf  = point spread function (kernel for call to convolution)
				x    = multiply operator
              '*'  = convolution operator
       </pre>

<p>Does not work in place.
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF;name=end --><!-- end discussion -->
</p>
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageTentConvolve_ARGB8888;   name=vImageTentConvolve_ARGB8888 --><a name="//apple_ref/c/func/vImageTentConvolve_ARGB8888"></a>
<h3><a name="vImageTentConvolve_ARGB8888">vImageTentConvolve_ARGB8888</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageTentConvolve_ARGB8888;name=start --><!-- begin abstract --></p>
<p>Special purpose tent convolution on a 4-channel interleaved, 8-bit per channel image.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageTentConvolve_ARGB8888;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageTentConvolve_ARGB8888;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageTentConvolve_ARGB8888" logicalPath="//apple_ref/c/instm/vImageTentConvolve_ARGB8888 //apple_ref/c/clm/vImageTentConvolve_ARGB8888 //apple_ref/c/intfcm/vImageTentConvolve_ARGB8888 //apple_ref/c/intfm/vImageTentConvolve_ARGB8888 //apple_ref/c/func/vImageTentConvolve_ARGB8888" target="_top"><span class="function">vImageTentConvolve_ARGB8888</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8888" logicalPath="//apple_ref/c/cl/Pixel_8888 //apple_ref/c/tdef/Pixel_8888" target="_top"><span class="type">Pixel_8888</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageTentConvolve_ARGB8888;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_ARGB8888/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageLeaveAlphaUnchanged  Apply the convolution to the last three channels in memory, only.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageTentConvolve_ARGB8888;name=start --><p>This filter applies a tent filter to a 4-channel interleaved, 8-bit per channel imagee.
A tent filter uses a much faster algorithm than a standard convolution, and may be a good
solution for real time application of large blur radii against images.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              int sumA = 0;
              int sumR = 0;
              int sumG = 0;
              int sumB = 0;
              int divisor = 0;

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sumA += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][0];
                  sumR += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][1];
                  sumG += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][2];
                  sumB += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][3];
                  divisor += kernel_element[i][j];
              }
              // Correct for the scaling introduced by multiplying by the weights table
              sumA = (sumA + divisor/2) / divisor;
              sumR = (sumR + divisor/2) / divisor;
              sumG = (sumG + divisor/2) / divisor;
              sumB = (sumB + divisor/2) / divisor;

              // write out result
              result[y][x][0] = CLAMP(sumA, 0, 255);
              result[y][x][1] = CLAMP(sumR, 0, 255);
              result[y][x][2] = CLAMP(sumG, 0, 255);
              result[y][x][3] = CLAMP(sumB, 0, 255);
          }
       </pre>

<p>This filter does not work in place.
</p>
<p>This filter will work without modification for other byte orders such as RGBA, BGRA, AGBR, CMYK, etc.
The image should be non-premultiplied to avoid odd results in non-opaque regions.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageTentConvolve_ARGB8888;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<hr class="betweenAPIEntries">
<!-- headerDoc=func;  uid=//apple_ref/c/func/vImageTentConvolve_Planar8;   name=vImageTentConvolve_Planar8 --><a name="//apple_ref/c/func/vImageTentConvolve_Planar8"></a>
<h3><a name="vImageTentConvolve_Planar8">vImageTentConvolve_Planar8</a></h3>
<hr class="afterName">
<p><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageTentConvolve_Planar8;name=start --><!-- begin abstract --></p>
<p>Special purpose tent convolution on a Planar8 image.
<!-- end abstract --><!-- headerDoc=abstract;uid=//apple_ref/c/func/vImageTentConvolve_Planar8;name=end --></p>
<div class="declaration_indent">
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageTentConvolve_Planar8;name=start --><a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/doc/title:tdef/vImage_Error" logicalPath="//apple_ref/c/cl/vImage_Error //apple_ref/c/tdef/vImage_Error //apple_ref/c/tag/vImage_Error //apple_ref/c/struct/vImage_Error //apple_ref/c/intf/vImage_Error //apple_ref/doc/anysymbol/vImage_Error" target="_top"><span class="type">vImage_Error</span></a> <a machinegenerated="true" href="index.html#//apple_ref/c/func/vImageTentConvolve_Planar8" logicalPath="//apple_ref/c/instm/vImageTentConvolve_Planar8 //apple_ref/c/clm/vImageTentConvolve_Planar8 //apple_ref/c/intfcm/vImageTentConvolve_Planar8 //apple_ref/c/intfm/vImageTentConvolve_Planar8 //apple_ref/c/func/vImageTentConvolve_Planar8" target="_top"><span class="function">vImageTentConvolve_Planar8</span></a>(
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">src</span>,
    <span class="keyword">const</span> <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Buffer" logicalPath="//apple_ref/c/cl/vImage_Buffer //apple_ref/c/tdef/vImage_Buffer" target="_top"><span class="type">vImage_Buffer</span></a> <span class="type">*</span><span class="param">dest</span>,
    <!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <span class="type">*</span><span class="param">tempBuffer</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_X</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImagePixelCount" logicalPath="//apple_ref/c/cl/vImagePixelCount //apple_ref/c/tdef/vImagePixelCount" target="_top"><span class="type">vImagePixelCount</span></a> <span class="param">srcOffsetToROI_Y</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_height</span>,
    <!-- a logicalPath="//apple_ref/c/cl/uint32_t //apple_ref/c/tdef/uint32_t //apple_ref/c/tag/uint32_t //apple_ref/c/struct/uint32_t //apple_ref/c/intf/uint32_t //apple_ref/doc/anysymbol/uint32_t" machineGenerated="true" --><span class="type">uint32_t</span><!-- /a --> <span class="param">kernel_width</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/Pixel_8" logicalPath="//apple_ref/c/cl/Pixel_8 //apple_ref/c/tdef/Pixel_8" target="_top"><span class="type">Pixel_8</span></a> <span class="param">backgroundColor</span>,
    <a machinegenerated="true" href="../vImage_Types_h/index.html#//apple_ref/c/tdef/vImage_Flags" logicalPath="//apple_ref/c/cl/vImage_Flags //apple_ref/c/tdef/vImage_Flags" target="_top"><span class="type">vImage_Flags</span></a> <span class="param">flags</span> ) ;  <!-- headerDoc=declaration;uid=//apple_ref/c/func/vImageTentConvolve_Planar8;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<div class="param_indent">
<dl>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/src;   name=src -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/src"></a>
<code>src</code>
</dt>
<dd><p>The input image</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/dest;   name=dest -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/dest"></a>
<code>dest</code>
</dt>
<dd><p>A pointer to a preallocated vImage_Buffer to receive the result image.
This may not alias the src image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/tempBuffer;   name=tempBuffer -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/tempBuffer"></a>
<code>tempBuffer</code>
</dt>
<dd><p>An optional pointer to a region of memory to use as a working area during
computation.  The size of the tempBuffer is given by calling the function
with the same parameters and the kvImageGetTempBufferSize flag, in which case
the size is returned instead of an error code from the left hand side.
You may pass NULL here, in which case a region of memory of similar size
will be allocated by the function and freed before it returns.  Temp Buffers
are a way of avoiding lost time due to VM faults to initialize newly allocated
buffers. If you will be calling this function repeatedly with similar parameters
you should use a temp buffer. If the function is called from different threads
concurrently, a different temp buffer should be used for each.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/srcOffsetToROI_X;   name=srcOffsetToROI_X -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/srcOffsetToROI_X"></a>
<code>srcOffsetToROI_X</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the left edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/srcOffsetToROI_Y;   name=srcOffsetToROI_Y -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/srcOffsetToROI_Y"></a>
<code>srcOffsetToROI_Y</code>
</dt>
<dd><p>An offset used in tiling to shift the position of the destination image
relative to the src image. Typically this is 0. Non-Zero values are needed
when the destination tile is not aligned with the top edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/kernel_height;   name=kernel_height -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/kernel_height"></a>
<code>kernel_height</code>
</dt>
<dd><p>The height of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/kernel_width;   name=kernel_width -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/kernel_width"></a>
<code>kernel_width</code>
</dt>
<dd><p>The width of the 2D table of weights passed in as kernel. It must be an odd number.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/backgroundColor;   name=backgroundColor -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/backgroundColor"></a>
<code>backgroundColor</code>
</dt>
<dd><p>When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
parameter provides the background color to be used for missing pixels when the
kernel extends off the edge of the image.</p></dd>
<dt>
<!-- headerDoc=functionparam;  uid=//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/flags;   name=flags -->
<a name="//apple_ref/doc/functionparam/vImageTentConvolve_Planar8/flags"></a>
<code>flags</code>
</dt>
<dd>
<p>The following flags are allowed:
      </p>
<pre>
              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
                                          copy the corresponding source pixel to the destination. This
                                          will result in a ring on unconvolved content at the edges
                                          and convolved content in the middle.

              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
                                          For a blur filter this will look like the edges of the image
                                          have been blurred into a particular color. This is usually
                                          appropriate when the color of the surface onto which the image
                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
                                          as a background color, and let the downstream image compositor
                                          blend in the background color. In this case, the result image
                                          should be treated as a premultiplied image.

              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
                                          This is better when the image is drawn into a frame or other
                                          context where the background is not expected to contribute to
                                          the final content.

              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
                                          simply ignored, and the bias and divisor are adjusted accordingly.
                                          Because of the complication at the edges, this edging mode can
                                          be significantly slower than the others. It can be numerically
                                          unstable if the sum over any rectangular subsection of the kernel
                                          is zero, which can result in division by zero during the computation.
                                          The results for this edging mode are usually quite visually similar
                                          to kvImageEdgeExtend.

              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
                                          size of the temp buffer needed for this set of parameters. Does
                                          not touch the src or dest image.

              kvImageDoNotTile            Disable internal multithreading.

       </pre>
<p>The first four flags listed are edging modes. One and only one edging mode must be
provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
be returned.</p>
</dd>
</dl>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --></p>
<p>One of the following error codes may be returned:
      </p>
<pre>
          kvImageNoError              Success.
              &gt;= 0                    If kvImageGetTempBufferSize is passed, this is the size of
                                      the temp buffer to use with this function and this set of
                                      parameters.

          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
                                           kvImageEdgeExtend,  kvImageTruncateKernel }

          kvImageRoiLargerThanInputBuffer The dest-&gt;width and height must be less than or equal
                                          to corresponding dimensions of the source buffer.

          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X &gt; src-&gt;width

          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y &gt; src-&gt;height

          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.

          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
       </pre>

<!-- end return value --><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageTentConvolve_Planar8;name=start --><p>This filter applies a tent filter to a Planar8 image.  A tent filter uses a much faster algorithm
than a standard convolution, and may be a good solution for real time application of large blur
radii against images.
For each pixel:
      </p>
<pre>
          for each pixel[y][x] in image{
              int sum = 0;
              int divisor = 0;

              // Calculate weighted average over kernel area
              for each kernel_element[i][j] in kernel{
                  sum += kernel_element[i][j] *
                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
                               [x+j+srcOffsetToROI_X- kernel_width/2];
                  divisor += kernel_element[i][j];
              }

              // Correct for the scaling introduced by multiplying by the weights table
              sum = (sum + divisor/2) / divisor;

              // write out result
              result[y][x] = CLAMP(sum, 0, 255);
          }
       </pre>

<p>This filter does not work in place.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/vImageTentConvolve_Planar8;name=end --><!-- end discussion -->
<dl>
<dt><b>Availability</b></dt>
<dd> Available in Mac OS X v10.4. Available in iOS v5.0.</dd>
</dl>
<p class="gapBeforeFooter">&nbsp;</p>
<hr class="afterFooter">
<div class="hd_copyright_and_timestamp">
<p class="hd_copyright">&copy; Copyright (c) 2002-2015 by Apple Inc. All rights reserved.

 </p>
<p class="hd_timestamp">Last Updated: Thursday, December 24, 2015
</p>
</div>
</td>
</tr></table>
</body>
</html>
